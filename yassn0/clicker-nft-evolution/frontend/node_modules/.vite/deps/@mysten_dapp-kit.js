import { i as __toESM$1, n as __commonJS$1, t as require_react } from "./react-BSaYXCBM.js";
import "./react-dom-Cq1CbmpW.js";
import { t as require_jsx_runtime } from "./jsx-runtime-wvvcSeDi.js";
import { $ as Root, Dt as composeRefs, J as Close, Q as Portal, Y as Content, Z as Overlay, d as Separator2, et as Title, h as Trigger$1, i as Item2, n as Content2, q as require_shim, s as Portal2, tt as Trigger, u as Root2 } from "./dist-DYwMf23X.js";
import { $ as abytes, B as add4L, C as optional, D as string, Dt as toHex, E as safeParse, Et as fromHex, F as blake2b, G as rotrSH, H as add5L, I as add, J as shrSL, K as rotrSL, L as add3H, N as suiBcs, O as uuid, Ot as fromBase64, Q as Hash, R as add3L, S as object, T as pipe, U as rotrBH, V as add5H, W as rotrBL, X as HashMD, Y as split, Z as SHA512_IV, _ as array, at as clean, b as literal, ct as createView, dt as kdfInputToBytes, et as aexists, ft as randomBytes, it as checkOpts, jt as bech32, k as variant, kt as toBase64, lt as hexToBytes, mt as SUI_ADDRESS_LENGTH, nt as anumber, ot as concatBytes, pt as toBytes, q as shrSH, rt as bytesToHex, st as createHasher, t as Transaction, tt as ahash, ut as isBytes, w as parse$1, wt as bcs, x as number, y as boolean, yt as normalizeSuiAddress, z as add4H } from "./Transaction-DWkJnoaJ.js";
import { s as promiseWithResolvers } from "./transactions-xpJqUSDW.js";
import { n as isSuiJsonRpcClient, r as getFullnodeUrl, t as SuiJsonRpcClient } from "./client-M2E3EHme.js";
import { g as useQueries, h as useQuery, l as queryOptions, m as useSuspenseQuery, r as useMutation, t as useInfiniteQuery } from "./modern-Dfpvzq22.js";

//#region node_modules/.pnpm/clsx@2.1.1/node_modules/clsx/dist/clsx.mjs
function r(e) {
	var t, f, n = "";
	if ("string" == typeof e || "number" == typeof e) n += e;
	else if ("object" == typeof e) if (Array.isArray(e)) {
		var o = e.length;
		for (t = 0; t < o; t++) e[t] && (f = r(e[t])) && (n && (n += " "), n += f);
	} else for (f in e) e[f] && (n && (n += " "), n += f);
	return n;
}
function clsx() {
	for (var e, t, f = 0, n = "", o = arguments.length; f < o; f++) (e = arguments[f]) && (t = r(e)) && (n && (n += " "), n += t);
	return n;
}
var clsx_default = clsx;

//#endregion
//#region node_modules/.pnpm/@mysten+sui@1.45.2_typescript@5.9.3/node_modules/@mysten/sui/dist/esm/utils/format.js
var ELLIPSIS = "â€¦";
function formatAddress(address) {
	if (address.length <= 6) return address;
	const offset = address.startsWith("0x") ? 2 : 0;
	return `0x${address.slice(offset, offset + 4)}${ELLIPSIS}${address.slice(-4)}`;
}

//#endregion
//#region node_modules/.pnpm/@wallet-standard+app@1.1.0/node_modules/@wallet-standard/app/lib/esm/wallets.js
var __classPrivateFieldGet$1 = void 0 && (void 0).__classPrivateFieldGet || function(receiver, state, kind, f) {
	if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
	if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
	return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet$1 = void 0 && (void 0).__classPrivateFieldSet || function(receiver, state, value, kind, f) {
	if (kind === "m") throw new TypeError("Private method is not writable");
	if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
	if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
	return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var _AppReadyEvent_detail;
var wallets = void 0;
var registeredWalletsSet = /* @__PURE__ */ new Set();
function addRegisteredWallet(wallet) {
	cachedWalletsArray = void 0;
	registeredWalletsSet.add(wallet);
}
function removeRegisteredWallet(wallet) {
	cachedWalletsArray = void 0;
	registeredWalletsSet.delete(wallet);
}
var listeners = {};
/**
* Get an API for {@link Wallets.get | getting}, {@link Wallets.on | listening for}, and
* {@link Wallets.register | registering} {@link "@wallet-standard/base".Wallet | Wallets}.
*
* When called for the first time --
*
* This dispatches a {@link "@wallet-standard/base".WindowAppReadyEvent} to notify each Wallet that the app is ready
* to register it.
*
* This also adds a listener for {@link "@wallet-standard/base".WindowRegisterWalletEvent} to listen for a notification
* from each Wallet that the Wallet is ready to be registered by the app.
*
* This combination of event dispatch and listener guarantees that each Wallet will be registered synchronously as soon
* as the app is ready whether the app loads before or after each Wallet.
*
* @return API for getting, listening for, and registering Wallets.
*
* @group App
*/
function getWallets() {
	if (wallets) return wallets;
	wallets = Object.freeze({
		register,
		get: get$1,
		on
	});
	if (typeof window === "undefined") return wallets;
	const api = Object.freeze({ register });
	try {
		window.addEventListener("wallet-standard:register-wallet", ({ detail: callback }) => callback(api));
	} catch (error) {
		console.error("wallet-standard:register-wallet event listener could not be added\n", error);
	}
	try {
		window.dispatchEvent(new AppReadyEvent(api));
	} catch (error) {
		console.error("wallet-standard:app-ready event could not be dispatched\n", error);
	}
	return wallets;
}
function register(...wallets$1) {
	wallets$1 = wallets$1.filter((wallet) => !registeredWalletsSet.has(wallet));
	if (!wallets$1.length) return () => {};
	wallets$1.forEach((wallet) => addRegisteredWallet(wallet));
	listeners["register"]?.forEach((listener) => guard(() => listener(...wallets$1)));
	return function unregister() {
		wallets$1.forEach((wallet) => removeRegisteredWallet(wallet));
		listeners["unregister"]?.forEach((listener) => guard(() => listener(...wallets$1)));
	};
}
var cachedWalletsArray;
function get$1() {
	if (!cachedWalletsArray) cachedWalletsArray = [...registeredWalletsSet];
	return cachedWalletsArray;
}
function on(event, listener) {
	listeners[event]?.push(listener) || (listeners[event] = [listener]);
	return function off() {
		listeners[event] = listeners[event]?.filter((existingListener) => listener !== existingListener);
	};
}
function guard(callback) {
	try {
		callback();
	} catch (error) {
		console.error(error);
	}
}
var AppReadyEvent = class extends Event {
	get detail() {
		return __classPrivateFieldGet$1(this, _AppReadyEvent_detail, "f");
	}
	get type() {
		return "wallet-standard:app-ready";
	}
	constructor(api) {
		super("wallet-standard:app-ready", {
			bubbles: false,
			cancelable: false,
			composed: false
		});
		_AppReadyEvent_detail.set(this, void 0);
		__classPrivateFieldSet$1(this, _AppReadyEvent_detail, api, "f");
	}
	/** @deprecated */
	preventDefault() {
		throw new Error("preventDefault cannot be called");
	}
	/** @deprecated */
	stopImmediatePropagation() {
		throw new Error("stopImmediatePropagation cannot be called");
	}
	/** @deprecated */
	stopPropagation() {
		throw new Error("stopPropagation cannot be called");
	}
};
_AppReadyEvent_detail = /* @__PURE__ */ new WeakMap();

//#endregion
//#region node_modules/.pnpm/@wallet-standard+features@1.1.0/node_modules/@wallet-standard/features/lib/esm/connect.js
/** Name of the feature. */
const StandardConnect = "standard:connect";

//#endregion
//#region node_modules/.pnpm/@wallet-standard+features@1.1.0/node_modules/@wallet-standard/features/lib/esm/events.js
/** Name of the feature. */
const StandardEvents = "standard:events";

//#endregion
//#region node_modules/.pnpm/@wallet-standard+wallet@1.1.0/node_modules/@wallet-standard/wallet/lib/esm/util.js
var __classPrivateFieldGet = void 0 && (void 0).__classPrivateFieldGet || function(receiver, state, kind, f) {
	if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
	if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
	return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = void 0 && (void 0).__classPrivateFieldSet || function(receiver, state, value, kind, f) {
	if (kind === "m") throw new TypeError("Private method is not writable");
	if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
	if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
	return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var _ReadonlyWalletAccount_address, _ReadonlyWalletAccount_publicKey, _ReadonlyWalletAccount_chains, _ReadonlyWalletAccount_features, _ReadonlyWalletAccount_label, _ReadonlyWalletAccount_icon;
/**
* Base implementation of a {@link "@wallet-standard/base".WalletAccount} to be used or extended by a
* {@link "@wallet-standard/base".Wallet}.
*
* `WalletAccount` properties must be read-only. This class enforces this by making all properties
* [truly private](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/Private_class_fields) and
* read-only, using getters for access, returning copies instead of references, and calling
* [Object.freeze](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze)
* on the instance.
*
* @group Account
*/
var ReadonlyWalletAccount = class ReadonlyWalletAccount {
	/** Implementation of {@link "@wallet-standard/base".WalletAccount.address | WalletAccount::address} */
	get address() {
		return __classPrivateFieldGet(this, _ReadonlyWalletAccount_address, "f");
	}
	/** Implementation of {@link "@wallet-standard/base".WalletAccount.publicKey | WalletAccount::publicKey} */
	get publicKey() {
		return __classPrivateFieldGet(this, _ReadonlyWalletAccount_publicKey, "f").slice();
	}
	/** Implementation of {@link "@wallet-standard/base".WalletAccount.chains | WalletAccount::chains} */
	get chains() {
		return __classPrivateFieldGet(this, _ReadonlyWalletAccount_chains, "f").slice();
	}
	/** Implementation of {@link "@wallet-standard/base".WalletAccount.features | WalletAccount::features} */
	get features() {
		return __classPrivateFieldGet(this, _ReadonlyWalletAccount_features, "f").slice();
	}
	/** Implementation of {@link "@wallet-standard/base".WalletAccount.label | WalletAccount::label} */
	get label() {
		return __classPrivateFieldGet(this, _ReadonlyWalletAccount_label, "f");
	}
	/** Implementation of {@link "@wallet-standard/base".WalletAccount.icon | WalletAccount::icon} */
	get icon() {
		return __classPrivateFieldGet(this, _ReadonlyWalletAccount_icon, "f");
	}
	/**
	* Create and freeze a read-only account.
	*
	* @param account Account to copy properties from.
	*/
	constructor(account) {
		_ReadonlyWalletAccount_address.set(this, void 0);
		_ReadonlyWalletAccount_publicKey.set(this, void 0);
		_ReadonlyWalletAccount_chains.set(this, void 0);
		_ReadonlyWalletAccount_features.set(this, void 0);
		_ReadonlyWalletAccount_label.set(this, void 0);
		_ReadonlyWalletAccount_icon.set(this, void 0);
		if (new.target === ReadonlyWalletAccount) Object.freeze(this);
		__classPrivateFieldSet(this, _ReadonlyWalletAccount_address, account.address, "f");
		__classPrivateFieldSet(this, _ReadonlyWalletAccount_publicKey, account.publicKey.slice(), "f");
		__classPrivateFieldSet(this, _ReadonlyWalletAccount_chains, account.chains.slice(), "f");
		__classPrivateFieldSet(this, _ReadonlyWalletAccount_features, account.features.slice(), "f");
		__classPrivateFieldSet(this, _ReadonlyWalletAccount_label, account.label, "f");
		__classPrivateFieldSet(this, _ReadonlyWalletAccount_icon, account.icon, "f");
	}
};
_ReadonlyWalletAccount_address = /* @__PURE__ */ new WeakMap(), _ReadonlyWalletAccount_publicKey = /* @__PURE__ */ new WeakMap(), _ReadonlyWalletAccount_chains = /* @__PURE__ */ new WeakMap(), _ReadonlyWalletAccount_features = /* @__PURE__ */ new WeakMap(), _ReadonlyWalletAccount_label = /* @__PURE__ */ new WeakMap(), _ReadonlyWalletAccount_icon = /* @__PURE__ */ new WeakMap();

//#endregion
//#region node_modules/.pnpm/@mysten+wallet-standard@0.19.9_typescript@5.9.3/node_modules/@mysten/wallet-standard/dist/esm/wallet.js
async function signTransaction(wallet, input) {
	if (wallet.features["sui:signTransaction"]) return wallet.features["sui:signTransaction"].signTransaction(input);
	if (!wallet.features["sui:signTransactionBlock"]) throw new Error(`Provided wallet (${wallet.name}) does not support the signTransaction feature.`);
	const { signTransactionBlock } = wallet.features["sui:signTransactionBlock"];
	const { transactionBlockBytes, signature } = await signTransactionBlock({
		transactionBlock: Transaction.from(await input.transaction.toJSON()),
		account: input.account,
		chain: input.chain
	});
	return {
		bytes: transactionBlockBytes,
		signature
	};
}

//#endregion
//#region node_modules/.pnpm/@mysten+wallet-standard@0.19.9_typescript@5.9.3/node_modules/@mysten/wallet-standard/dist/esm/detect.js
var REQUIRED_FEATURES = [StandardConnect, StandardEvents];
function isWalletWithRequiredFeatureSet(wallet, additionalFeatures = []) {
	return [...REQUIRED_FEATURES, ...additionalFeatures].every((feature) => feature in wallet.features);
}

//#endregion
//#region node_modules/.pnpm/@mysten+wallet-standard@0.19.9_typescript@5.9.3/node_modules/@mysten/wallet-standard/dist/esm/chains.js
var SUI_DEVNET_CHAIN = "sui:devnet";
var SUI_TESTNET_CHAIN = "sui:testnet";
var SUI_LOCALNET_CHAIN = "sui:localnet";
var SUI_MAINNET_CHAIN = "sui:mainnet";
var SUI_CHAINS = [
	SUI_DEVNET_CHAIN,
	SUI_TESTNET_CHAIN,
	SUI_LOCALNET_CHAIN,
	SUI_MAINNET_CHAIN
];

//#endregion
//#region node_modules/.pnpm/mitt@3.0.1/node_modules/mitt/dist/mitt.mjs
function mitt_default(n) {
	return {
		all: n = n || /* @__PURE__ */ new Map(),
		on: function(t, e) {
			var i = n.get(t);
			i ? i.push(e) : n.set(t, [e]);
		},
		off: function(t, e) {
			var i = n.get(t);
			i && (e ? i.splice(i.indexOf(e) >>> 0, 1) : n.set(t, []));
		},
		emit: function(t, e) {
			var i = n.get(t);
			i && i.slice().map(function(n$1) {
				n$1(e);
			}), (i = n.get("*")) && i.slice().map(function(n$1) {
				n$1(t, e);
			});
		}
	};
}

//#endregion
//#region node_modules/.pnpm/jose@6.1.3/node_modules/jose/dist/webapi/lib/buffer_utils.js
const encoder = new TextEncoder();
const decoder = new TextDecoder();
var MAX_INT32 = 2 ** 32;

//#endregion
//#region node_modules/.pnpm/jose@6.1.3/node_modules/jose/dist/webapi/lib/base64.js
function decodeBase64(encoded) {
	if (Uint8Array.fromBase64) return Uint8Array.fromBase64(encoded);
	const binary = atob(encoded);
	const bytes = new Uint8Array(binary.length);
	for (let i = 0; i < binary.length; i++) bytes[i] = binary.charCodeAt(i);
	return bytes;
}

//#endregion
//#region node_modules/.pnpm/jose@6.1.3/node_modules/jose/dist/webapi/util/base64url.js
function decode(input) {
	if (Uint8Array.fromBase64) return Uint8Array.fromBase64(typeof input === "string" ? input : decoder.decode(input), { alphabet: "base64url" });
	let encoded = input;
	if (encoded instanceof Uint8Array) encoded = decoder.decode(encoded);
	encoded = encoded.replace(/-/g, "+").replace(/_/g, "/");
	try {
		return decodeBase64(encoded);
	} catch {
		throw new TypeError("The input to be decoded is not correctly encoded.");
	}
}

//#endregion
//#region node_modules/.pnpm/jose@6.1.3/node_modules/jose/dist/webapi/util/errors.js
var JOSEError = class extends Error {
	static code = "ERR_JOSE_GENERIC";
	code = "ERR_JOSE_GENERIC";
	constructor(message, options) {
		super(message, options);
		this.name = this.constructor.name;
		Error.captureStackTrace?.(this, this.constructor);
	}
};
var JWTInvalid = class extends JOSEError {
	static code = "ERR_JWT_INVALID";
	code = "ERR_JWT_INVALID";
};
var JWKSMultipleMatchingKeys = class extends JOSEError {
	[Symbol.asyncIterator];
	static code = "ERR_JWKS_MULTIPLE_MATCHING_KEYS";
	code = "ERR_JWKS_MULTIPLE_MATCHING_KEYS";
	constructor(message = "multiple matching keys found in the JSON Web Key Set", options) {
		super(message, options);
	}
};

//#endregion
//#region node_modules/.pnpm/jose@6.1.3/node_modules/jose/dist/webapi/lib/is_object.js
var isObjectLike = (value) => typeof value === "object" && value !== null;
function isObject(input) {
	if (!isObjectLike(input) || Object.prototype.toString.call(input) !== "[object Object]") return false;
	if (Object.getPrototypeOf(input) === null) return true;
	let proto = input;
	while (Object.getPrototypeOf(proto) !== null) proto = Object.getPrototypeOf(proto);
	return Object.getPrototypeOf(input) === proto;
}

//#endregion
//#region node_modules/.pnpm/jose@6.1.3/node_modules/jose/dist/webapi/util/decode_jwt.js
function decodeJwt(jwt) {
	if (typeof jwt !== "string") throw new JWTInvalid("JWTs must use Compact JWS serialization, JWT must be a string");
	const { 1: payload, length } = jwt.split(".");
	if (length === 5) throw new JWTInvalid("Only JWTs using Compact JWS serialization can be decoded");
	if (length !== 3) throw new JWTInvalid("Invalid JWT");
	if (!payload) throw new JWTInvalid("JWTs must contain a payload");
	let decoded;
	try {
		decoded = decode(payload);
	} catch {
		throw new JWTInvalid("Failed to base64url decode the payload");
	}
	let result;
	try {
		result = JSON.parse(decoder.decode(decoded));
	} catch {
		throw new JWTInvalid("Failed to parse the decoded payload as JSON");
	}
	if (!isObject(result)) throw new JWTInvalid("Invalid JWT Claims Set");
	return result;
}

//#endregion
//#region node_modules/.pnpm/@mysten+window-wallet-core@0.1.1_typescript@5.9.3/node_modules/@mysten/window-wallet-core/dist/esm/jwt-session/index.js
var AccountSchema = object({
	address: string(),
	publicKey: string()
});
var JwtSessionSchema = object({
	exp: number(),
	iat: number(),
	iss: string(),
	aud: string(),
	payload: object({ accounts: array(AccountSchema) })
});
function decodeJwtSession(jwt) {
	const decodedJwt = decodeJwt(jwt);
	return parse$1(JwtSessionSchema, decodedJwt);
}

//#endregion
//#region node_modules/.pnpm/@mysten+window-wallet-core@0.1.1_typescript@5.9.3/node_modules/@mysten/window-wallet-core/dist/esm/web-wallet-channel/responses.js
var ResponseData = variant("type", [
	object({
		type: literal("connect"),
		session: string("`session` is required")
	}),
	object({
		type: literal("sign-transaction"),
		bytes: string(),
		signature: string()
	}),
	object({
		type: literal("sign-and-execute-transaction"),
		bytes: string(),
		signature: string(),
		digest: string(),
		effects: string()
	}),
	object({
		type: literal("sign-personal-message"),
		bytes: string(),
		signature: string()
	})
]);
var ResponsePayload = variant("type", [object({
	type: literal("reject"),
	reason: optional(string("`reason` must be a string"))
}), object({
	type: literal("resolve"),
	data: ResponseData
})]);
var Response = object({
	id: pipe(string(), uuid()),
	source: literal("web-wallet-channel"),
	payload: ResponsePayload,
	version: literal("1")
});

//#endregion
//#region node_modules/.pnpm/@mysten+window-wallet-core@0.1.1_typescript@5.9.3/node_modules/@mysten/window-wallet-core/dist/esm/web-wallet-channel/utils.js
function getClientMetadata() {
	return {
		version: "1",
		originUrl: window.location.href,
		userAgent: navigator.userAgent,
		screenResolution: `${window.screen.width}x${window.screen.height}`,
		language: navigator.language,
		platform: navigator.platform,
		timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
		timestamp: Date.now()
	};
}

//#endregion
//#region node_modules/.pnpm/@mysten+window-wallet-core@0.1.1_typescript@5.9.3/node_modules/@mysten/window-wallet-core/dist/esm/web-wallet-channel/dapp-post-message-channel.js
var __typeError$2 = (msg) => {
	throw TypeError(msg);
};
var __accessCheck$2 = (obj, member, msg) => member.has(obj) || __typeError$2("Cannot " + msg);
var __privateGet$2 = (obj, member, getter) => (__accessCheck$2(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd$2 = (obj, member, value) => member.has(obj) ? __typeError$2("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet$1 = (obj, member, value, setter) => (__accessCheck$2(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod$1 = (obj, member, method) => (__accessCheck$2(obj, member, "access private method"), method);
var _popup, _version, _id$1, _hostOrigin, _hostPathname, _appName, _extraRequestOptions, _promise, _resolve, _reject, _interval, _isSendCalled, _listener, _DappPostMessageChannel_instances, cleanup_fn;
var DappPostMessageChannel = class {
	constructor({ appName, hostOrigin, hostPathname = "dapp-request", extraRequestOptions, popupWindow }) {
		__privateAdd$2(this, _DappPostMessageChannel_instances);
		__privateAdd$2(this, _popup);
		__privateAdd$2(this, _version, "1");
		__privateAdd$2(this, _id$1);
		__privateAdd$2(this, _hostOrigin);
		__privateAdd$2(this, _hostPathname);
		__privateAdd$2(this, _appName);
		__privateAdd$2(this, _extraRequestOptions);
		__privateAdd$2(this, _promise);
		__privateAdd$2(this, _resolve);
		__privateAdd$2(this, _reject);
		__privateAdd$2(this, _interval, null);
		__privateAdd$2(this, _isSendCalled, false);
		__privateAdd$2(this, _listener, (event) => {
			if (event.origin !== __privateGet$2(this, _hostOrigin)) return;
			const { success, output } = safeParse(Response, event.data);
			if (!success || output.id !== __privateGet$2(this, _id$1)) return;
			__privateMethod$1(this, _DappPostMessageChannel_instances, cleanup_fn).call(this);
			if (output.payload.type === "reject") __privateGet$2(this, _reject).call(this, /* @__PURE__ */ new Error("User rejected the request"));
			else if (output.payload.type === "resolve") __privateGet$2(this, _resolve).call(this, output.payload.data);
		});
		const popup = popupWindow ?? window.open("about:blank", "_blank");
		if (!popup) throw new Error("Failed to open new window");
		__privateSet$1(this, _id$1, crypto.randomUUID());
		__privateSet$1(this, _popup, popup);
		__privateSet$1(this, _hostOrigin, hostOrigin);
		__privateSet$1(this, _hostPathname, hostPathname);
		__privateSet$1(this, _appName, appName);
		const { promise, resolve, reject } = promiseWithResolvers();
		__privateSet$1(this, _promise, promise);
		__privateSet$1(this, _resolve, resolve);
		__privateSet$1(this, _reject, reject);
		__privateSet$1(this, _extraRequestOptions, extraRequestOptions);
		__privateSet$1(this, _interval, setInterval(() => {
			try {
				if (__privateGet$2(this, _popup).closed) {
					__privateMethod$1(this, _DappPostMessageChannel_instances, cleanup_fn).call(this);
					reject(/* @__PURE__ */ new Error("User closed the wallet window"));
				}
			} catch {}
		}, 1e3));
	}
	send({ type, ...data }) {
		if (__privateGet$2(this, _popup).closed) throw new Error("User closed the wallet window");
		if (__privateGet$2(this, _isSendCalled)) throw new Error("send() can only be called once");
		__privateSet$1(this, _isSendCalled, true);
		window.addEventListener("message", __privateGet$2(this, _listener));
		const requestData = {
			version: __privateGet$2(this, _version),
			requestId: __privateGet$2(this, _id$1),
			appUrl: window.location.href.split("#")[0],
			appName: __privateGet$2(this, _appName),
			payload: {
				type,
				...data
			},
			metadata: getClientMetadata(),
			extraRequestOptions: __privateGet$2(this, _extraRequestOptions)
		};
		const encodedRequestData = encodeURIComponent(btoa(JSON.stringify(requestData)));
		__privateGet$2(this, _popup).location.assign(`${__privateGet$2(this, _hostOrigin)}/${__privateGet$2(this, _hostPathname)}#${encodedRequestData}`);
		return __privateGet$2(this, _promise);
	}
	close() {
		__privateMethod$1(this, _DappPostMessageChannel_instances, cleanup_fn).call(this);
		__privateGet$2(this, _popup).close();
	}
};
_popup = /* @__PURE__ */ new WeakMap();
_version = /* @__PURE__ */ new WeakMap();
_id$1 = /* @__PURE__ */ new WeakMap();
_hostOrigin = /* @__PURE__ */ new WeakMap();
_hostPathname = /* @__PURE__ */ new WeakMap();
_appName = /* @__PURE__ */ new WeakMap();
_extraRequestOptions = /* @__PURE__ */ new WeakMap();
_promise = /* @__PURE__ */ new WeakMap();
_resolve = /* @__PURE__ */ new WeakMap();
_reject = /* @__PURE__ */ new WeakMap();
_interval = /* @__PURE__ */ new WeakMap();
_isSendCalled = /* @__PURE__ */ new WeakMap();
_listener = /* @__PURE__ */ new WeakMap();
_DappPostMessageChannel_instances = /* @__PURE__ */ new WeakSet();
cleanup_fn = function() {
	if (__privateGet$2(this, _interval)) {
		clearInterval(__privateGet$2(this, _interval));
		__privateSet$1(this, _interval, null);
	}
	window.removeEventListener("message", __privateGet$2(this, _listener));
};

//#endregion
//#region node_modules/.pnpm/@mysten+slush-wallet@0.2.12_typescript@5.9.3/node_modules/@mysten/slush-wallet/dist/esm/wallet/index.js
var __typeError$1 = (msg) => {
	throw TypeError(msg);
};
var __accessCheck$1 = (obj, member, msg) => member.has(obj) || __typeError$1("Cannot " + msg);
var __privateGet$1 = (obj, member, getter) => (__accessCheck$1(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd$1 = (obj, member, value) => member.has(obj) ? __typeError$1("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck$1(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod = (obj, member, method) => (__accessCheck$1(obj, member, "access private method"), method);
var _id, _events, _accounts, _origin, _walletName, _icon, _name, _signTransactionBlock, _signTransaction, _signAndExecuteTransaction, _signPersonalMessage, _on, _SlushWallet_instances, setAccounts_fn, _connect, getPreviouslyAuthorizedAccounts_fn, _disconnect, getNewPopupChannel_fn;
var DEFAULT_SLUSH_ORIGIN = "https://my.slush.app";
var SLUSH_SESSION_KEY = "slush:session";
var SLUSH_WALLET_NAME = "Slush";
var SUI_WALLET_EXTENSION_ID = "com.mystenlabs.suiwallet";
var METADATA_API_URL = "https://api.slush.app/api/wallet/metadata";
var FALLBACK_METADATA = {
	id: "com.mystenlabs.suiwallet.web",
	walletName: "Slush",
	description: "Trade and earn on Sui.",
	icon: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTAiIGhlaWdodD0iNTAiIHZpZXdCb3g9IjAgMCA1MCA1MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjUwIiBoZWlnaHQ9IjUwIiBmaWxsPSIjNENBMkZGIi8+CjxwYXRoIGQ9Ik0xMi4zNDczIDM0LjcyNTRDMTMuNTU1MyAzOS4yMzM2IDE4LjA2NzMgNDMuMzE0OCAyNy40MDI1IDQwLjgxMzRDMzYuMzA5NyAzOC40MjY3IDQxLjg5MjEgMzEuMDk5MyA0MC40NDQ2IDI1LjY5NzJDMzkuOTQ0NyAyMy44MzE3IDM4LjQzOTEgMjIuNTY4OSAzNi4xMTc4IDIyLjc3NDRMMTUuMzYxNSAyNC41MDM4QzE0LjA1NDQgMjQuNjA0MSAxMy40NTUgMjQuMzg5OCAxMy4xMDkyIDIzLjU2NjFDMTIuNzczOCAyMi43ODEyIDEyLjk2NDkgMjEuOTM4NSAxNC41NDM3IDIxLjE0MDZMMzAuMzM5NiAxMy4wMzQyQzMxLjU1MDMgMTIuNDE4MiAzMi4zNTY3IDEyLjE2MDUgMzMuMDkzNiAxMi40MjEzQzMzLjU1NTUgMTIuNTg5MSAzMy44NTk2IDEzLjI1NzQgMzMuNTgwMyAxNC4wODJMMzIuNTU2MSAxNy4xMDU2QzMxLjI5OTIgMjAuODE2NCAzMy45ODk5IDIxLjY3ODQgMzUuNTA2OCAyMS4yNzE5QzM3LjgwMTcgMjAuNjU3IDM4LjM0MTYgMTguNDcxMiAzNy42MDIzIDE1LjcxMTlDMzUuNzI3OCA4LjcxNjI5IDI4LjMwNTkgNy42MjI1NCAyMS41NzY4IDkuNDI1NTlDMTQuNzMxMSAxMS4yNTk5IDguNzk2ODEgMTYuODA3MiAxMC42MDg4IDIzLjU2OTZDMTEuMDM1OCAyNS4xNjMgMTIuNTAyNSAyNi40MzYyIDE0LjIwMTQgMjYuMzk3NUwxNi43OTUgMjYuMzkxMkMxNy4zMjg0IDI2LjM3ODggMTcuMTM2MyAyNi40MjI3IDE4LjE2NTMgMjYuMzM3NEMxOS4xOTQ0IDI2LjI1MjIgMjEuOTQyNSAyNS45MTQgMjEuOTQyNSAyNS45MTRMMzUuNDI3NSAyNC4zODhMMzUuNzc1IDI0LjMzNzVDMzYuNTYzNyAyNC4yMDMgMzcuMTU5NyAyNC40MDc5IDM3LjY2MzYgMjUuMjc2QzM4LjQxNzcgMjYuNTc1IDM3LjI2NzIgMjcuNTU0NiAzNS44ODk5IDI4LjcyNzJDMzUuODUzIDI4Ljc1ODYgMzUuODE2IDI4Ljc5MDEgMzUuNzc4OSAyOC44MjE4TDIzLjkyNSAzOS4wMzc3QzIxLjg5MzMgNDAuNzkwMSAyMC40NjYgNDAuMTMxMSAxOS45NjYyIDM4LjI2NTZMMTguMTk1OCAzMS42NTg3QzE3Ljc1ODUgMzAuMDI2NCAxNi4xNjQ2IDI4Ljc0NTYgMTQuMjk3NiAyOS4yNDU5QzExLjk2MzggMjkuODcxMiAxMS43NzQ2IDMyLjU4NzggMTIuMzQ3MyAzNC43MjU0WiIgZmlsbD0iIzA2MEQxNCIvPgo8L3N2Zz4K",
	enabled: true
};
var WalletMetadataSchema = object({
	id: string("Wallet ID is required"),
	walletName: string("Wallet name is required"),
	icon: string("Icon must be a valid wallet icon format"),
	enabled: boolean("Enabled is required")
});
function setSessionToStorage(session) {
	localStorage.setItem(SLUSH_SESSION_KEY, session);
}
function getSessionFromStorage() {
	const session = localStorage.getItem(SLUSH_SESSION_KEY);
	if (!session) throw new Error("No session found");
	return session;
}
var walletAccountFeatures = [
	"sui:signTransaction",
	"sui:signAndExecuteTransaction",
	"sui:signPersonalMessage",
	"sui:signTransactionBlock",
	"sui:signAndExecuteTransactionBlock"
];
function getAccountsFromSession(session) {
	const { payload } = decodeJwtSession(session);
	return payload.accounts.map((account) => {
		return new ReadonlyWalletAccount({
			address: account.address,
			chains: SUI_CHAINS,
			features: walletAccountFeatures,
			publicKey: fromBase64(account.publicKey)
		});
	});
}
var SlushWallet = class {
	constructor({ name, origin, metadata }) {
		__privateAdd$1(this, _SlushWallet_instances);
		__privateAdd$1(this, _id);
		__privateAdd$1(this, _events);
		__privateAdd$1(this, _accounts);
		__privateAdd$1(this, _origin);
		__privateAdd$1(this, _walletName);
		__privateAdd$1(this, _icon);
		__privateAdd$1(this, _name);
		__privateAdd$1(this, _signTransactionBlock, async ({ transactionBlock, account, chain }) => {
			const data = await transactionBlock.toJSON();
			const response = await __privateMethod(this, _SlushWallet_instances, getNewPopupChannel_fn).call(this).send({
				type: "sign-transaction",
				transaction: data,
				address: account.address,
				chain,
				session: getSessionFromStorage()
			});
			return {
				transactionBlockBytes: response.bytes,
				signature: response.signature
			};
		});
		__privateAdd$1(this, _signTransaction, async ({ transaction, account, chain }) => {
			const popup = __privateMethod(this, _SlushWallet_instances, getNewPopupChannel_fn).call(this);
			const tx = await transaction.toJSON();
			const response = await popup.send({
				type: "sign-transaction",
				transaction: tx,
				address: account.address,
				chain,
				session: getSessionFromStorage()
			});
			return {
				bytes: response.bytes,
				signature: response.signature
			};
		});
		__privateAdd$1(this, _signAndExecuteTransaction, async ({ transaction, account, chain }) => {
			const popup = __privateMethod(this, _SlushWallet_instances, getNewPopupChannel_fn).call(this);
			const data = await transaction.toJSON();
			const response = await popup.send({
				type: "sign-and-execute-transaction",
				transaction: data,
				address: account.address,
				chain,
				session: getSessionFromStorage()
			});
			return {
				bytes: response.bytes,
				signature: response.signature,
				digest: response.digest,
				effects: response.effects
			};
		});
		__privateAdd$1(this, _signPersonalMessage, async ({ message, account, chain }) => {
			const response = await __privateMethod(this, _SlushWallet_instances, getNewPopupChannel_fn).call(this).send({
				type: "sign-personal-message",
				message: toBase64(message),
				address: account.address,
				chain: chain ?? account.chains[0],
				session: getSessionFromStorage()
			});
			return {
				bytes: response.bytes,
				signature: response.signature
			};
		});
		__privateAdd$1(this, _on, (event, listener) => {
			__privateGet$1(this, _events).on(event, listener);
			return () => __privateGet$1(this, _events).off(event, listener);
		});
		__privateAdd$1(this, _connect, async (input) => {
			if (input?.silent) return { accounts: this.accounts };
			const response = await __privateMethod(this, _SlushWallet_instances, getNewPopupChannel_fn).call(this).send({ type: "connect" });
			setSessionToStorage(response.session);
			__privateMethod(this, _SlushWallet_instances, setAccounts_fn).call(this, getAccountsFromSession(response.session));
			return { accounts: this.accounts };
		});
		__privateAdd$1(this, _disconnect, async () => {
			localStorage.removeItem(SLUSH_SESSION_KEY);
			__privateMethod(this, _SlushWallet_instances, setAccounts_fn).call(this, []);
		});
		__privateSet(this, _id, metadata.id);
		__privateSet(this, _accounts, __privateMethod(this, _SlushWallet_instances, getPreviouslyAuthorizedAccounts_fn).call(this));
		__privateSet(this, _events, mitt_default());
		__privateSet(this, _origin, origin || DEFAULT_SLUSH_ORIGIN);
		__privateSet(this, _name, name);
		__privateSet(this, _walletName, metadata.walletName);
		__privateSet(this, _icon, metadata.icon);
	}
	get name() {
		return __privateGet$1(this, _walletName);
	}
	get id() {
		return __privateGet$1(this, _id);
	}
	get icon() {
		return __privateGet$1(this, _icon);
	}
	get version() {
		return "1.0.0";
	}
	get chains() {
		return SUI_CHAINS;
	}
	get accounts() {
		return __privateGet$1(this, _accounts);
	}
	get features() {
		return {
			"standard:connect": {
				version: "1.0.0",
				connect: __privateGet$1(this, _connect)
			},
			"standard:disconnect": {
				version: "1.0.0",
				disconnect: __privateGet$1(this, _disconnect)
			},
			"standard:events": {
				version: "1.0.0",
				on: __privateGet$1(this, _on)
			},
			"sui:signTransactionBlock": {
				version: "1.0.0",
				signTransactionBlock: __privateGet$1(this, _signTransactionBlock)
			},
			"sui:signTransaction": {
				version: "2.0.0",
				signTransaction: __privateGet$1(this, _signTransaction)
			},
			"sui:signPersonalMessage": {
				version: "1.1.0",
				signPersonalMessage: __privateGet$1(this, _signPersonalMessage)
			},
			"sui:signAndExecuteTransaction": {
				version: "2.0.0",
				signAndExecuteTransaction: __privateGet$1(this, _signAndExecuteTransaction)
			}
		};
	}
	updateMetadata(metadata) {
		__privateSet(this, _id, metadata.id);
		__privateSet(this, _walletName, metadata.walletName);
		__privateSet(this, _icon, metadata.icon);
	}
};
_id = /* @__PURE__ */ new WeakMap();
_events = /* @__PURE__ */ new WeakMap();
_accounts = /* @__PURE__ */ new WeakMap();
_origin = /* @__PURE__ */ new WeakMap();
_walletName = /* @__PURE__ */ new WeakMap();
_icon = /* @__PURE__ */ new WeakMap();
_name = /* @__PURE__ */ new WeakMap();
_signTransactionBlock = /* @__PURE__ */ new WeakMap();
_signTransaction = /* @__PURE__ */ new WeakMap();
_signAndExecuteTransaction = /* @__PURE__ */ new WeakMap();
_signPersonalMessage = /* @__PURE__ */ new WeakMap();
_on = /* @__PURE__ */ new WeakMap();
_SlushWallet_instances = /* @__PURE__ */ new WeakSet();
setAccounts_fn = function(accounts) {
	__privateSet(this, _accounts, accounts);
	__privateGet$1(this, _events).emit("change", { accounts: this.accounts });
};
_connect = /* @__PURE__ */ new WeakMap();
getPreviouslyAuthorizedAccounts_fn = function() {
	try {
		return getAccountsFromSession(getSessionFromStorage());
	} catch {
		return [];
	}
};
_disconnect = /* @__PURE__ */ new WeakMap();
getNewPopupChannel_fn = function() {
	return new DappPostMessageChannel({
		appName: __privateGet$1(this, _name),
		hostOrigin: __privateGet$1(this, _origin)
	});
};
async function fetchMetadata(metadataApiUrl) {
	const response = await fetch(metadataApiUrl);
	if (!response.ok) throw new Error("Failed to fetch wallet metadata");
	return parse$1(WalletMetadataSchema, await response.json());
}
function registerSlushWallet(name, { origin, metadataApiUrl = METADATA_API_URL } = {}) {
	const wallets$1 = getWallets();
	let unregister = null;
	wallets$1.on("register", (wallet) => {
		if (wallet.id === SUI_WALLET_EXTENSION_ID) unregister?.();
	});
	if (wallets$1.get().find((wallet) => wallet.id === SUI_WALLET_EXTENSION_ID)) return;
	const slushWalletInstance = new SlushWallet({
		name,
		origin,
		metadata: FALLBACK_METADATA
	});
	unregister = wallets$1.register(slushWalletInstance);
	fetchMetadata(metadataApiUrl).then((metadata) => {
		if (!metadata.enabled) {
			console.log("Slush wallet is not currently enabled.");
			unregister?.();
			return;
		}
		slushWalletInstance.updateMetadata(metadata);
	}).catch((error) => {
		console.error("Error fetching metadata", error);
	});
	return {
		wallet: slushWalletInstance,
		unregister
	};
}

//#endregion
//#region node_modules/.pnpm/zustand@4.5.7_@types+react@19.2.7_react@19.2.3/node_modules/zustand/esm/vanilla.mjs
var import_react = /* @__PURE__ */ __toESM$1(require_react(), 1);
var createStoreImpl = (createState) => {
	let state;
	const listeners$1 = /* @__PURE__ */ new Set();
	const setState = (partial, replace) => {
		const nextState = typeof partial === "function" ? partial(state) : partial;
		if (!Object.is(nextState, state)) {
			const previousState = state;
			state = (replace != null ? replace : typeof nextState !== "object" || nextState === null) ? nextState : Object.assign({}, state, nextState);
			listeners$1.forEach((listener) => listener(state, previousState));
		}
	};
	const getState = () => state;
	const getInitialState = () => initialState;
	const subscribe = (listener) => {
		listeners$1.add(listener);
		return () => listeners$1.delete(listener);
	};
	const destroy = () => {
		if ((import.meta.env ? import.meta.env.MODE : void 0) !== "production") console.warn("[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected.");
		listeners$1.clear();
	};
	const api = {
		setState,
		getState,
		getInitialState,
		subscribe,
		destroy
	};
	const initialState = state = createState(setState, getState, api);
	return api;
};
var createStore = (createState) => createState ? createStoreImpl(createState) : createStoreImpl;

//#endregion
//#region node_modules/.pnpm/use-sync-external-store@1.6.0_react@19.2.3/node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js
/**
* @license React
* use-sync-external-store-shim/with-selector.development.js
*
* Copyright (c) Meta Platforms, Inc. and affiliates.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/
var require_with_selector_development = /* @__PURE__ */ __commonJS$1({ "node_modules/.pnpm/use-sync-external-store@1.6.0_react@19.2.3/node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js": ((exports) => {
	(function() {
		function is(x$1, y) {
			return x$1 === y && (0 !== x$1 || 1 / x$1 === 1 / y) || x$1 !== x$1 && y !== y;
		}
		"undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
		var React = require_react(), shim = require_shim(), objectIs = "function" === typeof Object.is ? Object.is : is, useSyncExternalStore = shim.useSyncExternalStore, useRef$1 = React.useRef, useEffect$1 = React.useEffect, useMemo$1 = React.useMemo, useDebugValue$1 = React.useDebugValue;
		exports.useSyncExternalStoreWithSelector = function(subscribe, getSnapshot, getServerSnapshot, selector, isEqual) {
			var instRef = useRef$1(null);
			if (null === instRef.current) {
				var inst = {
					hasValue: !1,
					value: null
				};
				instRef.current = inst;
			} else inst = instRef.current;
			instRef = useMemo$1(function() {
				function memoizedSelector(nextSnapshot) {
					if (!hasMemo) {
						hasMemo = !0;
						memoizedSnapshot = nextSnapshot;
						nextSnapshot = selector(nextSnapshot);
						if (void 0 !== isEqual && inst.hasValue) {
							var currentSelection = inst.value;
							if (isEqual(currentSelection, nextSnapshot)) return memoizedSelection = currentSelection;
						}
						return memoizedSelection = nextSnapshot;
					}
					currentSelection = memoizedSelection;
					if (objectIs(memoizedSnapshot, nextSnapshot)) return currentSelection;
					var nextSelection = selector(nextSnapshot);
					if (void 0 !== isEqual && isEqual(currentSelection, nextSelection)) return memoizedSnapshot = nextSnapshot, currentSelection;
					memoizedSnapshot = nextSnapshot;
					return memoizedSelection = nextSelection;
				}
				var hasMemo = !1, memoizedSnapshot, memoizedSelection, maybeGetServerSnapshot = void 0 === getServerSnapshot ? null : getServerSnapshot;
				return [function() {
					return memoizedSelector(getSnapshot());
				}, null === maybeGetServerSnapshot ? void 0 : function() {
					return memoizedSelector(maybeGetServerSnapshot());
				}];
			}, [
				getSnapshot,
				getServerSnapshot,
				selector,
				isEqual
			]);
			var value = useSyncExternalStore(subscribe, instRef[0], instRef[1]);
			useEffect$1(function() {
				inst.hasValue = !0;
				inst.value = value;
			}, [value]);
			useDebugValue$1(value);
			return value;
		};
		"undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
	})();
}) });

//#endregion
//#region node_modules/.pnpm/use-sync-external-store@1.6.0_react@19.2.3/node_modules/use-sync-external-store/shim/with-selector.js
var require_with_selector = /* @__PURE__ */ __commonJS$1({ "node_modules/.pnpm/use-sync-external-store@1.6.0_react@19.2.3/node_modules/use-sync-external-store/shim/with-selector.js": ((exports, module) => {
	module.exports = require_with_selector_development();
}) });

//#endregion
//#region node_modules/.pnpm/zustand@4.5.7_@types+react@19.2.7_react@19.2.3/node_modules/zustand/esm/index.mjs
var import_with_selector = /* @__PURE__ */ __toESM$1(require_with_selector(), 1);
var { useDebugValue } = import_react.default;
var { useSyncExternalStoreWithSelector } = import_with_selector.default;
var didWarnAboutEqualityFn = false;
var identity = (arg) => arg;
function useStore(api, selector = identity, equalityFn) {
	if ((import.meta.env ? import.meta.env.MODE : void 0) !== "production" && equalityFn && !didWarnAboutEqualityFn) {
		console.warn("[DEPRECATED] Use `createWithEqualityFn` instead of `create` or use `useStoreWithEqualityFn` instead of `useStore`. They can be imported from 'zustand/traditional'. https://github.com/pmndrs/zustand/discussions/1937");
		didWarnAboutEqualityFn = true;
	}
	const slice = useSyncExternalStoreWithSelector(api.subscribe, api.getState, api.getServerState || api.getInitialState, selector, equalityFn);
	useDebugValue(slice);
	return slice;
}

//#endregion
//#region node_modules/.pnpm/@radix-ui+react-slot@1.2.4_@types+react@19.2.7_react@19.2.3/node_modules/@radix-ui/react-slot/dist/index.mjs
var import_jsx_runtime = require_jsx_runtime();
var REACT_LAZY_TYPE = Symbol.for("react.lazy");
var use = import_react[" use ".trim().toString()];
function isPromiseLike(value) {
	return typeof value === "object" && value !== null && "then" in value;
}
function isLazyComponent(element) {
	return element != null && typeof element === "object" && "$$typeof" in element && element.$$typeof === REACT_LAZY_TYPE && "_payload" in element && isPromiseLike(element._payload);
}
/* @__NO_SIDE_EFFECTS__ */
function createSlot(ownerName) {
	const SlotClone = /* @__PURE__ */ createSlotClone(ownerName);
	const Slot2 = import_react.forwardRef((props, forwardedRef) => {
		let { children, ...slotProps } = props;
		if (isLazyComponent(children) && typeof use === "function") children = use(children._payload);
		const childrenArray = import_react.Children.toArray(children);
		const slottable = childrenArray.find(isSlottable);
		if (slottable) {
			const newElement = slottable.props.children;
			const newChildren = childrenArray.map((child) => {
				if (child === slottable) {
					if (import_react.Children.count(newElement) > 1) return import_react.Children.only(null);
					return import_react.isValidElement(newElement) ? newElement.props.children : null;
				} else return child;
			});
			return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(SlotClone, {
				...slotProps,
				ref: forwardedRef,
				children: import_react.isValidElement(newElement) ? import_react.cloneElement(newElement, void 0, newChildren) : null
			});
		}
		return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(SlotClone, {
			...slotProps,
			ref: forwardedRef,
			children
		});
	});
	Slot2.displayName = `${ownerName}.Slot`;
	return Slot2;
}
var Slot = /* @__PURE__ */ createSlot("Slot");
/* @__NO_SIDE_EFFECTS__ */
function createSlotClone(ownerName) {
	const SlotClone = import_react.forwardRef((props, forwardedRef) => {
		let { children, ...slotProps } = props;
		if (isLazyComponent(children) && typeof use === "function") children = use(children._payload);
		if (import_react.isValidElement(children)) {
			const childrenRef = getElementRef(children);
			const props2 = mergeProps(slotProps, children.props);
			if (children.type !== import_react.Fragment) props2.ref = forwardedRef ? composeRefs(forwardedRef, childrenRef) : childrenRef;
			return import_react.cloneElement(children, props2);
		}
		return import_react.Children.count(children) > 1 ? import_react.Children.only(null) : null;
	});
	SlotClone.displayName = `${ownerName}.SlotClone`;
	return SlotClone;
}
var SLOTTABLE_IDENTIFIER = Symbol("radix.slottable");
function isSlottable(child) {
	return import_react.isValidElement(child) && typeof child.type === "function" && "__radixId" in child.type && child.type.__radixId === SLOTTABLE_IDENTIFIER;
}
function mergeProps(slotProps, childProps) {
	const overrideProps = { ...childProps };
	for (const propName in childProps) {
		const slotPropValue = slotProps[propName];
		const childPropValue = childProps[propName];
		if (/^on[A-Z]/.test(propName)) {
			if (slotPropValue && childPropValue) overrideProps[propName] = (...args) => {
				const result = childPropValue(...args);
				slotPropValue(...args);
				return result;
			};
			else if (slotPropValue) overrideProps[propName] = slotPropValue;
		} else if (propName === "style") overrideProps[propName] = {
			...slotPropValue,
			...childPropValue
		};
		else if (propName === "className") overrideProps[propName] = [slotPropValue, childPropValue].filter(Boolean).join(" ");
	}
	return {
		...slotProps,
		...overrideProps
	};
}
function getElementRef(element) {
	let getter = Object.getOwnPropertyDescriptor(element.props, "ref")?.get;
	let mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
	if (mayWarn) return element.ref;
	getter = Object.getOwnPropertyDescriptor(element, "ref")?.get;
	mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
	if (mayWarn) return element.props.ref;
	return element.props.ref || element.ref;
}

//#endregion
//#region node_modules/.pnpm/@vanilla-extract+recipes@0.5.7_@vanilla-extract+css@1.18.0/node_modules/@vanilla-extract/recipes/dist/createRuntimeFn-62c9670f.esm.js
function toPrimitive$1(t, r$1) {
	if ("object" != typeof t || !t) return t;
	var e = t[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i = e.call(t, r$1 || "default");
		if ("object" != typeof i) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r$1 ? String : Number)(t);
}
function toPropertyKey$1(t) {
	var i = toPrimitive$1(t, "string");
	return "symbol" == typeof i ? i : String(i);
}
function _defineProperty$2(obj, key, value) {
	key = toPropertyKey$1(key);
	if (key in obj) Object.defineProperty(obj, key, {
		value,
		enumerable: true,
		configurable: true,
		writable: true
	});
	else obj[key] = value;
	return obj;
}
function ownKeys$2(e, r$1) {
	var t = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o = Object.getOwnPropertySymbols(e);
		r$1 && (o = o.filter(function(r$2) {
			return Object.getOwnPropertyDescriptor(e, r$2).enumerable;
		})), t.push.apply(t, o);
	}
	return t;
}
function _objectSpread2$1(e) {
	for (var r$1 = 1; r$1 < arguments.length; r$1++) {
		var t = null != arguments[r$1] ? arguments[r$1] : {};
		r$1 % 2 ? ownKeys$2(Object(t), !0).forEach(function(r$2) {
			_defineProperty$2(e, r$2, t[r$2]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$2(Object(t)).forEach(function(r$2) {
			Object.defineProperty(e, r$2, Object.getOwnPropertyDescriptor(t, r$2));
		});
	}
	return e;
}
function mapValues(input, fn) {
	var result = {};
	for (var _key in input) result[_key] = fn(input[_key], _key);
	return result;
}
var shouldApplyCompound = (compoundCheck, selections, defaultVariants) => {
	for (var key of Object.keys(compoundCheck)) {
		var _selections$key;
		if (compoundCheck[key] !== ((_selections$key = selections[key]) !== null && _selections$key !== void 0 ? _selections$key : defaultVariants[key])) return false;
	}
	return true;
};
var createRuntimeFn = (config) => {
	var runtimeFn = (options) => {
		var className = config.defaultClassName;
		var selections = _objectSpread2$1(_objectSpread2$1({}, config.defaultVariants), options);
		for (var variantName in selections) {
			var _selections$variantNa;
			var variantSelection = (_selections$variantNa = selections[variantName]) !== null && _selections$variantNa !== void 0 ? _selections$variantNa : config.defaultVariants[variantName];
			if (variantSelection != null) {
				var selection = variantSelection;
				if (typeof selection === "boolean") selection = selection === true ? "true" : "false";
				var selectionClassName = config.variantClassNames[variantName][selection];
				if (selectionClassName) className += " " + selectionClassName;
			}
		}
		for (var [compoundCheck, compoundClassName] of config.compoundVariants) if (shouldApplyCompound(compoundCheck, selections, config.defaultVariants)) className += " " + compoundClassName;
		return className;
	};
	runtimeFn.variants = () => Object.keys(config.variantClassNames);
	runtimeFn.classNames = {
		get base() {
			return config.defaultClassName.split(" ")[0];
		},
		get variants() {
			return mapValues(config.variantClassNames, (classNames) => mapValues(classNames, (className) => className.split(" ")[0]));
		}
	};
	return runtimeFn;
};

//#endregion
//#region node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/esm/sha2.js
/**
* SHA2 hash function. A.k.a. sha256, sha384, sha512, sha512_224, sha512_256.
* SHA256 is the fastest hash implementable in JS, even faster than Blake3.
* Check out [RFC 4634](https://datatracker.ietf.org/doc/html/rfc4634) and
* [FIPS 180-4](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf).
* @module
*/
var K512 = /* @__PURE__ */ (() => split([
	"0x428a2f98d728ae22",
	"0x7137449123ef65cd",
	"0xb5c0fbcfec4d3b2f",
	"0xe9b5dba58189dbbc",
	"0x3956c25bf348b538",
	"0x59f111f1b605d019",
	"0x923f82a4af194f9b",
	"0xab1c5ed5da6d8118",
	"0xd807aa98a3030242",
	"0x12835b0145706fbe",
	"0x243185be4ee4b28c",
	"0x550c7dc3d5ffb4e2",
	"0x72be5d74f27b896f",
	"0x80deb1fe3b1696b1",
	"0x9bdc06a725c71235",
	"0xc19bf174cf692694",
	"0xe49b69c19ef14ad2",
	"0xefbe4786384f25e3",
	"0x0fc19dc68b8cd5b5",
	"0x240ca1cc77ac9c65",
	"0x2de92c6f592b0275",
	"0x4a7484aa6ea6e483",
	"0x5cb0a9dcbd41fbd4",
	"0x76f988da831153b5",
	"0x983e5152ee66dfab",
	"0xa831c66d2db43210",
	"0xb00327c898fb213f",
	"0xbf597fc7beef0ee4",
	"0xc6e00bf33da88fc2",
	"0xd5a79147930aa725",
	"0x06ca6351e003826f",
	"0x142929670a0e6e70",
	"0x27b70a8546d22ffc",
	"0x2e1b21385c26c926",
	"0x4d2c6dfc5ac42aed",
	"0x53380d139d95b3df",
	"0x650a73548baf63de",
	"0x766a0abb3c77b2a8",
	"0x81c2c92e47edaee6",
	"0x92722c851482353b",
	"0xa2bfe8a14cf10364",
	"0xa81a664bbc423001",
	"0xc24b8b70d0f89791",
	"0xc76c51a30654be30",
	"0xd192e819d6ef5218",
	"0xd69906245565a910",
	"0xf40e35855771202a",
	"0x106aa07032bbd1b8",
	"0x19a4c116b8d2d0c8",
	"0x1e376c085141ab53",
	"0x2748774cdf8eeb99",
	"0x34b0bcb5e19b48a8",
	"0x391c0cb3c5c95a63",
	"0x4ed8aa4ae3418acb",
	"0x5b9cca4f7763e373",
	"0x682e6ff3d6b2b8a3",
	"0x748f82ee5defb2fc",
	"0x78a5636f43172f60",
	"0x84c87814a1f0ab72",
	"0x8cc702081a6439ec",
	"0x90befffa23631e28",
	"0xa4506cebde82bde9",
	"0xbef9a3f7b2c67915",
	"0xc67178f2e372532b",
	"0xca273eceea26619c",
	"0xd186b8c721c0c207",
	"0xeada7dd6cde0eb1e",
	"0xf57d4f7fee6ed178",
	"0x06f067aa72176fba",
	"0x0a637dc5a2c898a6",
	"0x113f9804bef90dae",
	"0x1b710b35131c471b",
	"0x28db77f523047d84",
	"0x32caab7b40c72493",
	"0x3c9ebe0a15c9bebc",
	"0x431d67c49c100d4c",
	"0x4cc5d4becb3e42b6",
	"0x597f299cfc657e2a",
	"0x5fcb6fab3ad6faec",
	"0x6c44198c4a475817"
].map((n) => BigInt(n))))();
var SHA512_Kh = /* @__PURE__ */ (() => K512[0])();
var SHA512_Kl = /* @__PURE__ */ (() => K512[1])();
var SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);
var SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);
var SHA512 = class extends HashMD {
	constructor(outputLen = 64) {
		super(128, outputLen, 16, false);
		this.Ah = SHA512_IV[0] | 0;
		this.Al = SHA512_IV[1] | 0;
		this.Bh = SHA512_IV[2] | 0;
		this.Bl = SHA512_IV[3] | 0;
		this.Ch = SHA512_IV[4] | 0;
		this.Cl = SHA512_IV[5] | 0;
		this.Dh = SHA512_IV[6] | 0;
		this.Dl = SHA512_IV[7] | 0;
		this.Eh = SHA512_IV[8] | 0;
		this.El = SHA512_IV[9] | 0;
		this.Fh = SHA512_IV[10] | 0;
		this.Fl = SHA512_IV[11] | 0;
		this.Gh = SHA512_IV[12] | 0;
		this.Gl = SHA512_IV[13] | 0;
		this.Hh = SHA512_IV[14] | 0;
		this.Hl = SHA512_IV[15] | 0;
	}
	get() {
		const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
		return [
			Ah,
			Al,
			Bh,
			Bl,
			Ch,
			Cl,
			Dh,
			Dl,
			Eh,
			El,
			Fh,
			Fl,
			Gh,
			Gl,
			Hh,
			Hl
		];
	}
	set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
		this.Ah = Ah | 0;
		this.Al = Al | 0;
		this.Bh = Bh | 0;
		this.Bl = Bl | 0;
		this.Ch = Ch | 0;
		this.Cl = Cl | 0;
		this.Dh = Dh | 0;
		this.Dl = Dl | 0;
		this.Eh = Eh | 0;
		this.El = El | 0;
		this.Fh = Fh | 0;
		this.Fl = Fl | 0;
		this.Gh = Gh | 0;
		this.Gl = Gl | 0;
		this.Hh = Hh | 0;
		this.Hl = Hl | 0;
	}
	process(view, offset) {
		for (let i = 0; i < 16; i++, offset += 4) {
			SHA512_W_H[i] = view.getUint32(offset);
			SHA512_W_L[i] = view.getUint32(offset += 4);
		}
		for (let i = 16; i < 80; i++) {
			const W15h = SHA512_W_H[i - 15] | 0;
			const W15l = SHA512_W_L[i - 15] | 0;
			const s0h = rotrSH(W15h, W15l, 1) ^ rotrSH(W15h, W15l, 8) ^ shrSH(W15h, W15l, 7);
			const s0l = rotrSL(W15h, W15l, 1) ^ rotrSL(W15h, W15l, 8) ^ shrSL(W15h, W15l, 7);
			const W2h = SHA512_W_H[i - 2] | 0;
			const W2l = SHA512_W_L[i - 2] | 0;
			const s1h = rotrSH(W2h, W2l, 19) ^ rotrBH(W2h, W2l, 61) ^ shrSH(W2h, W2l, 6);
			const s1l = rotrSL(W2h, W2l, 19) ^ rotrBL(W2h, W2l, 61) ^ shrSL(W2h, W2l, 6);
			const SUMl = add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);
			SHA512_W_H[i] = add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]) | 0;
			SHA512_W_L[i] = SUMl | 0;
		}
		let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
		for (let i = 0; i < 80; i++) {
			const sigma1h = rotrSH(Eh, El, 14) ^ rotrSH(Eh, El, 18) ^ rotrBH(Eh, El, 41);
			const sigma1l = rotrSL(Eh, El, 14) ^ rotrSL(Eh, El, 18) ^ rotrBL(Eh, El, 41);
			const CHIh = Eh & Fh ^ ~Eh & Gh;
			const CHIl = El & Fl ^ ~El & Gl;
			const T1ll = add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);
			const T1h = add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);
			const T1l = T1ll | 0;
			const sigma0h = rotrSH(Ah, Al, 28) ^ rotrBH(Ah, Al, 34) ^ rotrBH(Ah, Al, 39);
			const sigma0l = rotrSL(Ah, Al, 28) ^ rotrBL(Ah, Al, 34) ^ rotrBL(Ah, Al, 39);
			const MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;
			const MAJl = Al & Bl ^ Al & Cl ^ Bl & Cl;
			Hh = Gh | 0;
			Hl = Gl | 0;
			Gh = Fh | 0;
			Gl = Fl | 0;
			Fh = Eh | 0;
			Fl = El | 0;
			({h: Eh, l: El} = add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));
			Dh = Ch | 0;
			Dl = Cl | 0;
			Ch = Bh | 0;
			Cl = Bl | 0;
			Bh = Ah | 0;
			Bl = Al | 0;
			const All = add3L(T1l, sigma0l, MAJl);
			Ah = add3H(All, T1h, sigma0h, MAJh);
			Al = All | 0;
		}
		({h: Ah, l: Al} = add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));
		({h: Bh, l: Bl} = add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));
		({h: Ch, l: Cl} = add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));
		({h: Dh, l: Dl} = add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));
		({h: Eh, l: El} = add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));
		({h: Fh, l: Fl} = add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));
		({h: Gh, l: Gl} = add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));
		({h: Hh, l: Hl} = add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));
		this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
	}
	roundClean() {
		clean(SHA512_W_H, SHA512_W_L);
	}
	destroy() {
		clean(this.buffer);
		this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
	}
};
/** SHA2-512 hash function from RFC 4634. */
const sha512$1 = /* @__PURE__ */ createHasher(() => new SHA512());

//#endregion
//#region node_modules/.pnpm/@noble+curves@1.9.4/node_modules/@noble/curves/esm/utils.js
/**
* Hex, bytes and number utilities.
* @module
*/
var _0n$4 = /* @__PURE__ */ BigInt(0);
var _1n$4 = /* @__PURE__ */ BigInt(1);
function abool(title$1, value) {
	if (typeof value !== "boolean") throw new Error(title$1 + " boolean expected, got " + value);
}
function hexToNumber(hex) {
	if (typeof hex !== "string") throw new Error("hex string expected, got " + typeof hex);
	return hex === "" ? _0n$4 : BigInt("0x" + hex);
}
function bytesToNumberBE(bytes) {
	return hexToNumber(bytesToHex(bytes));
}
function bytesToNumberLE(bytes) {
	abytes(bytes);
	return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));
}
function numberToBytesBE(n, len) {
	return hexToBytes(n.toString(16).padStart(len * 2, "0"));
}
function numberToBytesLE(n, len) {
	return numberToBytesBE(n, len).reverse();
}
/**
* Takes hex string or Uint8Array, converts to Uint8Array.
* Validates output length.
* Will throw error for other types.
* @param title descriptive title for an error e.g. 'secret key'
* @param hex hex string or Uint8Array
* @param expectedLength optional, will compare to result array's length
* @returns
*/
function ensureBytes(title$1, hex, expectedLength) {
	let res;
	if (typeof hex === "string") try {
		res = hexToBytes(hex);
	} catch (e) {
		throw new Error(title$1 + " must be hex string or Uint8Array, cause: " + e);
	}
	else if (isBytes(hex)) res = Uint8Array.from(hex);
	else throw new Error(title$1 + " must be hex string or Uint8Array");
	const len = res.length;
	if (typeof expectedLength === "number" && len !== expectedLength) throw new Error(title$1 + " of length " + expectedLength + " expected, got " + len);
	return res;
}
function equalBytes(a, b) {
	if (a.length !== b.length) return false;
	let diff = 0;
	for (let i = 0; i < a.length; i++) diff |= a[i] ^ b[i];
	return diff === 0;
}
/**
* @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])
*/
/**
* Converts bytes to string using UTF8 encoding.
* @example bytesToUtf8(Uint8Array.from([97, 98, 99])) // 'abc'
*/
var isPosBig = (n) => typeof n === "bigint" && _0n$4 <= n;
function inRange(n, min, max) {
	return isPosBig(n) && isPosBig(min) && isPosBig(max) && min <= n && n < max;
}
/**
* Asserts min <= n < max. NOTE: It's < max and not <= max.
* @example
* aInRange('x', x, 1n, 256n); // would assume x is in (1n..255n)
*/
function aInRange(title$1, n, min, max) {
	if (!inRange(n, min, max)) throw new Error("expected valid " + title$1 + ": " + min + " <= n < " + max + ", got " + n);
}
/**
* Calculates amount of bits in a bigint.
* Same as `n.toString(2).length`
* TODO: merge with nLength in modular
*/
function bitLen(n) {
	let len;
	for (len = 0; n > _0n$4; n >>= _1n$4, len += 1);
	return len;
}
/**
* Calculate mask for N bits. Not using ** operator with bigints because of old engines.
* Same as BigInt(`0b${Array(i).fill('1').join('')}`)
*/
const bitMask = (n) => (_1n$4 << BigInt(n)) - _1n$4;
function _validateObject(object$1, fields, optFields = {}) {
	if (!object$1 || typeof object$1 !== "object") throw new Error("expected valid options object");
	function checkField(fieldName, expectedType, isOpt) {
		const val = object$1[fieldName];
		if (isOpt && val === void 0) return;
		const current = typeof val;
		if (current !== expectedType || val === null) throw new Error(`param "${fieldName}" is invalid: expected ${expectedType}, got ${current}`);
	}
	Object.entries(fields).forEach(([k, v]) => checkField(k, v, false));
	Object.entries(optFields).forEach(([k, v]) => checkField(k, v, true));
}
/**
* Memoizes (caches) computation result.
* Uses WeakMap: the value is going auto-cleaned by GC after last reference is removed.
*/
function memoized(fn) {
	const map = /* @__PURE__ */ new WeakMap();
	return (arg, ...args) => {
		const val = map.get(arg);
		if (val !== void 0) return val;
		const computed = fn(arg, ...args);
		map.set(arg, computed);
		return computed;
	};
}

//#endregion
//#region node_modules/.pnpm/@noble+curves@1.9.4/node_modules/@noble/curves/esm/abstract/modular.js
/**
* Utils for modular division and fields.
* Field over 11 is a finite (Galois) field is integer number operations `mod 11`.
* There is no division: it is replaced by modular multiplicative inverse.
* @module
*/
var _0n$3 = BigInt(0), _1n$3 = BigInt(1), _2n$2 = /* @__PURE__ */ BigInt(2), _3n$1 = /* @__PURE__ */ BigInt(3);
var _4n = /* @__PURE__ */ BigInt(4), _5n$1 = /* @__PURE__ */ BigInt(5), _7n = /* @__PURE__ */ BigInt(7);
var _8n$2 = /* @__PURE__ */ BigInt(8), _9n = /* @__PURE__ */ BigInt(9), _16n = /* @__PURE__ */ BigInt(16);
function mod(a, b) {
	const result = a % b;
	return result >= _0n$3 ? result : b + result;
}
/** Does `x^(2^power)` mod p. `pow2(30, 4)` == `30^(2^4)` */
function pow2(x$1, power, modulo) {
	let res = x$1;
	while (power-- > _0n$3) {
		res *= res;
		res %= modulo;
	}
	return res;
}
/**
* Inverses number over modulo.
* Implemented using [Euclidean GCD](https://brilliant.org/wiki/extended-euclidean-algorithm/).
*/
function invert(number$1, modulo) {
	if (number$1 === _0n$3) throw new Error("invert: expected non-zero number");
	if (modulo <= _0n$3) throw new Error("invert: expected positive modulus, got " + modulo);
	let a = mod(number$1, modulo);
	let b = modulo;
	let x$1 = _0n$3, y = _1n$3, u = _1n$3, v = _0n$3;
	while (a !== _0n$3) {
		const q = b / a;
		const r$1 = b % a;
		const m = x$1 - u * q;
		const n = y - v * q;
		b = a, a = r$1, x$1 = u, y = v, u = m, v = n;
	}
	if (b !== _1n$3) throw new Error("invert: does not exist");
	return mod(x$1, modulo);
}
function assertIsSquare(Fp$1, root, n) {
	if (!Fp$1.eql(Fp$1.sqr(root), n)) throw new Error("Cannot find square root");
}
function sqrt3mod4(Fp$1, n) {
	const p1div4 = (Fp$1.ORDER + _1n$3) / _4n;
	const root = Fp$1.pow(n, p1div4);
	assertIsSquare(Fp$1, root, n);
	return root;
}
function sqrt5mod8(Fp$1, n) {
	const p5div8 = (Fp$1.ORDER - _5n$1) / _8n$2;
	const n2 = Fp$1.mul(n, _2n$2);
	const v = Fp$1.pow(n2, p5div8);
	const nv = Fp$1.mul(n, v);
	const i = Fp$1.mul(Fp$1.mul(nv, _2n$2), v);
	const root = Fp$1.mul(nv, Fp$1.sub(i, Fp$1.ONE));
	assertIsSquare(Fp$1, root, n);
	return root;
}
function sqrt9mod16(P) {
	const Fp_ = Field(P);
	const tn = tonelliShanks(P);
	const c1 = tn(Fp_, Fp_.neg(Fp_.ONE));
	const c2 = tn(Fp_, c1);
	const c3 = tn(Fp_, Fp_.neg(c1));
	const c4 = (P + _7n) / _16n;
	return (Fp$1, n) => {
		let tv1 = Fp$1.pow(n, c4);
		let tv2 = Fp$1.mul(tv1, c1);
		const tv3 = Fp$1.mul(tv1, c2);
		const tv4 = Fp$1.mul(tv1, c3);
		const e1 = Fp$1.eql(Fp$1.sqr(tv2), n);
		const e2 = Fp$1.eql(Fp$1.sqr(tv3), n);
		tv1 = Fp$1.cmov(tv1, tv2, e1);
		tv2 = Fp$1.cmov(tv4, tv3, e2);
		const e3 = Fp$1.eql(Fp$1.sqr(tv2), n);
		const root = Fp$1.cmov(tv1, tv2, e3);
		assertIsSquare(Fp$1, root, n);
		return root;
	};
}
/**
* Tonelli-Shanks square root search algorithm.
* 1. https://eprint.iacr.org/2012/685.pdf (page 12)
* 2. Square Roots from 1; 24, 51, 10 to Dan Shanks
* @param P field order
* @returns function that takes field Fp (created from P) and number n
*/
function tonelliShanks(P) {
	if (P < _3n$1) throw new Error("sqrt is not defined for small field");
	let Q = P - _1n$3;
	let S = 0;
	while (Q % _2n$2 === _0n$3) {
		Q /= _2n$2;
		S++;
	}
	let Z = _2n$2;
	const _Fp = Field(P);
	while (FpLegendre(_Fp, Z) === 1) if (Z++ > 1e3) throw new Error("Cannot find square root: probably non-prime P");
	if (S === 1) return sqrt3mod4;
	let cc = _Fp.pow(Z, Q);
	const Q1div2 = (Q + _1n$3) / _2n$2;
	return function tonelliSlow(Fp$1, n) {
		if (Fp$1.is0(n)) return n;
		if (FpLegendre(Fp$1, n) !== 1) throw new Error("Cannot find square root");
		let M = S;
		let c = Fp$1.mul(Fp$1.ONE, cc);
		let t = Fp$1.pow(n, Q);
		let R = Fp$1.pow(n, Q1div2);
		while (!Fp$1.eql(t, Fp$1.ONE)) {
			if (Fp$1.is0(t)) return Fp$1.ZERO;
			let i = 1;
			let t_tmp = Fp$1.sqr(t);
			while (!Fp$1.eql(t_tmp, Fp$1.ONE)) {
				i++;
				t_tmp = Fp$1.sqr(t_tmp);
				if (i === M) throw new Error("Cannot find square root");
			}
			const exponent = _1n$3 << BigInt(M - i - 1);
			const b = Fp$1.pow(c, exponent);
			M = i;
			c = Fp$1.sqr(b);
			t = Fp$1.mul(t, c);
			R = Fp$1.mul(R, b);
		}
		return R;
	};
}
/**
* Square root for a finite field. Will try optimized versions first:
*
* 1. P â‰¡ 3 (mod 4)
* 2. P â‰¡ 5 (mod 8)
* 3. P â‰¡ 9 (mod 16)
* 4. Tonelli-Shanks algorithm
*
* Different algorithms can give different roots, it is up to user to decide which one they want.
* For example there is FpSqrtOdd/FpSqrtEven to choice root based on oddness (used for hash-to-curve).
*/
function FpSqrt(P) {
	if (P % _4n === _3n$1) return sqrt3mod4;
	if (P % _8n$2 === _5n$1) return sqrt5mod8;
	if (P % _16n === _9n) return sqrt9mod16(P);
	return tonelliShanks(P);
}
const isNegativeLE = (num, modulo) => (mod(num, modulo) & _1n$3) === _1n$3;
var FIELD_FIELDS = [
	"create",
	"isValid",
	"is0",
	"neg",
	"inv",
	"sqrt",
	"sqr",
	"eql",
	"add",
	"sub",
	"mul",
	"pow",
	"div",
	"addN",
	"subN",
	"mulN",
	"sqrN"
];
function validateField(field) {
	_validateObject(field, FIELD_FIELDS.reduce((map, val) => {
		map[val] = "function";
		return map;
	}, {
		ORDER: "bigint",
		MASK: "bigint",
		BYTES: "number",
		BITS: "number"
	}));
	return field;
}
/**
* Same as `pow` but for Fp: non-constant-time.
* Unsafe in some contexts: uses ladder, so can expose bigint bits.
*/
function FpPow(Fp$1, num, power) {
	if (power < _0n$3) throw new Error("invalid exponent, negatives unsupported");
	if (power === _0n$3) return Fp$1.ONE;
	if (power === _1n$3) return num;
	let p = Fp$1.ONE;
	let d = num;
	while (power > _0n$3) {
		if (power & _1n$3) p = Fp$1.mul(p, d);
		d = Fp$1.sqr(d);
		power >>= _1n$3;
	}
	return p;
}
/**
* Efficiently invert an array of Field elements.
* Exception-free. Will return `undefined` for 0 elements.
* @param passZero map 0 to 0 (instead of undefined)
*/
function FpInvertBatch(Fp$1, nums, passZero = false) {
	const inverted = new Array(nums.length).fill(passZero ? Fp$1.ZERO : void 0);
	const multipliedAcc = nums.reduce((acc, num, i) => {
		if (Fp$1.is0(num)) return acc;
		inverted[i] = acc;
		return Fp$1.mul(acc, num);
	}, Fp$1.ONE);
	const invertedAcc = Fp$1.inv(multipliedAcc);
	nums.reduceRight((acc, num, i) => {
		if (Fp$1.is0(num)) return acc;
		inverted[i] = Fp$1.mul(acc, inverted[i]);
		return Fp$1.mul(acc, num);
	}, invertedAcc);
	return inverted;
}
/**
* Legendre symbol.
* Legendre constant is used to calculate Legendre symbol (a | p)
* which denotes the value of a^((p-1)/2) (mod p).
*
* * (a | p) â‰¡ 1    if a is a square (mod p), quadratic residue
* * (a | p) â‰¡ -1   if a is not a square (mod p), quadratic non residue
* * (a | p) â‰¡ 0    if a â‰¡ 0 (mod p)
*/
function FpLegendre(Fp$1, n) {
	const p1mod2 = (Fp$1.ORDER - _1n$3) / _2n$2;
	const powered = Fp$1.pow(n, p1mod2);
	const yes = Fp$1.eql(powered, Fp$1.ONE);
	const zero = Fp$1.eql(powered, Fp$1.ZERO);
	const no = Fp$1.eql(powered, Fp$1.neg(Fp$1.ONE));
	if (!yes && !zero && !no) throw new Error("invalid Legendre symbol result");
	return yes ? 1 : zero ? 0 : -1;
}
function nLength(n, nBitLength) {
	if (nBitLength !== void 0) anumber(nBitLength);
	const _nBitLength = nBitLength !== void 0 ? nBitLength : n.toString(2).length;
	return {
		nBitLength: _nBitLength,
		nByteLength: Math.ceil(_nBitLength / 8)
	};
}
/**
* Creates a finite field. Major performance optimizations:
* * 1. Denormalized operations like mulN instead of mul.
* * 2. Identical object shape: never add or remove keys.
* * 3. `Object.freeze`.
* Fragile: always run a benchmark on a change.
* Security note: operations don't check 'isValid' for all elements for performance reasons,
* it is caller responsibility to check this.
* This is low-level code, please make sure you know what you're doing.
*
* Note about field properties:
* * CHARACTERISTIC p = prime number, number of elements in main subgroup.
* * ORDER q = similar to cofactor in curves, may be composite `q = p^m`.
*
* @param ORDER field order, probably prime, or could be composite
* @param bitLen how many bits the field consumes
* @param isLE (default: false) if encoding / decoding should be in little-endian
* @param redef optional faster redefinitions of sqrt and other methods
*/
function Field(ORDER, bitLenOrOpts, isLE = false, opts = {}) {
	if (ORDER <= _0n$3) throw new Error("invalid field: expected ORDER > 0, got " + ORDER);
	let _nbitLength = void 0;
	let _sqrt = void 0;
	let modOnDecode = false;
	let allowedLengths = void 0;
	if (typeof bitLenOrOpts === "object" && bitLenOrOpts != null) {
		if (opts.sqrt || isLE) throw new Error("cannot specify opts in two arguments");
		const _opts = bitLenOrOpts;
		if (_opts.BITS) _nbitLength = _opts.BITS;
		if (_opts.sqrt) _sqrt = _opts.sqrt;
		if (typeof _opts.isLE === "boolean") isLE = _opts.isLE;
		if (typeof _opts.modOnDecode === "boolean") modOnDecode = _opts.modOnDecode;
		allowedLengths = _opts.allowedLengths;
	} else {
		if (typeof bitLenOrOpts === "number") _nbitLength = bitLenOrOpts;
		if (opts.sqrt) _sqrt = opts.sqrt;
	}
	const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, _nbitLength);
	if (BYTES > 2048) throw new Error("invalid field: expected ORDER of <= 2048 bytes");
	let sqrtP;
	const f = Object.freeze({
		ORDER,
		isLE,
		BITS,
		BYTES,
		MASK: bitMask(BITS),
		ZERO: _0n$3,
		ONE: _1n$3,
		allowedLengths,
		create: (num) => mod(num, ORDER),
		isValid: (num) => {
			if (typeof num !== "bigint") throw new Error("invalid field element: expected bigint, got " + typeof num);
			return _0n$3 <= num && num < ORDER;
		},
		is0: (num) => num === _0n$3,
		isValidNot0: (num) => !f.is0(num) && f.isValid(num),
		isOdd: (num) => (num & _1n$3) === _1n$3,
		neg: (num) => mod(-num, ORDER),
		eql: (lhs, rhs) => lhs === rhs,
		sqr: (num) => mod(num * num, ORDER),
		add: (lhs, rhs) => mod(lhs + rhs, ORDER),
		sub: (lhs, rhs) => mod(lhs - rhs, ORDER),
		mul: (lhs, rhs) => mod(lhs * rhs, ORDER),
		pow: (num, power) => FpPow(f, num, power),
		div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),
		sqrN: (num) => num * num,
		addN: (lhs, rhs) => lhs + rhs,
		subN: (lhs, rhs) => lhs - rhs,
		mulN: (lhs, rhs) => lhs * rhs,
		inv: (num) => invert(num, ORDER),
		sqrt: _sqrt || ((n) => {
			if (!sqrtP) sqrtP = FpSqrt(ORDER);
			return sqrtP(f, n);
		}),
		toBytes: (num) => isLE ? numberToBytesLE(num, BYTES) : numberToBytesBE(num, BYTES),
		fromBytes: (bytes, skipValidation = true) => {
			if (allowedLengths) {
				if (!allowedLengths.includes(bytes.length) || bytes.length > BYTES) throw new Error("Field.fromBytes: expected " + allowedLengths + " bytes, got " + bytes.length);
				const padded = new Uint8Array(BYTES);
				padded.set(bytes, isLE ? 0 : padded.length - bytes.length);
				bytes = padded;
			}
			if (bytes.length !== BYTES) throw new Error("Field.fromBytes: expected " + BYTES + " bytes, got " + bytes.length);
			let scalar = isLE ? bytesToNumberLE(bytes) : bytesToNumberBE(bytes);
			if (modOnDecode) scalar = mod(scalar, ORDER);
			if (!skipValidation) {
				if (!f.isValid(scalar)) throw new Error("invalid field element: outside of range 0..ORDER");
			}
			return scalar;
		},
		invertBatch: (lst) => FpInvertBatch(f, lst),
		cmov: (a, b, c) => c ? b : a
	});
	return Object.freeze(f);
}

//#endregion
//#region node_modules/.pnpm/@noble+curves@1.9.4/node_modules/@noble/curves/esm/abstract/curve.js
/**
* Methods for elliptic curve multiplication by scalars.
* Contains wNAF, pippenger.
* @module
*/
var _0n$2 = BigInt(0);
var _1n$2 = BigInt(1);
function negateCt(condition, item) {
	const neg = item.negate();
	return condition ? neg : item;
}
/**
* Takes a bunch of Projective Points but executes only one
* inversion on all of them. Inversion is very slow operation,
* so this improves performance massively.
* Optimization: converts a list of projective points to a list of identical points with Z=1.
*/
function normalizeZ(c, points) {
	const invertedZs = FpInvertBatch(c.Fp, points.map((p) => p.Z));
	return points.map((p, i) => c.fromAffine(p.toAffine(invertedZs[i])));
}
function validateW(W, bits) {
	if (!Number.isSafeInteger(W) || W <= 0 || W > bits) throw new Error("invalid window size, expected [1.." + bits + "], got W=" + W);
}
function calcWOpts(W, scalarBits) {
	validateW(W, scalarBits);
	const windows = Math.ceil(scalarBits / W) + 1;
	const windowSize = 2 ** (W - 1);
	const maxNumber = 2 ** W;
	return {
		windows,
		windowSize,
		mask: bitMask(W),
		maxNumber,
		shiftBy: BigInt(W)
	};
}
function calcOffsets(n, window$1, wOpts) {
	const { windowSize, mask, maxNumber, shiftBy } = wOpts;
	let wbits = Number(n & mask);
	let nextN = n >> shiftBy;
	if (wbits > windowSize) {
		wbits -= maxNumber;
		nextN += _1n$2;
	}
	const offsetStart = window$1 * windowSize;
	const offset = offsetStart + Math.abs(wbits) - 1;
	const isZero = wbits === 0;
	const isNeg = wbits < 0;
	const isNegF = window$1 % 2 !== 0;
	return {
		nextN,
		offset,
		isZero,
		isNeg,
		isNegF,
		offsetF: offsetStart
	};
}
function validateMSMPoints(points, c) {
	if (!Array.isArray(points)) throw new Error("array expected");
	points.forEach((p, i) => {
		if (!(p instanceof c)) throw new Error("invalid point at index " + i);
	});
}
function validateMSMScalars(scalars, field) {
	if (!Array.isArray(scalars)) throw new Error("array of scalars expected");
	scalars.forEach((s, i) => {
		if (!field.isValid(s)) throw new Error("invalid scalar at index " + i);
	});
}
var pointPrecomputes = /* @__PURE__ */ new WeakMap();
var pointWindowSizes = /* @__PURE__ */ new WeakMap();
function getW(P) {
	return pointWindowSizes.get(P) || 1;
}
function assert0(n) {
	if (n !== _0n$2) throw new Error("invalid wNAF");
}
/**
* Elliptic curve multiplication of Point by scalar. Fragile.
* Table generation takes **30MB of ram and 10ms on high-end CPU**,
* but may take much longer on slow devices. Actual generation will happen on
* first call of `multiply()`. By default, `BASE` point is precomputed.
*
* Scalars should always be less than curve order: this should be checked inside of a curve itself.
* Creates precomputation tables for fast multiplication:
* - private scalar is split by fixed size windows of W bits
* - every window point is collected from window's table & added to accumulator
* - since windows are different, same point inside tables won't be accessed more than once per calc
* - each multiplication is 'Math.ceil(CURVE_ORDER / ð‘Š) + 1' point additions (fixed for any scalar)
* - +1 window is neccessary for wNAF
* - wNAF reduces table size: 2x less memory + 2x faster generation, but 10% slower multiplication
*
* @todo Research returning 2d JS array of windows, instead of a single window.
* This would allow windows to be in different memory locations
*/
var wNAF = class {
	constructor(Point, bits) {
		this.BASE = Point.BASE;
		this.ZERO = Point.ZERO;
		this.Fn = Point.Fn;
		this.bits = bits;
	}
	_unsafeLadder(elm, n, p = this.ZERO) {
		let d = elm;
		while (n > _0n$2) {
			if (n & _1n$2) p = p.add(d);
			d = d.double();
			n >>= _1n$2;
		}
		return p;
	}
	/**
	* Creates a wNAF precomputation window. Used for caching.
	* Default window size is set by `utils.precompute()` and is equal to 8.
	* Number of precomputed points depends on the curve size:
	* 2^(ð‘Šâˆ’1) * (Math.ceil(ð‘› / ð‘Š) + 1), where:
	* - ð‘Š is the window size
	* - ð‘› is the bitlength of the curve order.
	* For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
	* @param point Point instance
	* @param W window size
	* @returns precomputed point tables flattened to a single array
	*/
	precomputeWindow(point, W) {
		const { windows, windowSize } = calcWOpts(W, this.bits);
		const points = [];
		let p = point;
		let base = p;
		for (let window$1 = 0; window$1 < windows; window$1++) {
			base = p;
			points.push(base);
			for (let i = 1; i < windowSize; i++) {
				base = base.add(p);
				points.push(base);
			}
			p = base.double();
		}
		return points;
	}
	/**
	* Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
	* More compact implementation:
	* https://github.com/paulmillr/noble-secp256k1/blob/47cb1669b6e506ad66b35fe7d76132ae97465da2/index.ts#L502-L541
	* @returns real and fake (for const-time) points
	*/
	wNAF(W, precomputes, n) {
		if (!this.Fn.isValid(n)) throw new Error("invalid scalar");
		let p = this.ZERO;
		let f = this.BASE;
		const wo = calcWOpts(W, this.bits);
		for (let window$1 = 0; window$1 < wo.windows; window$1++) {
			const { nextN, offset, isZero, isNeg, isNegF, offsetF } = calcOffsets(n, window$1, wo);
			n = nextN;
			if (isZero) f = f.add(negateCt(isNegF, precomputes[offsetF]));
			else p = p.add(negateCt(isNeg, precomputes[offset]));
		}
		assert0(n);
		return {
			p,
			f
		};
	}
	/**
	* Implements ec unsafe (non const-time) multiplication using precomputed tables and w-ary non-adjacent form.
	* @param acc accumulator point to add result of multiplication
	* @returns point
	*/
	wNAFUnsafe(W, precomputes, n, acc = this.ZERO) {
		const wo = calcWOpts(W, this.bits);
		for (let window$1 = 0; window$1 < wo.windows; window$1++) {
			if (n === _0n$2) break;
			const { nextN, offset, isZero, isNeg } = calcOffsets(n, window$1, wo);
			n = nextN;
			if (isZero) continue;
			else {
				const item = precomputes[offset];
				acc = acc.add(isNeg ? item.negate() : item);
			}
		}
		assert0(n);
		return acc;
	}
	getPrecomputes(W, point, transform) {
		let comp = pointPrecomputes.get(point);
		if (!comp) {
			comp = this.precomputeWindow(point, W);
			if (W !== 1) {
				if (typeof transform === "function") comp = transform(comp);
				pointPrecomputes.set(point, comp);
			}
		}
		return comp;
	}
	cached(point, scalar, transform) {
		const W = getW(point);
		return this.wNAF(W, this.getPrecomputes(W, point, transform), scalar);
	}
	unsafe(point, scalar, transform, prev) {
		const W = getW(point);
		if (W === 1) return this._unsafeLadder(point, scalar, prev);
		return this.wNAFUnsafe(W, this.getPrecomputes(W, point, transform), scalar, prev);
	}
	createCache(P, W) {
		validateW(W, this.bits);
		pointWindowSizes.set(P, W);
		pointPrecomputes.delete(P);
	}
	hasCache(elm) {
		return getW(elm) !== 1;
	}
};
/**
* Pippenger algorithm for multi-scalar multiplication (MSM, Pa + Qb + Rc + ...).
* 30x faster vs naive addition on L=4096, 10x faster than precomputes.
* For N=254bit, L=1, it does: 1024 ADD + 254 DBL. For L=5: 1536 ADD + 254 DBL.
* Algorithmically constant-time (for same L), even when 1 point + scalar, or when scalar = 0.
* @param c Curve Point constructor
* @param fieldN field over CURVE.N - important that it's not over CURVE.P
* @param points array of L curve points
* @param scalars array of L scalars (aka secret keys / bigints)
*/
function pippenger(c, fieldN, points, scalars) {
	validateMSMPoints(points, c);
	validateMSMScalars(scalars, fieldN);
	const plength = points.length;
	const slength = scalars.length;
	if (plength !== slength) throw new Error("arrays of points and scalars must have equal length");
	const zero = c.ZERO;
	const wbits = bitLen(BigInt(plength));
	let windowSize = 1;
	if (wbits > 12) windowSize = wbits - 3;
	else if (wbits > 4) windowSize = wbits - 2;
	else if (wbits > 0) windowSize = 2;
	const MASK = bitMask(windowSize);
	const buckets = new Array(Number(MASK) + 1).fill(zero);
	const lastBits = Math.floor((fieldN.BITS - 1) / windowSize) * windowSize;
	let sum = zero;
	for (let i = lastBits; i >= 0; i -= windowSize) {
		buckets.fill(zero);
		for (let j = 0; j < slength; j++) {
			const scalar = scalars[j];
			const wbits$1 = Number(scalar >> BigInt(i) & MASK);
			buckets[wbits$1] = buckets[wbits$1].add(points[j]);
		}
		let resI = zero;
		for (let j = buckets.length - 1, sumI = zero; j > 0; j--) {
			sumI = sumI.add(buckets[j]);
			resI = resI.add(sumI);
		}
		sum = sum.add(resI);
		if (i !== 0) for (let j = 0; j < windowSize; j++) sum = sum.double();
	}
	return sum;
}
function createField(order, field) {
	if (field) {
		if (field.ORDER !== order) throw new Error("Field.ORDER must match order: Fp == p, Fn == n");
		validateField(field);
		return field;
	} else return Field(order);
}
/** Validates CURVE opts and creates fields */
function _createCurveFields(type, CURVE, curveOpts = {}) {
	if (!CURVE || typeof CURVE !== "object") throw new Error(`expected valid ${type} CURVE object`);
	for (const p of [
		"p",
		"n",
		"h"
	]) {
		const val = CURVE[p];
		if (!(typeof val === "bigint" && val > _0n$2)) throw new Error(`CURVE.${p} must be positive bigint`);
	}
	const Fp$1 = createField(CURVE.p, curveOpts.Fp);
	const Fn$1 = createField(CURVE.n, curveOpts.Fn);
	const params = [
		"Gx",
		"Gy",
		"a",
		type === "weierstrass" ? "b" : "d"
	];
	for (const p of params) if (!Fp$1.isValid(CURVE[p])) throw new Error(`CURVE.${p} must be valid field element of CURVE.Fp`);
	return {
		Fp: Fp$1,
		Fn: Fn$1
	};
}

//#endregion
//#region node_modules/.pnpm/@noble+curves@1.9.4/node_modules/@noble/curves/esm/abstract/edwards.js
/**
* Twisted Edwards curve. The formula is: axÂ² + yÂ² = 1 + dxÂ²yÂ².
* For design rationale of types / exports, see weierstrass module documentation.
* Untwisted Edwards curves exist, but they aren't used in real-world protocols.
* @module
*/
var _0n$1 = BigInt(0), _1n$1 = BigInt(1), _2n$1 = BigInt(2), _8n$1 = BigInt(8);
function isEdValidXY(Fp$1, CURVE, x$1, y) {
	const x2 = Fp$1.sqr(x$1);
	const y2 = Fp$1.sqr(y);
	const left = Fp$1.add(Fp$1.mul(CURVE.a, x2), y2);
	const right = Fp$1.add(Fp$1.ONE, Fp$1.mul(CURVE.d, Fp$1.mul(x2, y2)));
	return Fp$1.eql(left, right);
}
function edwards(CURVE, curveOpts = {}) {
	const { Fp: Fp$1, Fn: Fn$1 } = _createCurveFields("edwards", CURVE, curveOpts);
	const { h: cofactor, n: CURVE_ORDER } = CURVE;
	_validateObject(curveOpts, {}, { uvRatio: "function" });
	const MASK = _2n$1 << BigInt(Fn$1.BYTES * 8) - _1n$1;
	const modP = (n) => Fp$1.create(n);
	const uvRatio$1 = curveOpts.uvRatio || ((u, v) => {
		try {
			return {
				isValid: true,
				value: Fp$1.sqrt(Fp$1.div(u, v))
			};
		} catch (e) {
			return {
				isValid: false,
				value: _0n$1
			};
		}
	});
	if (!isEdValidXY(Fp$1, CURVE, CURVE.Gx, CURVE.Gy)) throw new Error("bad curve params: generator point");
	/**
	* Asserts coordinate is valid: 0 <= n < MASK.
	* Coordinates >= Fp.ORDER are allowed for zip215.
	*/
	function acoord(title$1, n, banZero = false) {
		const min = banZero ? _1n$1 : _0n$1;
		aInRange("coordinate " + title$1, n, min, MASK);
		return n;
	}
	function aextpoint(other) {
		if (!(other instanceof Point)) throw new Error("ExtendedPoint expected");
	}
	const toAffineMemo = memoized((p, iz) => {
		const { X, Y, Z } = p;
		const is0 = p.is0();
		if (iz == null) iz = is0 ? _8n$1 : Fp$1.inv(Z);
		const x$1 = modP(X * iz);
		const y = modP(Y * iz);
		const zz = Fp$1.mul(Z, iz);
		if (is0) return {
			x: _0n$1,
			y: _1n$1
		};
		if (zz !== _1n$1) throw new Error("invZ was invalid");
		return {
			x: x$1,
			y
		};
	});
	const assertValidMemo = memoized((p) => {
		const { a, d } = CURVE;
		if (p.is0()) throw new Error("bad point: ZERO");
		const { X, Y, Z, T } = p;
		const X2 = modP(X * X);
		const Y2 = modP(Y * Y);
		const Z2 = modP(Z * Z);
		const Z4 = modP(Z2 * Z2);
		if (modP(Z2 * modP(modP(X2 * a) + Y2)) !== modP(Z4 + modP(d * modP(X2 * Y2)))) throw new Error("bad point: equation left != right (1)");
		if (modP(X * Y) !== modP(Z * T)) throw new Error("bad point: equation left != right (2)");
		return true;
	});
	class Point {
		constructor(X, Y, Z, T) {
			this.X = acoord("x", X);
			this.Y = acoord("y", Y);
			this.Z = acoord("z", Z, true);
			this.T = acoord("t", T);
			Object.freeze(this);
		}
		get x() {
			return this.toAffine().x;
		}
		get y() {
			return this.toAffine().y;
		}
		get ex() {
			return this.X;
		}
		get ey() {
			return this.Y;
		}
		get ez() {
			return this.Z;
		}
		get et() {
			return this.T;
		}
		static normalizeZ(points) {
			return normalizeZ(Point, points);
		}
		static msm(points, scalars) {
			return pippenger(Point, Fn$1, points, scalars);
		}
		_setWindowSize(windowSize) {
			this.precompute(windowSize);
		}
		static fromAffine(p) {
			if (p instanceof Point) throw new Error("extended point not allowed");
			const { x: x$1, y } = p || {};
			acoord("x", x$1);
			acoord("y", y);
			return new Point(x$1, y, _1n$1, modP(x$1 * y));
		}
		precompute(windowSize = 8, isLazy = true) {
			wnaf.createCache(this, windowSize);
			if (!isLazy) this.multiply(_2n$1);
			return this;
		}
		assertValidity() {
			assertValidMemo(this);
		}
		equals(other) {
			aextpoint(other);
			const { X: X1, Y: Y1, Z: Z1 } = this;
			const { X: X2, Y: Y2, Z: Z2 } = other;
			const X1Z2 = modP(X1 * Z2);
			const X2Z1 = modP(X2 * Z1);
			const Y1Z2 = modP(Y1 * Z2);
			const Y2Z1 = modP(Y2 * Z1);
			return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;
		}
		is0() {
			return this.equals(Point.ZERO);
		}
		negate() {
			return new Point(modP(-this.X), this.Y, this.Z, modP(-this.T));
		}
		double() {
			const { a } = CURVE;
			const { X: X1, Y: Y1, Z: Z1 } = this;
			const A = modP(X1 * X1);
			const B = modP(Y1 * Y1);
			const C = modP(_2n$1 * modP(Z1 * Z1));
			const D = modP(a * A);
			const x1y1 = X1 + Y1;
			const E = modP(modP(x1y1 * x1y1) - A - B);
			const G = D + B;
			const F = G - C;
			const H = D - B;
			const X3 = modP(E * F);
			const Y3 = modP(G * H);
			const T3 = modP(E * H);
			return new Point(X3, Y3, modP(F * G), T3);
		}
		add(other) {
			aextpoint(other);
			const { a, d } = CURVE;
			const { X: X1, Y: Y1, Z: Z1, T: T1 } = this;
			const { X: X2, Y: Y2, Z: Z2, T: T2 } = other;
			const A = modP(X1 * X2);
			const B = modP(Y1 * Y2);
			const C = modP(T1 * d * T2);
			const D = modP(Z1 * Z2);
			const E = modP((X1 + Y1) * (X2 + Y2) - A - B);
			const F = D - C;
			const G = D + C;
			const H = modP(B - a * A);
			const X3 = modP(E * F);
			const Y3 = modP(G * H);
			const T3 = modP(E * H);
			return new Point(X3, Y3, modP(F * G), T3);
		}
		subtract(other) {
			return this.add(other.negate());
		}
		multiply(scalar) {
			const n = scalar;
			aInRange("scalar", n, _1n$1, CURVE_ORDER);
			const { p, f } = wnaf.cached(this, n, (p$1) => normalizeZ(Point, p$1));
			return normalizeZ(Point, [p, f])[0];
		}
		multiplyUnsafe(scalar, acc = Point.ZERO) {
			const n = scalar;
			aInRange("scalar", n, _0n$1, CURVE_ORDER);
			if (n === _0n$1) return Point.ZERO;
			if (this.is0() || n === _1n$1) return this;
			return wnaf.unsafe(this, n, (p) => normalizeZ(Point, p), acc);
		}
		isSmallOrder() {
			return this.multiplyUnsafe(cofactor).is0();
		}
		isTorsionFree() {
			return wnaf.unsafe(this, CURVE_ORDER).is0();
		}
		toAffine(invertedZ) {
			return toAffineMemo(this, invertedZ);
		}
		clearCofactor() {
			if (cofactor === _1n$1) return this;
			return this.multiplyUnsafe(cofactor);
		}
		static fromBytes(bytes, zip215 = false) {
			abytes(bytes);
			return Point.fromHex(bytes, zip215);
		}
		static fromHex(hex, zip215 = false) {
			const { d, a } = CURVE;
			const len = Fp$1.BYTES;
			hex = ensureBytes("pointHex", hex, len);
			abool("zip215", zip215);
			const normed = hex.slice();
			const lastByte = hex[len - 1];
			normed[len - 1] = lastByte & -129;
			const y = bytesToNumberLE(normed);
			aInRange("pointHex.y", y, _0n$1, zip215 ? MASK : Fp$1.ORDER);
			const y2 = modP(y * y);
			let { isValid, value: x$1 } = uvRatio$1(modP(y2 - _1n$1), modP(d * y2 - a));
			if (!isValid) throw new Error("Point.fromHex: invalid y coordinate");
			const isXOdd = (x$1 & _1n$1) === _1n$1;
			const isLastByteOdd = (lastByte & 128) !== 0;
			if (!zip215 && x$1 === _0n$1 && isLastByteOdd) throw new Error("Point.fromHex: x=0 and x_0=1");
			if (isLastByteOdd !== isXOdd) x$1 = modP(-x$1);
			return Point.fromAffine({
				x: x$1,
				y
			});
		}
		toBytes() {
			const { x: x$1, y } = this.toAffine();
			const bytes = numberToBytesLE(y, Fp$1.BYTES);
			bytes[bytes.length - 1] |= x$1 & _1n$1 ? 128 : 0;
			return bytes;
		}
		/** @deprecated use `toBytes` */
		toRawBytes() {
			return this.toBytes();
		}
		toHex() {
			return bytesToHex(this.toBytes());
		}
		toString() {
			return `<Point ${this.is0() ? "ZERO" : this.toHex()}>`;
		}
	}
	Point.BASE = new Point(CURVE.Gx, CURVE.Gy, _1n$1, modP(CURVE.Gx * CURVE.Gy));
	Point.ZERO = new Point(_0n$1, _1n$1, _1n$1, _0n$1);
	Point.Fp = Fp$1;
	Point.Fn = Fn$1;
	const wnaf = new wNAF(Point, Fn$1.BYTES * 8);
	return Point;
}
/**
* Base class for prime-order points like Ristretto255 and Decaf448.
* These points eliminate cofactor issues by representing equivalence classes
* of Edwards curve points.
*/
var PrimeEdwardsPoint = class {
	constructor(ep) {
		this.ep = ep;
	}
	static fromBytes(_bytes) {
		throw new Error("fromBytes must be implemented by subclass");
	}
	static fromHex(_hex) {
		throw new Error("fromHex must be implemented by subclass");
	}
	get x() {
		return this.toAffine().x;
	}
	get y() {
		return this.toAffine().y;
	}
	clearCofactor() {
		return this;
	}
	assertValidity() {
		this.ep.assertValidity();
	}
	toAffine(invertedZ) {
		return this.ep.toAffine(invertedZ);
	}
	/** @deprecated use `toBytes` */
	toRawBytes() {
		return this.toBytes();
	}
	toHex() {
		return bytesToHex(this.toBytes());
	}
	toString() {
		return this.toHex();
	}
	isTorsionFree() {
		return true;
	}
	isSmallOrder() {
		return false;
	}
	add(other) {
		this.assertSame(other);
		return this.init(this.ep.add(other.ep));
	}
	subtract(other) {
		this.assertSame(other);
		return this.init(this.ep.subtract(other.ep));
	}
	multiply(scalar) {
		return this.init(this.ep.multiply(scalar));
	}
	multiplyUnsafe(scalar) {
		return this.init(this.ep.multiplyUnsafe(scalar));
	}
	double() {
		return this.init(this.ep.double());
	}
	negate() {
		return this.init(this.ep.negate());
	}
	precompute(windowSize, isLazy) {
		return this.init(this.ep.precompute(windowSize, isLazy));
	}
};
/**
* Initializes EdDSA signatures over given Edwards curve.
*/
function eddsa(Point, cHash, eddsaOpts) {
	if (typeof cHash !== "function") throw new Error("\"hash\" function param is required");
	_validateObject(eddsaOpts, {}, {
		adjustScalarBytes: "function",
		randomBytes: "function",
		domain: "function",
		prehash: "function",
		mapToCurve: "function"
	});
	const { prehash } = eddsaOpts;
	const { BASE: G, Fp: Fp$1, Fn: Fn$1 } = Point;
	const CURVE_ORDER = Fn$1.ORDER;
	const randomBytes_ = eddsaOpts.randomBytes || randomBytes;
	const adjustScalarBytes$1 = eddsaOpts.adjustScalarBytes || ((bytes) => bytes);
	const domain = eddsaOpts.domain || ((data, ctx, phflag) => {
		abool("phflag", phflag);
		if (ctx.length || phflag) throw new Error("Contexts/pre-hash are not supported");
		return data;
	});
	function modN(a) {
		return Fn$1.create(a);
	}
	function modN_LE(hash) {
		return modN(bytesToNumberLE(hash));
	}
	function getPrivateScalar(key) {
		const len = Fp$1.BYTES;
		key = ensureBytes("private key", key, len);
		const hashed = ensureBytes("hashed private key", cHash(key), 2 * len);
		const head = adjustScalarBytes$1(hashed.slice(0, len));
		return {
			head,
			prefix: hashed.slice(len, 2 * len),
			scalar: modN_LE(head)
		};
	}
	/** Convenience method that creates public key from scalar. RFC8032 5.1.5 */
	function getExtendedPublicKey(secretKey) {
		const { head, prefix, scalar } = getPrivateScalar(secretKey);
		const point = G.multiply(scalar);
		return {
			head,
			prefix,
			scalar,
			point,
			pointBytes: point.toBytes()
		};
	}
	/** Calculates EdDSA pub key. RFC8032 5.1.5. */
	function getPublicKey(secretKey) {
		return getExtendedPublicKey(secretKey).pointBytes;
	}
	function hashDomainToScalar(context = Uint8Array.of(), ...msgs) {
		return modN_LE(cHash(domain(concatBytes(...msgs), ensureBytes("context", context), !!prehash)));
	}
	/** Signs message with privateKey. RFC8032 5.1.6 */
	function sign(msg, secretKey, options = {}) {
		msg = ensureBytes("message", msg);
		if (prehash) msg = prehash(msg);
		const { prefix, scalar, pointBytes } = getExtendedPublicKey(secretKey);
		const r$1 = hashDomainToScalar(options.context, prefix, msg);
		const R = G.multiply(r$1).toBytes();
		const s = modN(r$1 + hashDomainToScalar(options.context, R, pointBytes, msg) * scalar);
		aInRange("signature.s", s, _0n$1, CURVE_ORDER);
		const L = Fp$1.BYTES;
		return ensureBytes("result", concatBytes(R, numberToBytesLE(s, L)), L * 2);
	}
	const verifyOpts = { zip215: true };
	/**
	* Verifies EdDSA signature against message and public key. RFC8032 5.1.7.
	* An extended group equation is checked.
	*/
	function verify(sig, msg, publicKey, options = verifyOpts) {
		const { context, zip215 } = options;
		const len = Fp$1.BYTES;
		sig = ensureBytes("signature", sig, 2 * len);
		msg = ensureBytes("message", msg);
		publicKey = ensureBytes("publicKey", publicKey, len);
		if (zip215 !== void 0) abool("zip215", zip215);
		if (prehash) msg = prehash(msg);
		const s = bytesToNumberLE(sig.slice(len, 2 * len));
		let A, R, SB;
		try {
			A = Point.fromHex(publicKey, zip215);
			R = Point.fromHex(sig.slice(0, len), zip215);
			SB = G.multiplyUnsafe(s);
		} catch (error) {
			return false;
		}
		if (!zip215 && A.isSmallOrder()) return false;
		const k = hashDomainToScalar(context, R.toBytes(), A.toBytes(), msg);
		return R.add(A.multiplyUnsafe(k)).subtract(SB).clearCofactor().is0();
	}
	G.precompute(8);
	const size = Fp$1.BYTES;
	const lengths = {
		secret: size,
		public: size,
		signature: 2 * size,
		seed: size
	};
	function randomSecretKey(seed = randomBytes_(lengths.seed)) {
		return seed;
	}
	const utils = {
		getExtendedPublicKey,
		randomSecretKey,
		isValidSecretKey,
		isValidPublicKey,
		randomPrivateKey: randomSecretKey,
		toMontgomery(publicKey) {
			const { y } = Point.fromBytes(publicKey);
			const is25519 = size === 32;
			if (!is25519 && size !== 57) throw new Error("only defined for 25519 and 448");
			const u = is25519 ? Fp$1.div(_1n$1 + y, _1n$1 - y) : Fp$1.div(y - _1n$1, y + _1n$1);
			return Fp$1.toBytes(u);
		},
		toMontgomeryPriv(privateKey) {
			abytes(privateKey, size);
			return adjustScalarBytes$1(cHash(privateKey.subarray(0, size))).subarray(0, size);
		},
		precompute(windowSize = 8, point = Point.BASE) {
			return point.precompute(windowSize, false);
		}
	};
	function keygen(seed) {
		const secretKey = utils.randomSecretKey(seed);
		return {
			secretKey,
			publicKey: getPublicKey(secretKey)
		};
	}
	function isValidSecretKey(key) {
		try {
			return !!Fn$1.fromBytes(key, false);
		} catch (error) {
			return false;
		}
	}
	function isValidPublicKey(key, zip215) {
		try {
			return !!Point.fromBytes(key, zip215);
		} catch (error) {
			return false;
		}
	}
	return Object.freeze({
		keygen,
		getPublicKey,
		sign,
		verify,
		utils,
		Point,
		info: {
			type: "edwards",
			lengths
		}
	});
}
function _eddsa_legacy_opts_to_new(c) {
	const CURVE = {
		a: c.a,
		d: c.d,
		p: c.Fp.ORDER,
		n: c.n,
		h: c.h,
		Gx: c.Gx,
		Gy: c.Gy
	};
	const curveOpts = {
		Fp: c.Fp,
		Fn: Field(CURVE.n, c.nBitLength, true),
		uvRatio: c.uvRatio
	};
	const eddsaOpts = {
		randomBytes: c.randomBytes,
		adjustScalarBytes: c.adjustScalarBytes,
		domain: c.domain,
		prehash: c.prehash,
		mapToCurve: c.mapToCurve
	};
	return {
		CURVE,
		curveOpts,
		hash: c.hash,
		eddsaOpts
	};
}
function _eddsa_new_output_to_legacy(c, eddsa$1) {
	return Object.assign({}, eddsa$1, {
		ExtendedPoint: eddsa$1.Point,
		CURVE: c
	});
}
function twistedEdwards(c) {
	const { CURVE, curveOpts, hash, eddsaOpts } = _eddsa_legacy_opts_to_new(c);
	return _eddsa_new_output_to_legacy(c, eddsa(edwards(CURVE, curveOpts), hash, eddsaOpts));
}

//#endregion
//#region node_modules/.pnpm/@noble+curves@1.9.4/node_modules/@noble/curves/esm/ed25519.js
/**
* ed25519 Twisted Edwards curve with following addons:
* - X25519 ECDH
* - Ristretto cofactor elimination
* - Elligator hash-to-group / point indistinguishability
* @module
*/
var _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3);
var _5n = BigInt(5), _8n = BigInt(8);
var ed25519_CURVE = {
	p: BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffed"),
	n: BigInt("0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed"),
	h: _8n,
	a: BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec"),
	d: BigInt("0x52036cee2b6ffe738cc740797779e89800700a4d4141d8ab75eb4dca135978a3"),
	Gx: BigInt("0x216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a"),
	Gy: BigInt("0x6666666666666666666666666666666666666666666666666666666666666658")
};
function ed25519_pow_2_252_3(x$1) {
	const _10n = BigInt(10), _20n = BigInt(20), _40n = BigInt(40), _80n = BigInt(80);
	const P = ed25519_CURVE.p;
	const b2 = x$1 * x$1 % P * x$1 % P;
	const b5 = pow2(pow2(b2, _2n, P) * b2 % P, _1n, P) * x$1 % P;
	const b10 = pow2(b5, _5n, P) * b5 % P;
	const b20 = pow2(b10, _10n, P) * b10 % P;
	const b40 = pow2(b20, _20n, P) * b20 % P;
	const b80 = pow2(b40, _40n, P) * b40 % P;
	return {
		pow_p_5_8: pow2(pow2(pow2(pow2(b80, _80n, P) * b80 % P, _80n, P) * b80 % P, _10n, P) * b10 % P, _2n, P) * x$1 % P,
		b2
	};
}
function adjustScalarBytes(bytes) {
	bytes[0] &= 248;
	bytes[31] &= 127;
	bytes[31] |= 64;
	return bytes;
}
var ED25519_SQRT_M1 = /* @__PURE__ */ BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");
function uvRatio(u, v) {
	const P = ed25519_CURVE.p;
	const v3 = mod(v * v * v, P);
	const pow = ed25519_pow_2_252_3(u * mod(v3 * v3 * v, P)).pow_p_5_8;
	let x$1 = mod(u * v3 * pow, P);
	const vx2 = mod(v * x$1 * x$1, P);
	const root1 = x$1;
	const root2 = mod(x$1 * ED25519_SQRT_M1, P);
	const useRoot1 = vx2 === u;
	const useRoot2 = vx2 === mod(-u, P);
	const noRoot = vx2 === mod(-u * ED25519_SQRT_M1, P);
	if (useRoot1) x$1 = root1;
	if (useRoot2 || noRoot) x$1 = root2;
	if (isNegativeLE(x$1, P)) x$1 = mod(-x$1, P);
	return {
		isValid: useRoot1 || useRoot2,
		value: x$1
	};
}
var Fp = /* @__PURE__ */ (() => Field(ed25519_CURVE.p, { isLE: true }))();
var Fn = /* @__PURE__ */ (() => Field(ed25519_CURVE.n, { isLE: true }))();
var ed25519Defaults = /* @__PURE__ */ (() => ({
	...ed25519_CURVE,
	Fp,
	hash: sha512$1,
	adjustScalarBytes,
	uvRatio
}))();
/**
* ed25519 curve with EdDSA signatures.
* @example
* import { ed25519 } from '@noble/curves/ed25519';
* const { secretKey, publicKey } = ed25519.keygen();
* const msg = new TextEncoder().encode('hello');
* const sig = ed25519.sign(msg, priv);
* ed25519.verify(sig, msg, pub); // Default mode: follows ZIP215
* ed25519.verify(sig, msg, pub, { zip215: false }); // RFC8032 / FIPS 186-5
*/
const ed25519 = /* @__PURE__ */ (() => twistedEdwards(ed25519Defaults))();
var SQRT_M1 = ED25519_SQRT_M1;
var SQRT_AD_MINUS_ONE = /* @__PURE__ */ BigInt("25063068953384623474111414158702152701244531502492656460079210482610430750235");
var INVSQRT_A_MINUS_D = /* @__PURE__ */ BigInt("54469307008909316920995813868745141605393597292927456921205312896311721017578");
var ONE_MINUS_D_SQ = /* @__PURE__ */ BigInt("1159843021668779879193775521855586647937357759715417654439879720876111806838");
var D_MINUS_ONE_SQ = /* @__PURE__ */ BigInt("40440834346308536858101042469323190826248399146238708352240133220865137265952");
var invertSqrt = (number$1) => uvRatio(_1n, number$1);
var MAX_255B = /* @__PURE__ */ BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
var bytes255ToNumberLE = (bytes) => ed25519.CURVE.Fp.create(bytesToNumberLE(bytes) & MAX_255B);
/**
* Computes Elligator map for Ristretto255.
* Described in [RFC9380](https://www.rfc-editor.org/rfc/rfc9380#appendix-B) and on
* the [website](https://ristretto.group/formulas/elligator.html).
*/
function calcElligatorRistrettoMap(r0) {
	const { d } = ed25519.CURVE;
	const P = ed25519.CURVE.Fp.ORDER;
	const mod$1 = ed25519.CURVE.Fp.create;
	const r$1 = mod$1(SQRT_M1 * r0 * r0);
	const Ns = mod$1((r$1 + _1n) * ONE_MINUS_D_SQ);
	let c = BigInt(-1);
	const D = mod$1((c - d * r$1) * mod$1(r$1 + d));
	let { isValid: Ns_D_is_sq, value: s } = uvRatio(Ns, D);
	let s_ = mod$1(s * r0);
	if (!isNegativeLE(s_, P)) s_ = mod$1(-s_);
	if (!Ns_D_is_sq) s = s_;
	if (!Ns_D_is_sq) c = r$1;
	const Nt = mod$1(c * (r$1 - _1n) * D_MINUS_ONE_SQ - D);
	const s2 = s * s;
	const W0 = mod$1((s + s) * D);
	const W1 = mod$1(Nt * SQRT_AD_MINUS_ONE);
	const W2 = mod$1(_1n - s2);
	const W3 = mod$1(_1n + s2);
	return new ed25519.Point(mod$1(W0 * W3), mod$1(W2 * W1), mod$1(W1 * W3), mod$1(W0 * W2));
}
function ristretto255_map(bytes) {
	abytes(bytes, 64);
	const R1 = calcElligatorRistrettoMap(bytes255ToNumberLE(bytes.subarray(0, 32)));
	const R2 = calcElligatorRistrettoMap(bytes255ToNumberLE(bytes.subarray(32, 64)));
	return new _RistrettoPoint(R1.add(R2));
}
/**
* Wrapper over Edwards Point for ristretto255.
*
* Each ed25519/ExtendedPoint has 8 different equivalent points. This can be
* a source of bugs for protocols like ring signatures. Ristretto was created to solve this.
* Ristretto point operates in X:Y:Z:T extended coordinates like ExtendedPoint,
* but it should work in its own namespace: do not combine those two.
* See [RFC9496](https://www.rfc-editor.org/rfc/rfc9496).
*/
var _RistrettoPoint = class _RistrettoPoint extends PrimeEdwardsPoint {
	constructor(ep) {
		super(ep);
	}
	static fromAffine(ap) {
		return new _RistrettoPoint(ed25519.Point.fromAffine(ap));
	}
	assertSame(other) {
		if (!(other instanceof _RistrettoPoint)) throw new Error("RistrettoPoint expected");
	}
	init(ep) {
		return new _RistrettoPoint(ep);
	}
	/** @deprecated use `import { ristretto255_hasher } from '@noble/curves/ed25519.js';` */
	static hashToCurve(hex) {
		return ristretto255_map(ensureBytes("ristrettoHash", hex, 64));
	}
	static fromBytes(bytes) {
		abytes(bytes, 32);
		const { a, d } = ed25519.CURVE;
		const P = Fp.ORDER;
		const mod$1 = Fp.create;
		const s = bytes255ToNumberLE(bytes);
		if (!equalBytes(numberToBytesLE(s, 32), bytes) || isNegativeLE(s, P)) throw new Error("invalid ristretto255 encoding 1");
		const s2 = mod$1(s * s);
		const u1 = mod$1(_1n + a * s2);
		const u2 = mod$1(_1n - a * s2);
		const u1_2 = mod$1(u1 * u1);
		const u2_2 = mod$1(u2 * u2);
		const v = mod$1(a * d * u1_2 - u2_2);
		const { isValid, value: I } = invertSqrt(mod$1(v * u2_2));
		const Dx = mod$1(I * u2);
		const Dy = mod$1(I * Dx * v);
		let x$1 = mod$1((s + s) * Dx);
		if (isNegativeLE(x$1, P)) x$1 = mod$1(-x$1);
		const y = mod$1(u1 * Dy);
		const t = mod$1(x$1 * y);
		if (!isValid || isNegativeLE(t, P) || y === _0n) throw new Error("invalid ristretto255 encoding 2");
		return new _RistrettoPoint(new ed25519.Point(x$1, y, _1n, t));
	}
	/**
	* Converts ristretto-encoded string to ristretto point.
	* Described in [RFC9496](https://www.rfc-editor.org/rfc/rfc9496#name-decode).
	* @param hex Ristretto-encoded 32 bytes. Not every 32-byte string is valid ristretto encoding
	*/
	static fromHex(hex) {
		return _RistrettoPoint.fromBytes(ensureBytes("ristrettoHex", hex, 32));
	}
	static msm(points, scalars) {
		return pippenger(_RistrettoPoint, ed25519.Point.Fn, points, scalars);
	}
	/**
	* Encodes ristretto point to Uint8Array.
	* Described in [RFC9496](https://www.rfc-editor.org/rfc/rfc9496#name-encode).
	*/
	toBytes() {
		let { X, Y, Z, T } = this.ep;
		const P = Fp.ORDER;
		const mod$1 = Fp.create;
		const u1 = mod$1(mod$1(Z + Y) * mod$1(Z - Y));
		const u2 = mod$1(X * Y);
		const { value: invsqrt } = invertSqrt(mod$1(u1 * mod$1(u2 * u2)));
		const D1 = mod$1(invsqrt * u1);
		const D2 = mod$1(invsqrt * u2);
		const zInv = mod$1(D1 * D2 * T);
		let D;
		if (isNegativeLE(T * zInv, P)) {
			let _x = mod$1(Y * SQRT_M1);
			let _y = mod$1(X * SQRT_M1);
			X = _x;
			Y = _y;
			D = mod$1(D1 * INVSQRT_A_MINUS_D);
		} else D = D2;
		if (isNegativeLE(X * zInv, P)) Y = mod$1(-Y);
		let s = mod$1((Z - Y) * D);
		if (isNegativeLE(s, P)) s = mod$1(-s);
		return numberToBytesLE(s, 32);
	}
	/**
	* Compares two Ristretto points.
	* Described in [RFC9496](https://www.rfc-editor.org/rfc/rfc9496#name-equals).
	*/
	equals(other) {
		this.assertSame(other);
		const { X: X1, Y: Y1 } = this.ep;
		const { X: X2, Y: Y2 } = other.ep;
		const mod$1 = Fp.create;
		const one = mod$1(X1 * Y2) === mod$1(Y1 * X2);
		const two = mod$1(Y1 * Y2) === mod$1(X1 * X2);
		return one || two;
	}
	is0() {
		return this.equals(_RistrettoPoint.ZERO);
	}
};
_RistrettoPoint.BASE = /* @__PURE__ */ (() => new _RistrettoPoint(ed25519.Point.BASE))();
_RistrettoPoint.ZERO = /* @__PURE__ */ (() => new _RistrettoPoint(ed25519.Point.ZERO))();
_RistrettoPoint.Fp = Fp;
_RistrettoPoint.Fn = Fn;

//#endregion
//#region node_modules/.pnpm/@mysten+sui@1.45.2_typescript@5.9.3/node_modules/@mysten/sui/dist/esm/cryptography/intent.js
function messageWithIntent(scope, message) {
	return suiBcs.IntentMessage(suiBcs.bytes(message.length)).serialize({
		intent: {
			scope: { [scope]: true },
			version: { V0: true },
			appId: { Sui: true }
		},
		value: message
	}).toBytes();
}

//#endregion
//#region node_modules/.pnpm/@mysten+sui@1.45.2_typescript@5.9.3/node_modules/@mysten/sui/dist/esm/cryptography/signature-scheme.js
var SIGNATURE_SCHEME_TO_FLAG = {
	ED25519: 0,
	Secp256k1: 1,
	Secp256r1: 2,
	MultiSig: 3,
	ZkLogin: 5,
	Passkey: 6
};
var SIGNATURE_SCHEME_TO_SIZE = {
	ED25519: 32,
	Secp256k1: 33,
	Secp256r1: 33,
	Passkey: 33
};
var SIGNATURE_FLAG_TO_SCHEME = {
	0: "ED25519",
	1: "Secp256k1",
	2: "Secp256r1",
	3: "MultiSig",
	5: "ZkLogin",
	6: "Passkey"
};

//#endregion
//#region node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/esm/hmac.js
/**
* HMAC: RFC2104 message authentication code.
* @module
*/
var HMAC = class extends Hash {
	constructor(hash, _key) {
		super();
		this.finished = false;
		this.destroyed = false;
		ahash(hash);
		const key = toBytes(_key);
		this.iHash = hash.create();
		if (typeof this.iHash.update !== "function") throw new Error("Expected instance of class which extends utils.Hash");
		this.blockLen = this.iHash.blockLen;
		this.outputLen = this.iHash.outputLen;
		const blockLen = this.blockLen;
		const pad = new Uint8Array(blockLen);
		pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);
		for (let i = 0; i < pad.length; i++) pad[i] ^= 54;
		this.iHash.update(pad);
		this.oHash = hash.create();
		for (let i = 0; i < pad.length; i++) pad[i] ^= 106;
		this.oHash.update(pad);
		clean(pad);
	}
	update(buf) {
		aexists(this);
		this.iHash.update(buf);
		return this;
	}
	digestInto(out) {
		aexists(this);
		abytes(out, this.outputLen);
		this.finished = true;
		this.iHash.digestInto(out);
		this.oHash.update(out);
		this.oHash.digestInto(out);
		this.destroy();
	}
	digest() {
		const out = new Uint8Array(this.oHash.outputLen);
		this.digestInto(out);
		return out;
	}
	_cloneInto(to) {
		to || (to = Object.create(Object.getPrototypeOf(this), {}));
		const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
		to = to;
		to.finished = finished;
		to.destroyed = destroyed;
		to.blockLen = blockLen;
		to.outputLen = outputLen;
		to.oHash = oHash._cloneInto(to.oHash);
		to.iHash = iHash._cloneInto(to.iHash);
		return to;
	}
	clone() {
		return this._cloneInto();
	}
	destroy() {
		this.destroyed = true;
		this.oHash.destroy();
		this.iHash.destroy();
	}
};
/**
* HMAC: RFC2104 message authentication code.
* @param hash - function that would be used e.g. sha256
* @param key - message key
* @param message - message data
* @example
* import { hmac } from '@noble/hashes/hmac';
* import { sha256 } from '@noble/hashes/sha2';
* const mac1 = hmac(sha256, 'key', 'message');
*/
const hmac = (hash, key, message) => new HMAC(hash, key).update(message).digest();
hmac.create = (hash, key) => new HMAC(hash, key);

//#endregion
//#region node_modules/.pnpm/@mysten+sui@1.45.2_typescript@5.9.3/node_modules/@mysten/sui/dist/esm/cryptography/publickey.js
function bytesEqual(a, b) {
	if (a === b) return true;
	if (a.length !== b.length) return false;
	for (let i = 0; i < a.length; i++) if (a[i] !== b[i]) return false;
	return true;
}
var PublicKey = class {
	/**
	* Checks if two public keys are equal
	*/
	equals(publicKey) {
		return bytesEqual(this.toRawBytes(), publicKey.toRawBytes());
	}
	/**
	* Return the base-64 representation of the public key
	*/
	toBase64() {
		return toBase64(this.toRawBytes());
	}
	toString() {
		throw new Error("`toString` is not implemented on public keys. Use `toBase64()` or `toRawBytes()` instead.");
	}
	/**
	* Return the Sui representation of the public key encoded in
	* base-64. A Sui public key is formed by the concatenation
	* of the scheme flag with the raw bytes of the public key
	*/
	toSuiPublicKey() {
		return toBase64(this.toSuiBytes());
	}
	verifyWithIntent(bytes, signature, intent) {
		const digest = blake2b(messageWithIntent(intent, bytes), { dkLen: 32 });
		return this.verify(digest, signature);
	}
	/**
	* Verifies that the signature is valid for for the provided PersonalMessage
	*/
	verifyPersonalMessage(message, signature) {
		return this.verifyWithIntent(suiBcs.byteVector().serialize(message).toBytes(), signature, "PersonalMessage");
	}
	/**
	* Verifies that the signature is valid for for the provided Transaction
	*/
	verifyTransaction(transaction, signature) {
		return this.verifyWithIntent(transaction, signature, "TransactionData");
	}
	/**
	* Verifies that the public key is associated with the provided address
	*/
	verifyAddress(address) {
		return this.toSuiAddress() === address;
	}
	/**
	* Returns the bytes representation of the public key
	* prefixed with the signature scheme flag
	*/
	toSuiBytes() {
		const rawBytes = this.toRawBytes();
		const suiBytes = new Uint8Array(rawBytes.length + 1);
		suiBytes.set([this.flag()]);
		suiBytes.set(rawBytes, 1);
		return suiBytes;
	}
	/**
	* Return the Sui address associated with this Ed25519 public key
	*/
	toSuiAddress() {
		return normalizeSuiAddress(bytesToHex(blake2b(this.toSuiBytes(), { dkLen: 32 })).slice(0, SUI_ADDRESS_LENGTH * 2));
	}
};
function parseSerializedKeypairSignature(serializedSignature) {
	const bytes = fromBase64(serializedSignature);
	const signatureScheme = SIGNATURE_FLAG_TO_SCHEME[bytes[0]];
	switch (signatureScheme) {
		case "ED25519":
		case "Secp256k1":
		case "Secp256r1":
			const size = SIGNATURE_SCHEME_TO_SIZE[signatureScheme];
			const signature = bytes.slice(1, bytes.length - size);
			return {
				serializedSignature,
				signatureScheme,
				signature,
				publicKey: bytes.slice(1 + signature.length),
				bytes
			};
		default: throw new Error("Unsupported signature scheme");
	}
}

//#endregion
//#region node_modules/.pnpm/@mysten+sui@1.45.2_typescript@5.9.3/node_modules/@mysten/sui/dist/esm/cryptography/signature.js
function toSerializedSignature({ signature, signatureScheme, publicKey }) {
	if (!publicKey) throw new Error("`publicKey` is required");
	const pubKeyBytes = publicKey.toRawBytes();
	const serializedSignature = new Uint8Array(1 + signature.length + pubKeyBytes.length);
	serializedSignature.set([SIGNATURE_SCHEME_TO_FLAG[signatureScheme]]);
	serializedSignature.set(signature, 1);
	serializedSignature.set(pubKeyBytes, 1 + signature.length);
	return toBase64(serializedSignature);
}

//#endregion
//#region node_modules/.pnpm/@mysten+sui@1.45.2_typescript@5.9.3/node_modules/@mysten/sui/dist/esm/cryptography/keypair.js
var PRIVATE_KEY_SIZE = 32;
var SUI_PRIVATE_KEY_PREFIX = "suiprivkey";
var Signer = class {
	/**
	* Sign messages with a specific intent. By combining the message bytes with the intent before hashing and signing,
	* it ensures that a signed message is tied to a specific purpose and domain separator is provided
	*/
	async signWithIntent(bytes, intent) {
		const digest = blake2b(messageWithIntent(intent, bytes), { dkLen: 32 });
		return {
			signature: toSerializedSignature({
				signature: await this.sign(digest),
				signatureScheme: this.getKeyScheme(),
				publicKey: this.getPublicKey()
			}),
			bytes: toBase64(bytes)
		};
	}
	/**
	* Signs provided transaction by calling `signWithIntent()` with a `TransactionData` provided as intent scope
	*/
	async signTransaction(bytes) {
		return this.signWithIntent(bytes, "TransactionData");
	}
	/**
	* Signs provided personal message by calling `signWithIntent()` with a `PersonalMessage` provided as intent scope
	*/
	async signPersonalMessage(bytes) {
		const { signature } = await this.signWithIntent(bcs.byteVector().serialize(bytes).toBytes(), "PersonalMessage");
		return {
			bytes: toBase64(bytes),
			signature
		};
	}
	async signAndExecuteTransaction({ transaction, client }) {
		const bytes = await transaction.build({ client });
		const { signature } = await this.signTransaction(bytes);
		return (await client.core.executeTransaction({
			transaction: bytes,
			signatures: [signature]
		})).transaction;
	}
	toSuiAddress() {
		return this.getPublicKey().toSuiAddress();
	}
};
var Keypair = class extends Signer {};
function decodeSuiPrivateKey(value) {
	const { prefix, words } = bech32.decode(value);
	if (prefix !== SUI_PRIVATE_KEY_PREFIX) throw new Error("invalid private key prefix");
	const extendedSecretKey = new Uint8Array(bech32.fromWords(words));
	const secretKey = extendedSecretKey.slice(1);
	const signatureScheme = SIGNATURE_FLAG_TO_SCHEME[extendedSecretKey[0]];
	return {
		scheme: signatureScheme,
		schema: signatureScheme,
		secretKey
	};
}
function encodeSuiPrivateKey(bytes, scheme) {
	if (bytes.length !== PRIVATE_KEY_SIZE) throw new Error("Invalid bytes length");
	const flag = SIGNATURE_SCHEME_TO_FLAG[scheme];
	const privKeyBytes = new Uint8Array(bytes.length + 1);
	privKeyBytes.set([flag]);
	privKeyBytes.set(bytes, 1);
	return bech32.encode(SUI_PRIVATE_KEY_PREFIX, bech32.toWords(privKeyBytes));
}

//#endregion
//#region node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/esm/pbkdf2.js
/**
* PBKDF (RFC 2898). Can be used to create a key from password and salt.
* @module
*/
function pbkdf2Init(hash, _password, _salt, _opts) {
	ahash(hash);
	const { c, dkLen, asyncTick } = checkOpts({
		dkLen: 32,
		asyncTick: 10
	}, _opts);
	anumber(c);
	anumber(dkLen);
	anumber(asyncTick);
	if (c < 1) throw new Error("iterations (c) should be >= 1");
	const password = kdfInputToBytes(_password);
	const salt = kdfInputToBytes(_salt);
	const DK = new Uint8Array(dkLen);
	const PRF = hmac.create(hash, password);
	return {
		c,
		dkLen,
		asyncTick,
		DK,
		PRF,
		PRFSalt: PRF._cloneInto().update(salt)
	};
}
function pbkdf2Output(PRF, PRFSalt, DK, prfW, u) {
	PRF.destroy();
	PRFSalt.destroy();
	if (prfW) prfW.destroy();
	clean(u);
	return DK;
}
/**
* PBKDF2-HMAC: RFC 2898 key derivation function
* @param hash - hash function that would be used e.g. sha256
* @param password - password from which a derived key is generated
* @param salt - cryptographic salt
* @param opts - {c, dkLen} where c is work factor and dkLen is output message size
* @example
* const key = pbkdf2(sha256, 'password', 'salt', { dkLen: 32, c: Math.pow(2, 18) });
*/
function pbkdf2(hash, password, salt, opts) {
	const { c, dkLen, DK, PRF, PRFSalt } = pbkdf2Init(hash, password, salt, opts);
	let prfW;
	const arr = new Uint8Array(4);
	const view = createView(arr);
	const u = new Uint8Array(PRF.outputLen);
	for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {
		const Ti = DK.subarray(pos, pos + PRF.outputLen);
		view.setInt32(0, ti, false);
		(prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);
		Ti.set(u.subarray(0, Ti.length));
		for (let ui = 1; ui < c; ui++) {
			PRF._cloneInto(prfW).update(u).digestInto(u);
			for (let i = 0; i < Ti.length; i++) Ti[i] ^= u[i];
		}
	}
	return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);
}

//#endregion
//#region node_modules/.pnpm/@scure+bip39@1.6.0/node_modules/@scure/bip39/esm/index.js
/**
* Audited & minimal JS implementation of
* [BIP39 mnemonic phrases](https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki).
* @module
* @example
```js
import * as bip39 from '@scure/bip39';
import { wordlist } from '@scure/bip39/wordlists/english';
const mn = bip39.generateMnemonic(wordlist);
console.log(mn);
const ent = bip39.mnemonicToEntropy(mn, wordlist)
bip39.entropyToMnemonic(ent, wordlist);
bip39.validateMnemonic(mn, wordlist);
await bip39.mnemonicToSeed(mn, 'password');
bip39.mnemonicToSeedSync(mn, 'password');

// Wordlists
import { wordlist as czech } from '@scure/bip39/wordlists/czech';
import { wordlist as english } from '@scure/bip39/wordlists/english';
import { wordlist as french } from '@scure/bip39/wordlists/french';
import { wordlist as italian } from '@scure/bip39/wordlists/italian';
import { wordlist as japanese } from '@scure/bip39/wordlists/japanese';
import { wordlist as korean } from '@scure/bip39/wordlists/korean';
import { wordlist as portuguese } from '@scure/bip39/wordlists/portuguese';
import { wordlist as simplifiedChinese } from '@scure/bip39/wordlists/simplified-chinese';
import { wordlist as spanish } from '@scure/bip39/wordlists/spanish';
import { wordlist as traditionalChinese } from '@scure/bip39/wordlists/traditional-chinese';
```
*/
function nfkd(str) {
	if (typeof str !== "string") throw new TypeError("invalid mnemonic type: " + typeof str);
	return str.normalize("NFKD");
}
function normalize(str) {
	const norm = nfkd(str);
	const words = norm.split(" ");
	if (![
		12,
		15,
		18,
		21,
		24
	].includes(words.length)) throw new Error("Invalid mnemonic");
	return {
		nfkd: norm,
		words
	};
}
var psalt = (passphrase) => nfkd("mnemonic" + passphrase);
/**
* Irreversible: Uses KDF to derive 64 bytes of key data from mnemonic + optional password.
* @param mnemonic 12-24 words
* @param passphrase string that will additionally protect the key
* @returns 64 bytes of key data
* @example
* const mnem = 'legal winner thank year wave sausage worth useful legal winner thank yellow';
* mnemonicToSeedSync(mnem, 'password');
* // new Uint8Array([...64 bytes])
*/
function mnemonicToSeedSync(mnemonic, passphrase = "") {
	return pbkdf2(sha512$1, normalize(mnemonic).nfkd, psalt(passphrase), {
		c: 2048,
		dkLen: 64
	});
}

//#endregion
//#region node_modules/.pnpm/@mysten+sui@1.45.2_typescript@5.9.3/node_modules/@mysten/sui/dist/esm/cryptography/mnemonics.js
function isValidHardenedPath(path) {
	if (!(/* @__PURE__ */ new RegExp("^m\\/44'\\/784'\\/[0-9]+'\\/[0-9]+'\\/[0-9]+'+$")).test(path)) return false;
	return true;
}
function mnemonicToSeed(mnemonics) {
	return mnemonicToSeedSync(mnemonics, "");
}
function mnemonicToSeedHex(mnemonics) {
	return toHex(mnemonicToSeed(mnemonics));
}

//#endregion
//#region node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/esm/sha512.js
/**
* SHA2-512 a.k.a. sha512 and sha384. It is slower than sha256 in js because u64 operations are slow.
*
* Check out [RFC 4634](https://datatracker.ietf.org/doc/html/rfc4634) and
* [the paper on truncated SHA512/256](https://eprint.iacr.org/2010/548.pdf).
* @module
* @deprecated
*/
/** @deprecated Use import from `noble/hashes/sha2` module */
const sha512 = sha512$1;

//#endregion
//#region node_modules/.pnpm/@mysten+sui@1.45.2_typescript@5.9.3/node_modules/@mysten/sui/dist/esm/keypairs/ed25519/ed25519-hd-key.js
var ED25519_CURVE = "ed25519 seed";
var HARDENED_OFFSET = 2147483648;
var pathRegex = /* @__PURE__ */ new RegExp("^m(\\/[0-9]+')+$");
var replaceDerive = (val) => val.replace("'", "");
var getMasterKeyFromSeed = (seed) => {
	const I = hmac.create(sha512, ED25519_CURVE).update(fromHex(seed)).digest();
	return {
		key: I.slice(0, 32),
		chainCode: I.slice(32)
	};
};
var CKDPriv = ({ key, chainCode }, index) => {
	const indexBuffer = /* @__PURE__ */ new ArrayBuffer(4);
	new DataView(indexBuffer).setUint32(0, index);
	const data = new Uint8Array(1 + key.length + indexBuffer.byteLength);
	data.set(new Uint8Array(1).fill(0));
	data.set(key, 1);
	data.set(new Uint8Array(indexBuffer, 0, indexBuffer.byteLength), key.length + 1);
	const I = hmac.create(sha512, chainCode).update(data).digest();
	return {
		key: I.slice(0, 32),
		chainCode: I.slice(32)
	};
};
var isValidPath = (path) => {
	if (!pathRegex.test(path)) return false;
	return !path.split("/").slice(1).map(replaceDerive).some(isNaN);
};
var derivePath = (path, seed, offset = HARDENED_OFFSET) => {
	if (!isValidPath(path)) throw new Error("Invalid derivation path");
	const { key, chainCode } = getMasterKeyFromSeed(seed);
	return path.split("/").slice(1).map(replaceDerive).map((el) => parseInt(el, 10)).reduce((parentKeys, segment) => CKDPriv(parentKeys, segment + offset), {
		key,
		chainCode
	});
};

//#endregion
//#region node_modules/.pnpm/@mysten+sui@1.45.2_typescript@5.9.3/node_modules/@mysten/sui/dist/esm/keypairs/ed25519/publickey.js
var PUBLIC_KEY_SIZE = 32;
var Ed25519PublicKey = class extends PublicKey {
	/**
	* Create a new Ed25519PublicKey object
	* @param value ed25519 public key as buffer or base-64 encoded string
	*/
	constructor(value) {
		super();
		if (typeof value === "string") this.data = fromBase64(value);
		else if (value instanceof Uint8Array) this.data = value;
		else this.data = Uint8Array.from(value);
		if (this.data.length !== PUBLIC_KEY_SIZE) throw new Error(`Invalid public key input. Expected ${PUBLIC_KEY_SIZE} bytes, got ${this.data.length}`);
	}
	/**
	* Checks if two Ed25519 public keys are equal
	*/
	equals(publicKey) {
		return super.equals(publicKey);
	}
	/**
	* Return the byte array representation of the Ed25519 public key
	*/
	toRawBytes() {
		return this.data;
	}
	/**
	* Return the Sui address associated with this Ed25519 public key
	*/
	flag() {
		return SIGNATURE_SCHEME_TO_FLAG["ED25519"];
	}
	/**
	* Verifies that the signature is valid for for the provided message
	*/
	async verify(message, signature) {
		let bytes;
		if (typeof signature === "string") {
			const parsed = parseSerializedKeypairSignature(signature);
			if (parsed.signatureScheme !== "ED25519") throw new Error("Invalid signature scheme");
			if (!bytesEqual(this.toRawBytes(), parsed.publicKey)) throw new Error("Signature does not match public key");
			bytes = parsed.signature;
		} else bytes = signature;
		return ed25519.verify(bytes, message, this.toRawBytes());
	}
};
Ed25519PublicKey.SIZE = PUBLIC_KEY_SIZE;

//#endregion
//#region node_modules/.pnpm/@mysten+sui@1.45.2_typescript@5.9.3/node_modules/@mysten/sui/dist/esm/keypairs/ed25519/keypair.js
var DEFAULT_ED25519_DERIVATION_PATH = "m/44'/784'/0'/0'/0'";
var Ed25519Keypair = class Ed25519Keypair extends Keypair {
	/**
	* Create a new Ed25519 keypair instance.
	* Generate random keypair if no {@link Ed25519Keypair} is provided.
	*
	* @param keypair Ed25519 keypair
	*/
	constructor(keypair) {
		super();
		if (keypair) this.keypair = {
			publicKey: keypair.publicKey,
			secretKey: keypair.secretKey.slice(0, 32)
		};
		else {
			const privateKey = ed25519.utils.randomPrivateKey();
			this.keypair = {
				publicKey: ed25519.getPublicKey(privateKey),
				secretKey: privateKey
			};
		}
	}
	/**
	* Get the key scheme of the keypair ED25519
	*/
	getKeyScheme() {
		return "ED25519";
	}
	/**
	* Generate a new random Ed25519 keypair
	*/
	static generate() {
		const secretKey = ed25519.utils.randomPrivateKey();
		return new Ed25519Keypair({
			publicKey: ed25519.getPublicKey(secretKey),
			secretKey
		});
	}
	/**
	* Create a Ed25519 keypair from a raw secret key byte array, also known as seed.
	* This is NOT the private scalar which is result of hashing and bit clamping of
	* the raw secret key.
	*
	* @throws error if the provided secret key is invalid and validation is not skipped.
	*
	* @param secretKey secret key as a byte array or Bech32 secret key string
	* @param options: skip secret key validation
	*/
	static fromSecretKey(secretKey, options) {
		if (typeof secretKey === "string") {
			const decoded = decodeSuiPrivateKey(secretKey);
			if (decoded.schema !== "ED25519") throw new Error(`Expected a ED25519 keypair, got ${decoded.schema}`);
			return this.fromSecretKey(decoded.secretKey, options);
		}
		const secretKeyLength = secretKey.length;
		if (secretKeyLength !== PRIVATE_KEY_SIZE) throw new Error(`Wrong secretKey size. Expected ${PRIVATE_KEY_SIZE} bytes, got ${secretKeyLength}.`);
		const keypair = {
			publicKey: ed25519.getPublicKey(secretKey),
			secretKey
		};
		if (!options || !options.skipValidation) {
			const signData = new TextEncoder().encode("sui validation");
			const signature = ed25519.sign(signData, secretKey);
			if (!ed25519.verify(signature, signData, keypair.publicKey)) throw new Error("provided secretKey is invalid");
		}
		return new Ed25519Keypair(keypair);
	}
	/**
	* The public key for this Ed25519 keypair
	*/
	getPublicKey() {
		return new Ed25519PublicKey(this.keypair.publicKey);
	}
	/**
	* The Bech32 secret key string for this Ed25519 keypair
	*/
	getSecretKey() {
		return encodeSuiPrivateKey(this.keypair.secretKey.slice(0, PRIVATE_KEY_SIZE), this.getKeyScheme());
	}
	/**
	* Return the signature for the provided data using Ed25519.
	*/
	async sign(data) {
		return ed25519.sign(data, this.keypair.secretKey);
	}
	/**
	* Derive Ed25519 keypair from mnemonics and path. The mnemonics must be normalized
	* and validated against the english wordlist.
	*
	* If path is none, it will default to m/44'/784'/0'/0'/0', otherwise the path must
	* be compliant to SLIP-0010 in form m/44'/784'/{account_index}'/{change_index}'/{address_index}'.
	*/
	static deriveKeypair(mnemonics, path) {
		if (path == null) path = DEFAULT_ED25519_DERIVATION_PATH;
		if (!isValidHardenedPath(path)) throw new Error("Invalid derivation path");
		const { key } = derivePath(path, mnemonicToSeedHex(mnemonics));
		return Ed25519Keypair.fromSecretKey(key);
	}
	/**
	* Derive Ed25519 keypair from mnemonicSeed and path.
	*
	* If path is none, it will default to m/44'/784'/0'/0'/0', otherwise the path must
	* be compliant to SLIP-0010 in form m/44'/784'/{account_index}'/{change_index}'/{address_index}'.
	*/
	static deriveKeypairFromSeed(seedHex, path) {
		if (path == null) path = DEFAULT_ED25519_DERIVATION_PATH;
		if (!isValidHardenedPath(path)) throw new Error("Invalid derivation path");
		const { key } = derivePath(path, seedHex);
		return Ed25519Keypair.fromSecretKey(key);
	}
};

//#endregion
//#region node_modules/.pnpm/zustand@4.5.7_@types+react@19.2.7_react@19.2.3/node_modules/zustand/esm/middleware.mjs
function createJSONStorage(getStorage, options) {
	let storage;
	try {
		storage = getStorage();
	} catch (_e) {
		return;
	}
	return {
		getItem: (name) => {
			var _a;
			const parse$2 = (str2) => {
				if (str2 === null) return null;
				return JSON.parse(str2, options == null ? void 0 : options.reviver);
			};
			const str = (_a = storage.getItem(name)) != null ? _a : null;
			if (str instanceof Promise) return str.then(parse$2);
			return parse$2(str);
		},
		setItem: (name, newValue) => storage.setItem(name, JSON.stringify(newValue, options == null ? void 0 : options.replacer)),
		removeItem: (name) => storage.removeItem(name)
	};
}
var toThenable = (fn) => (input) => {
	try {
		const result = fn(input);
		if (result instanceof Promise) return result;
		return {
			then(onFulfilled) {
				return toThenable(onFulfilled)(result);
			},
			catch(_onRejected) {
				return this;
			}
		};
	} catch (e) {
		return {
			then(_onFulfilled) {
				return this;
			},
			catch(onRejected) {
				return toThenable(onRejected)(e);
			}
		};
	}
};
var oldImpl = (config, baseOptions) => (set, get$2, api) => {
	let options = {
		getStorage: () => localStorage,
		serialize: JSON.stringify,
		deserialize: JSON.parse,
		partialize: (state) => state,
		version: 0,
		merge: (persistedState, currentState) => ({
			...currentState,
			...persistedState
		}),
		...baseOptions
	};
	let hasHydrated = false;
	const hydrationListeners = /* @__PURE__ */ new Set();
	const finishHydrationListeners = /* @__PURE__ */ new Set();
	let storage;
	try {
		storage = options.getStorage();
	} catch (_e) {}
	if (!storage) return config((...args) => {
		console.warn(`[zustand persist middleware] Unable to update item '${options.name}', the given storage is currently unavailable.`);
		set(...args);
	}, get$2, api);
	const thenableSerialize = toThenable(options.serialize);
	const setItem = () => {
		const state = options.partialize({ ...get$2() });
		let errorInSync;
		const thenable = thenableSerialize({
			state,
			version: options.version
		}).then((serializedValue) => storage.setItem(options.name, serializedValue)).catch((e) => {
			errorInSync = e;
		});
		if (errorInSync) throw errorInSync;
		return thenable;
	};
	const savedSetState = api.setState;
	api.setState = (state, replace) => {
		savedSetState(state, replace);
		setItem();
	};
	const configResult = config((...args) => {
		set(...args);
		setItem();
	}, get$2, api);
	let stateFromStorage;
	const hydrate = () => {
		var _a;
		if (!storage) return;
		hasHydrated = false;
		hydrationListeners.forEach((cb) => cb(get$2()));
		const postRehydrationCallback = ((_a = options.onRehydrateStorage) == null ? void 0 : _a.call(options, get$2())) || void 0;
		return toThenable(storage.getItem.bind(storage))(options.name).then((storageValue) => {
			if (storageValue) return options.deserialize(storageValue);
		}).then((deserializedStorageValue) => {
			if (deserializedStorageValue) if (typeof deserializedStorageValue.version === "number" && deserializedStorageValue.version !== options.version) {
				if (options.migrate) return options.migrate(deserializedStorageValue.state, deserializedStorageValue.version);
				console.error(`State loaded from storage couldn't be migrated since no migrate function was provided`);
			} else return deserializedStorageValue.state;
		}).then((migratedState) => {
			var _a2;
			stateFromStorage = options.merge(migratedState, (_a2 = get$2()) != null ? _a2 : configResult);
			set(stateFromStorage, true);
			return setItem();
		}).then(() => {
			postRehydrationCallback?.(stateFromStorage, void 0);
			hasHydrated = true;
			finishHydrationListeners.forEach((cb) => cb(stateFromStorage));
		}).catch((e) => {
			postRehydrationCallback?.(void 0, e);
		});
	};
	api.persist = {
		setOptions: (newOptions) => {
			options = {
				...options,
				...newOptions
			};
			if (newOptions.getStorage) storage = newOptions.getStorage();
		},
		clearStorage: () => {
			storage?.removeItem(options.name);
		},
		getOptions: () => options,
		rehydrate: () => hydrate(),
		hasHydrated: () => hasHydrated,
		onHydrate: (cb) => {
			hydrationListeners.add(cb);
			return () => {
				hydrationListeners.delete(cb);
			};
		},
		onFinishHydration: (cb) => {
			finishHydrationListeners.add(cb);
			return () => {
				finishHydrationListeners.delete(cb);
			};
		}
	};
	hydrate();
	return stateFromStorage || configResult;
};
var newImpl = (config, baseOptions) => (set, get$2, api) => {
	let options = {
		storage: createJSONStorage(() => localStorage),
		partialize: (state) => state,
		version: 0,
		merge: (persistedState, currentState) => ({
			...currentState,
			...persistedState
		}),
		...baseOptions
	};
	let hasHydrated = false;
	const hydrationListeners = /* @__PURE__ */ new Set();
	const finishHydrationListeners = /* @__PURE__ */ new Set();
	let storage = options.storage;
	if (!storage) return config((...args) => {
		console.warn(`[zustand persist middleware] Unable to update item '${options.name}', the given storage is currently unavailable.`);
		set(...args);
	}, get$2, api);
	const setItem = () => {
		const state = options.partialize({ ...get$2() });
		return storage.setItem(options.name, {
			state,
			version: options.version
		});
	};
	const savedSetState = api.setState;
	api.setState = (state, replace) => {
		savedSetState(state, replace);
		setItem();
	};
	const configResult = config((...args) => {
		set(...args);
		setItem();
	}, get$2, api);
	api.getInitialState = () => configResult;
	let stateFromStorage;
	const hydrate = () => {
		var _a, _b;
		if (!storage) return;
		hasHydrated = false;
		hydrationListeners.forEach((cb) => {
			var _a2;
			return cb((_a2 = get$2()) != null ? _a2 : configResult);
		});
		const postRehydrationCallback = ((_b = options.onRehydrateStorage) == null ? void 0 : _b.call(options, (_a = get$2()) != null ? _a : configResult)) || void 0;
		return toThenable(storage.getItem.bind(storage))(options.name).then((deserializedStorageValue) => {
			if (deserializedStorageValue) if (typeof deserializedStorageValue.version === "number" && deserializedStorageValue.version !== options.version) {
				if (options.migrate) return [true, options.migrate(deserializedStorageValue.state, deserializedStorageValue.version)];
				console.error(`State loaded from storage couldn't be migrated since no migrate function was provided`);
			} else return [false, deserializedStorageValue.state];
			return [false, void 0];
		}).then((migrationResult) => {
			var _a2;
			const [migrated, migratedState] = migrationResult;
			stateFromStorage = options.merge(migratedState, (_a2 = get$2()) != null ? _a2 : configResult);
			set(stateFromStorage, true);
			if (migrated) return setItem();
		}).then(() => {
			postRehydrationCallback?.(stateFromStorage, void 0);
			stateFromStorage = get$2();
			hasHydrated = true;
			finishHydrationListeners.forEach((cb) => cb(stateFromStorage));
		}).catch((e) => {
			postRehydrationCallback?.(void 0, e);
		});
	};
	api.persist = {
		setOptions: (newOptions) => {
			options = {
				...options,
				...newOptions
			};
			if (newOptions.storage) storage = newOptions.storage;
		},
		clearStorage: () => {
			storage?.removeItem(options.name);
		},
		getOptions: () => options,
		rehydrate: () => hydrate(),
		hasHydrated: () => hasHydrated,
		onHydrate: (cb) => {
			hydrationListeners.add(cb);
			return () => {
				hydrationListeners.delete(cb);
			};
		},
		onFinishHydration: (cb) => {
			finishHydrationListeners.add(cb);
			return () => {
				finishHydrationListeners.delete(cb);
			};
		}
	};
	if (!options.skipHydration) hydrate();
	return stateFromStorage || configResult;
};
var persistImpl = (config, baseOptions) => {
	if ("getStorage" in baseOptions || "serialize" in baseOptions || "deserialize" in baseOptions) {
		if ((import.meta.env ? import.meta.env.MODE : void 0) !== "production") console.warn("[DEPRECATED] `getStorage`, `serialize` and `deserialize` options are deprecated. Use `storage` option instead.");
		return oldImpl(config, baseOptions);
	}
	return newImpl(config, baseOptions);
};
var persist = persistImpl;

//#endregion
//#region node_modules/.pnpm/@vanilla-extract+private@1.0.9/node_modules/@vanilla-extract/private/dist/vanilla-extract-private.esm.js
function getVarName(variable) {
	var matches = variable.match(/^var\((.*)\)$/);
	if (matches) return matches[1];
	return variable;
}
function get(obj, path) {
	var result = obj;
	for (var key of path) {
		if (!(key in result)) throw new Error("Path ".concat(path.join(" -> "), " does not exist in object"));
		result = result[key];
	}
	return result;
}
function walkObject(obj, fn) {
	var path = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
	var clone = {};
	for (var key in obj) {
		var _value = obj[key];
		var currentPath = [...path, key];
		if (typeof _value === "string" || typeof _value === "number" || _value == null) clone[key] = fn(_value, currentPath);
		else if (typeof _value === "object" && !Array.isArray(_value)) clone[key] = walkObject(_value, fn, currentPath);
		else console.warn("Skipping invalid key \"".concat(currentPath.join("."), "\". Should be a string, number, null or object. Received: \"").concat(Array.isArray(_value) ? "Array" : typeof _value, "\""));
	}
	return clone;
}

//#endregion
//#region node_modules/.pnpm/@vanilla-extract+dynamic@2.1.5/node_modules/@vanilla-extract/dynamic/dist/vanilla-extract-dynamic.esm.js
function assignInlineVars(varsOrContract, tokens) {
	var styles = {};
	if (typeof tokens === "object") {
		var _contract = varsOrContract;
		walkObject(tokens, (value$1, path) => {
			if (value$1 == null) return;
			var varName$1 = get(_contract, path);
			styles[getVarName(varName$1)] = String(value$1);
		});
	} else {
		var _vars = varsOrContract;
		for (var varName in _vars) {
			var value = _vars[varName];
			if (value == null) continue;
			styles[getVarName(varName)] = value;
		}
	}
	Object.defineProperty(styles, "toString", {
		value: function value$1() {
			return Object.keys(this).map((key) => "".concat(key, ":").concat(this[key])).join(";");
		},
		writable: false
	});
	return styles;
}

//#endregion
//#region node_modules/.pnpm/@vanilla-extract+css@1.18.0/node_modules/@vanilla-extract/css/injectStyles/dist/vanilla-extract-css-injectStyles.browser.esm.js
var stylesheets = {};
var injectStyles = (_ref) => {
	var { fileScope, css } = _ref;
	var fileScopeId = fileScope.packageName ? [fileScope.packageName, fileScope.filePath].join("/") : fileScope.filePath;
	var stylesheet = stylesheets[fileScopeId];
	if (!stylesheet) {
		var styleEl = document.createElement("style");
		if (fileScope.packageName) styleEl.setAttribute("data-package", fileScope.packageName);
		styleEl.setAttribute("data-file", fileScope.filePath);
		styleEl.setAttribute("type", "text/css");
		stylesheet = stylesheets[fileScopeId] = styleEl;
		document.head.appendChild(styleEl);
	}
	stylesheet.innerHTML = css;
};

//#endregion
//#region node_modules/.pnpm/cssesc@3.0.0/node_modules/cssesc/cssesc.js
var require_cssesc = /* @__PURE__ */ __commonJS$1({ "node_modules/.pnpm/cssesc@3.0.0/node_modules/cssesc/cssesc.js": ((exports, module) => {
	var hasOwnProperty = {}.hasOwnProperty;
	var merge = function merge$1(options, defaults) {
		if (!options) return defaults;
		var result = {};
		for (var key in defaults) result[key] = hasOwnProperty.call(options, key) ? options[key] : defaults[key];
		return result;
	};
	var regexAnySingleEscape = /[ -,\.\/:-@\[-\^`\{-~]/;
	var regexSingleEscape = /[ -,\.\/:-@\[\]\^`\{-~]/;
	var regexExcessiveSpaces = /(^|\\+)?(\\[A-F0-9]{1,6})\x20(?![a-fA-F0-9\x20])/g;
	var cssesc$2 = function cssesc$3(string$1, options) {
		options = merge(options, cssesc$3.options);
		if (options.quotes != "single" && options.quotes != "double") options.quotes = "single";
		var quote = options.quotes == "double" ? "\"" : "'";
		var isIdentifier = options.isIdentifier;
		var firstChar = string$1.charAt(0);
		var output = "";
		var counter = 0;
		var length = string$1.length;
		while (counter < length) {
			var character = string$1.charAt(counter++);
			var codePoint = character.charCodeAt();
			var value = void 0;
			if (codePoint < 32 || codePoint > 126) {
				if (codePoint >= 55296 && codePoint <= 56319 && counter < length) {
					var extra = string$1.charCodeAt(counter++);
					if ((extra & 64512) == 56320) codePoint = ((codePoint & 1023) << 10) + (extra & 1023) + 65536;
					else counter--;
				}
				value = "\\" + codePoint.toString(16).toUpperCase() + " ";
			} else if (options.escapeEverything) if (regexAnySingleEscape.test(character)) value = "\\" + character;
			else value = "\\" + codePoint.toString(16).toUpperCase() + " ";
			else if (/[\t\n\f\r\x0B]/.test(character)) value = "\\" + codePoint.toString(16).toUpperCase() + " ";
			else if (character == "\\" || !isIdentifier && (character == "\"" && quote == character || character == "'" && quote == character) || isIdentifier && regexSingleEscape.test(character)) value = "\\" + character;
			else value = character;
			output += value;
		}
		if (isIdentifier) {
			if (/^-[-\d]/.test(output)) output = "\\-" + output.slice(1);
			else if (/\d/.test(firstChar)) output = "\\3" + firstChar + " " + output.slice(1);
		}
		output = output.replace(regexExcessiveSpaces, function($0, $1, $2) {
			if ($1 && $1.length % 2) return $0;
			return ($1 || "") + $2;
		});
		if (!isIdentifier && options.wrap) return quote + output + quote;
		return output;
	};
	cssesc$2.options = {
		"escapeEverything": false,
		"isIdentifier": false,
		"quotes": "single",
		"wrap": false
	};
	cssesc$2.version = "3.0.0";
	module.exports = cssesc$2;
}) });

//#endregion
//#region node_modules/.pnpm/modern-ahocorasick@1.1.0/node_modules/modern-ahocorasick/dist/index.js
var import_cssesc$1 = /* @__PURE__ */ __toESM$1(require_cssesc());
var AhoCorasick = class {
	constructor(keywords) {
		const { failure, gotoFn, output } = this._buildTables(keywords);
		this.gotoFn = gotoFn;
		this.output = output;
		this.failure = failure;
	}
	_buildTables(keywords) {
		const gotoFn = { 0: {} };
		const output = {};
		let state = 0;
		for (const word of keywords) {
			let curr = 0;
			for (const l of word) if (gotoFn[curr] && l in gotoFn[curr]) curr = gotoFn[curr][l];
			else {
				state++;
				gotoFn[curr][l] = state;
				gotoFn[state] = {};
				curr = state;
				output[state] = [];
			}
			output[curr].push(word);
		}
		const failure = {};
		const xs = [];
		for (const l in gotoFn[0]) {
			const state2 = gotoFn[0][l];
			failure[state2] = 0;
			xs.push(state2);
		}
		while (xs.length > 0) {
			const r$1 = xs.shift();
			if (r$1 !== void 0) for (const l in gotoFn[r$1]) {
				const s = gotoFn[r$1][l];
				xs.push(s);
				let state2 = failure[r$1];
				while (state2 > 0 && !(l in gotoFn[state2])) state2 = failure[state2];
				if (l in gotoFn[state2]) {
					const fs = gotoFn[state2][l];
					failure[s] = fs;
					output[s] = [...output[s], ...output[fs]];
				} else failure[s] = 0;
			}
		}
		return {
			gotoFn,
			output,
			failure
		};
	}
	search(str) {
		let state = 0;
		const results = [];
		for (let i = 0; i < str.length; i++) {
			const l = str[i];
			while (state > 0 && !(l in this.gotoFn[state])) state = this.failure[state];
			if (!(l in this.gotoFn[state])) continue;
			state = this.gotoFn[state][l];
			if (this.output[state].length > 0) {
				const foundStrs = this.output[state];
				results.push([i, foundStrs]);
			}
		}
		return results;
	}
	match(str) {
		let state = 0;
		for (let i = 0; i < str.length; i++) {
			const l = str[i];
			while (state > 0 && !(l in this.gotoFn[state])) state = this.failure[state];
			if (!(l in this.gotoFn[state])) continue;
			state = this.gotoFn[state][l];
			if (this.output[state].length > 0) return true;
		}
		return false;
	}
};

//#endregion
//#region node_modules/.pnpm/@vanilla-extract+css@1.18.0/node_modules/@vanilla-extract/css/adapter/dist/vanilla-extract-css-adapter.browser.esm.js
var mockAdapter = {
	appendCss: () => {},
	registerClassName: () => {},
	onEndFileScope: () => {},
	registerComposition: () => {},
	markCompositionUsed: () => {},
	getIdentOption: () => "debug"
};
var adapterStack = [mockAdapter];
var currentAdapter = () => {
	if (adapterStack.length < 1) throw new Error("No adapter configured");
	return adapterStack[adapterStack.length - 1];
};
var hasConfiguredAdapter = false;
var setAdapterIfNotSet = (newAdapter) => {
	if (!hasConfiguredAdapter) setAdapter(newAdapter);
};
var setAdapter = (newAdapter) => {
	if (!newAdapter) throw new Error("No adapter provided when calling \"setAdapter\"");
	hasConfiguredAdapter = true;
	adapterStack.push(newAdapter);
};
var markCompositionUsed = function markCompositionUsed$1() {
	return currentAdapter().markCompositionUsed(...arguments);
};

//#endregion
//#region node_modules/.pnpm/@vanilla-extract+css@1.18.0/node_modules/@vanilla-extract/css/dist/taggedTemplateLiteral-8e47dbd7.browser.esm.js
function _taggedTemplateLiteral(strings, raw) {
	if (!raw) raw = strings.slice(0);
	return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } }));
}

//#endregion
//#region node_modules/.pnpm/css-what@6.2.2/node_modules/css-what/lib/es/types.js
var SelectorType;
(function(SelectorType$1) {
	SelectorType$1["Attribute"] = "attribute";
	SelectorType$1["Pseudo"] = "pseudo";
	SelectorType$1["PseudoElement"] = "pseudo-element";
	SelectorType$1["Tag"] = "tag";
	SelectorType$1["Universal"] = "universal";
	SelectorType$1["Adjacent"] = "adjacent";
	SelectorType$1["Child"] = "child";
	SelectorType$1["Descendant"] = "descendant";
	SelectorType$1["Parent"] = "parent";
	SelectorType$1["Sibling"] = "sibling";
	SelectorType$1["ColumnCombinator"] = "column-combinator";
})(SelectorType || (SelectorType = {}));
var AttributeAction;
(function(AttributeAction$1) {
	AttributeAction$1["Any"] = "any";
	AttributeAction$1["Element"] = "element";
	AttributeAction$1["End"] = "end";
	AttributeAction$1["Equals"] = "equals";
	AttributeAction$1["Exists"] = "exists";
	AttributeAction$1["Hyphen"] = "hyphen";
	AttributeAction$1["Not"] = "not";
	AttributeAction$1["Start"] = "start";
})(AttributeAction || (AttributeAction = {}));

//#endregion
//#region node_modules/.pnpm/css-what@6.2.2/node_modules/css-what/lib/es/parse.js
var reName = /^[^\\#]?(?:\\(?:[\da-f]{1,6}\s?|.)|[\w\-\u00b0-\uFFFF])+/;
var reEscape = /\\([\da-f]{1,6}\s?|(\s)|.)/gi;
var actionTypes = new Map([
	[126, AttributeAction.Element],
	[94, AttributeAction.Start],
	[36, AttributeAction.End],
	[42, AttributeAction.Any],
	[33, AttributeAction.Not],
	[124, AttributeAction.Hyphen]
]);
var unpackPseudos = new Set([
	"has",
	"not",
	"matches",
	"is",
	"where",
	"host",
	"host-context"
]);
/**
* Checks whether a specific selector is a traversal.
* This is useful eg. in swapping the order of elements that
* are not traversals.
*
* @param selector Selector to check.
*/
function isTraversal(selector) {
	switch (selector.type) {
		case SelectorType.Adjacent:
		case SelectorType.Child:
		case SelectorType.Descendant:
		case SelectorType.Parent:
		case SelectorType.Sibling:
		case SelectorType.ColumnCombinator: return true;
		default: return false;
	}
}
var stripQuotesFromPseudos = new Set(["contains", "icontains"]);
function funescape(_, escaped, escapedWhitespace) {
	const high = parseInt(escaped, 16) - 65536;
	return high !== high || escapedWhitespace ? escaped : high < 0 ? String.fromCharCode(high + 65536) : String.fromCharCode(high >> 10 | 55296, high & 1023 | 56320);
}
function unescapeCSS(str) {
	return str.replace(reEscape, funescape);
}
function isQuote(c) {
	return c === 39 || c === 34;
}
function isWhitespace(c) {
	return c === 32 || c === 9 || c === 10 || c === 12 || c === 13;
}
/**
* Parses `selector`, optionally with the passed `options`.
*
* @param selector Selector to parse.
* @param options Options for parsing.
* @returns Returns a two-dimensional array.
* The first dimension represents selectors separated by commas (eg. `sub1, sub2`),
* the second contains the relevant tokens for that selector.
*/
function parse(selector) {
	const subselects = [];
	const endIndex = parseSelector(subselects, `${selector}`, 0);
	if (endIndex < selector.length) throw new Error(`Unmatched selector: ${selector.slice(endIndex)}`);
	return subselects;
}
function parseSelector(subselects, selector, selectorIndex) {
	let tokens = [];
	function getName(offset) {
		const match = selector.slice(selectorIndex + offset).match(reName);
		if (!match) throw new Error(`Expected name, found ${selector.slice(selectorIndex)}`);
		const [name] = match;
		selectorIndex += offset + name.length;
		return unescapeCSS(name);
	}
	function stripWhitespace(offset) {
		selectorIndex += offset;
		while (selectorIndex < selector.length && isWhitespace(selector.charCodeAt(selectorIndex))) selectorIndex++;
	}
	function readValueWithParenthesis() {
		selectorIndex += 1;
		const start = selectorIndex;
		let counter = 1;
		for (; counter > 0 && selectorIndex < selector.length; selectorIndex++) if (selector.charCodeAt(selectorIndex) === 40 && !isEscaped(selectorIndex)) counter++;
		else if (selector.charCodeAt(selectorIndex) === 41 && !isEscaped(selectorIndex)) counter--;
		if (counter) throw new Error("Parenthesis not matched");
		return unescapeCSS(selector.slice(start, selectorIndex - 1));
	}
	function isEscaped(pos) {
		let slashCount = 0;
		while (selector.charCodeAt(--pos) === 92) slashCount++;
		return (slashCount & 1) === 1;
	}
	function ensureNotTraversal() {
		if (tokens.length > 0 && isTraversal(tokens[tokens.length - 1])) throw new Error("Did not expect successive traversals.");
	}
	function addTraversal(type) {
		if (tokens.length > 0 && tokens[tokens.length - 1].type === SelectorType.Descendant) {
			tokens[tokens.length - 1].type = type;
			return;
		}
		ensureNotTraversal();
		tokens.push({ type });
	}
	function addSpecialAttribute(name, action) {
		tokens.push({
			type: SelectorType.Attribute,
			name,
			action,
			value: getName(1),
			namespace: null,
			ignoreCase: "quirks"
		});
	}
	/**
	* We have finished parsing the current part of the selector.
	*
	* Remove descendant tokens at the end if they exist,
	* and return the last index, so that parsing can be
	* picked up from here.
	*/
	function finalizeSubselector() {
		if (tokens.length && tokens[tokens.length - 1].type === SelectorType.Descendant) tokens.pop();
		if (tokens.length === 0) throw new Error("Empty sub-selector");
		subselects.push(tokens);
	}
	stripWhitespace(0);
	if (selector.length === selectorIndex) return selectorIndex;
	loop: while (selectorIndex < selector.length) {
		const firstChar = selector.charCodeAt(selectorIndex);
		switch (firstChar) {
			case 32:
			case 9:
			case 10:
			case 12:
			case 13:
				if (tokens.length === 0 || tokens[0].type !== SelectorType.Descendant) {
					ensureNotTraversal();
					tokens.push({ type: SelectorType.Descendant });
				}
				stripWhitespace(1);
				break;
			case 62:
				addTraversal(SelectorType.Child);
				stripWhitespace(1);
				break;
			case 60:
				addTraversal(SelectorType.Parent);
				stripWhitespace(1);
				break;
			case 126:
				addTraversal(SelectorType.Sibling);
				stripWhitespace(1);
				break;
			case 43:
				addTraversal(SelectorType.Adjacent);
				stripWhitespace(1);
				break;
			case 46:
				addSpecialAttribute("class", AttributeAction.Element);
				break;
			case 35:
				addSpecialAttribute("id", AttributeAction.Equals);
				break;
			case 91: {
				stripWhitespace(1);
				let name;
				let namespace = null;
				if (selector.charCodeAt(selectorIndex) === 124) name = getName(1);
				else if (selector.startsWith("*|", selectorIndex)) {
					namespace = "*";
					name = getName(2);
				} else {
					name = getName(0);
					if (selector.charCodeAt(selectorIndex) === 124 && selector.charCodeAt(selectorIndex + 1) !== 61) {
						namespace = name;
						name = getName(1);
					}
				}
				stripWhitespace(0);
				let action = AttributeAction.Exists;
				const possibleAction = actionTypes.get(selector.charCodeAt(selectorIndex));
				if (possibleAction) {
					action = possibleAction;
					if (selector.charCodeAt(selectorIndex + 1) !== 61) throw new Error("Expected `=`");
					stripWhitespace(2);
				} else if (selector.charCodeAt(selectorIndex) === 61) {
					action = AttributeAction.Equals;
					stripWhitespace(1);
				}
				let value = "";
				let ignoreCase = null;
				if (action !== "exists") {
					if (isQuote(selector.charCodeAt(selectorIndex))) {
						const quote = selector.charCodeAt(selectorIndex);
						let sectionEnd = selectorIndex + 1;
						while (sectionEnd < selector.length && (selector.charCodeAt(sectionEnd) !== quote || isEscaped(sectionEnd))) sectionEnd += 1;
						if (selector.charCodeAt(sectionEnd) !== quote) throw new Error("Attribute value didn't end");
						value = unescapeCSS(selector.slice(selectorIndex + 1, sectionEnd));
						selectorIndex = sectionEnd + 1;
					} else {
						const valueStart = selectorIndex;
						while (selectorIndex < selector.length && (!isWhitespace(selector.charCodeAt(selectorIndex)) && selector.charCodeAt(selectorIndex) !== 93 || isEscaped(selectorIndex))) selectorIndex += 1;
						value = unescapeCSS(selector.slice(valueStart, selectorIndex));
					}
					stripWhitespace(0);
					const forceIgnore = selector.charCodeAt(selectorIndex) | 32;
					if (forceIgnore === 115) {
						ignoreCase = false;
						stripWhitespace(1);
					} else if (forceIgnore === 105) {
						ignoreCase = true;
						stripWhitespace(1);
					}
				}
				if (selector.charCodeAt(selectorIndex) !== 93) throw new Error("Attribute selector didn't terminate");
				selectorIndex += 1;
				const attributeSelector = {
					type: SelectorType.Attribute,
					name,
					action,
					value,
					namespace,
					ignoreCase
				};
				tokens.push(attributeSelector);
				break;
			}
			case 58: {
				if (selector.charCodeAt(selectorIndex + 1) === 58) {
					tokens.push({
						type: SelectorType.PseudoElement,
						name: getName(2).toLowerCase(),
						data: selector.charCodeAt(selectorIndex) === 40 ? readValueWithParenthesis() : null
					});
					continue;
				}
				const name = getName(1).toLowerCase();
				let data = null;
				if (selector.charCodeAt(selectorIndex) === 40) if (unpackPseudos.has(name)) {
					if (isQuote(selector.charCodeAt(selectorIndex + 1))) throw new Error(`Pseudo-selector ${name} cannot be quoted`);
					data = [];
					selectorIndex = parseSelector(data, selector, selectorIndex + 1);
					if (selector.charCodeAt(selectorIndex) !== 41) throw new Error(`Missing closing parenthesis in :${name} (${selector})`);
					selectorIndex += 1;
				} else {
					data = readValueWithParenthesis();
					if (stripQuotesFromPseudos.has(name)) {
						const quot = data.charCodeAt(0);
						if (quot === data.charCodeAt(data.length - 1) && isQuote(quot)) data = data.slice(1, -1);
					}
					data = unescapeCSS(data);
				}
				tokens.push({
					type: SelectorType.Pseudo,
					name,
					data
				});
				break;
			}
			case 44:
				finalizeSubselector();
				tokens = [];
				stripWhitespace(1);
				break;
			default: {
				if (selector.startsWith("/*", selectorIndex)) {
					const endIndex = selector.indexOf("*/", selectorIndex + 2);
					if (endIndex < 0) throw new Error("Comment was not terminated");
					selectorIndex = endIndex + 2;
					if (tokens.length === 0) stripWhitespace(0);
					break;
				}
				let namespace = null;
				let name;
				if (firstChar === 42) {
					selectorIndex += 1;
					name = "*";
				} else if (firstChar === 124) {
					name = "";
					if (selector.charCodeAt(selectorIndex + 1) === 124) {
						addTraversal(SelectorType.ColumnCombinator);
						stripWhitespace(2);
						break;
					}
				} else if (reName.test(selector.slice(selectorIndex))) name = getName(0);
				else break loop;
				if (selector.charCodeAt(selectorIndex) === 124 && selector.charCodeAt(selectorIndex + 1) !== 124) {
					namespace = name;
					if (selector.charCodeAt(selectorIndex + 1) === 42) {
						name = "*";
						selectorIndex += 2;
					} else name = getName(1);
				}
				tokens.push(name === "*" ? {
					type: SelectorType.Universal,
					namespace
				} : {
					type: SelectorType.Tag,
					name,
					namespace
				});
			}
		}
	}
	finalizeSubselector();
	return selectorIndex;
}

//#endregion
//#region node_modules/.pnpm/dedent@1.7.1/node_modules/dedent/dist/dedent.mjs
function ownKeys$1(object$1, enumerableOnly) {
	var keys = Object.keys(object$1);
	if (Object.getOwnPropertySymbols) {
		var symbols = Object.getOwnPropertySymbols(object$1);
		enumerableOnly && (symbols = symbols.filter(function(sym) {
			return Object.getOwnPropertyDescriptor(object$1, sym).enumerable;
		})), keys.push.apply(keys, symbols);
	}
	return keys;
}
function _objectSpread(target) {
	for (var i = 1; i < arguments.length; i++) {
		var source = null != arguments[i] ? arguments[i] : {};
		i % 2 ? ownKeys$1(Object(source), !0).forEach(function(key) {
			_defineProperty$1(target, key, source[key]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1(Object(source)).forEach(function(key) {
			Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
		});
	}
	return target;
}
function _defineProperty$1(obj, key, value) {
	key = _toPropertyKey(key);
	if (key in obj) Object.defineProperty(obj, key, {
		value,
		enumerable: true,
		configurable: true,
		writable: true
	});
	else obj[key] = value;
	return obj;
}
function _toPropertyKey(arg) {
	var key = _toPrimitive(arg, "string");
	return typeof key === "symbol" ? key : String(key);
}
function _toPrimitive(input, hint) {
	if (typeof input !== "object" || input === null) return input;
	var prim = input[Symbol.toPrimitive];
	if (prim !== void 0) {
		var res = prim.call(input, hint || "default");
		if (typeof res !== "object") return res;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return (hint === "string" ? String : Number)(input);
}
var dedent = createDedent({});
var dedent_default = dedent;
function createDedent(options) {
	dedent$1.withOptions = (newOptions) => createDedent(_objectSpread(_objectSpread({}, options), newOptions));
	return dedent$1;
	function dedent$1(strings, ...values) {
		const raw = typeof strings === "string" ? [strings] : strings.raw;
		const { alignValues = false, escapeSpecialCharacters = Array.isArray(strings), trimWhitespace = true } = options;
		let result = "";
		for (let i = 0; i < raw.length; i++) {
			let next = raw[i];
			if (escapeSpecialCharacters) next = next.replace(/\\\n[ \t]*/g, "").replace(/\\`/g, "`").replace(/\\\$/g, "$").replace(/\\\{/g, "{");
			result += next;
			if (i < values.length) {
				const value = alignValues ? alignValue(values[i], result) : values[i];
				result += value;
			}
		}
		const lines = result.split("\n");
		let mindent = null;
		for (const l of lines) {
			const m = l.match(/^(\s+)\S+/);
			if (m) {
				const indent = m[1].length;
				if (!mindent) mindent = indent;
				else mindent = Math.min(mindent, indent);
			}
		}
		if (mindent !== null) {
			const m = mindent;
			result = lines.map((l) => l[0] === " " || l[0] === "	" ? l.slice(m) : l).join("\n");
		}
		if (trimWhitespace) result = result.trim();
		if (escapeSpecialCharacters) result = result.replace(/\\n/g, "\n");
		if (typeof Bun !== "undefined") result = result.replace(/\\u(?:\{([\da-fA-F]{1,6})\}|([\da-fA-F]{4}))/g, (_, braced, unbraced) => {
			var _ref;
			const hex = (_ref = braced !== null && braced !== void 0 ? braced : unbraced) !== null && _ref !== void 0 ? _ref : "";
			return String.fromCodePoint(parseInt(hex, 16));
		});
		return result;
	}
}
/**
* Adjusts the indentation of a multi-line interpolated value to match the current line.
*/
function alignValue(value, precedingText) {
	if (typeof value !== "string" || !value.includes("\n")) return value;
	const indentMatch = precedingText.slice(precedingText.lastIndexOf("\n") + 1).match(/^(\s+)/);
	if (indentMatch) {
		const indent = indentMatch[1];
		return value.replace(/\n/g, `\n${indent}`);
	}
	return value;
}

//#endregion
//#region node_modules/.pnpm/media-query-parser@2.0.2/node_modules/media-query-parser/dist/media-query-parser.esm.js
var __assign = function() {
	__assign = Object.assign || function __assign$1(t) {
		for (var s, i = 1, n = arguments.length; i < n; i++) {
			s = arguments[i];
			for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
		}
		return t;
	};
	return __assign.apply(this, arguments);
};
function __rest(s, e) {
	var t = {};
	for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
	if (s != null && typeof Object.getOwnPropertySymbols === "function") {
		for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
	}
	return t;
}
function __values(o) {
	var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
	if (m) return m.call(o);
	if (o && typeof o.length === "number") return { next: function() {
		if (o && i >= o.length) o = void 0;
		return {
			value: o && o[i++],
			done: !o
		};
	} };
	throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o, n) {
	var m = typeof Symbol === "function" && o[Symbol.iterator];
	if (!m) return o;
	var i = m.call(o), r$1, ar = [], e;
	try {
		while ((n === void 0 || n-- > 0) && !(r$1 = i.next()).done) ar.push(r$1.value);
	} catch (error) {
		e = { error };
	} finally {
		try {
			if (r$1 && !r$1.done && (m = i["return"])) m.call(i);
		} finally {
			if (e) throw e.error;
		}
	}
	return ar;
}
var weirdNewlines = /(\u000D|\u000C|\u000D\u000A)/g;
var nullOrSurrogates = /[\u0000\uD800-\uDFFF]/g;
var commentRegex = /(\/\*)[\s\S]*?(\*\/)/g;
var lexicalAnalysis = function lexicalAnalysis$1(str, index) {
	if (index === void 0) index = 0;
	str = str.replace(weirdNewlines, "\n").replace(nullOrSurrogates, "ï¿½");
	str = str.replace(commentRegex, "");
	var tokens = [];
	for (; index < str.length; index += 1) {
		var code = str.charCodeAt(index);
		if (code === 9 || code === 32 || code === 10) {
			var code_1 = str.charCodeAt(++index);
			while (code_1 === 9 || code_1 === 32 || code_1 === 10) code_1 = str.charCodeAt(++index);
			index -= 1;
			tokens.push({ type: "<whitespace-token>" });
		} else if (code === 34) {
			var result = consumeString(str, index);
			if (result === null) return null;
			var _a = __read(result, 2), lastIndex = _a[0], value = _a[1];
			tokens.push({
				type: "<string-token>",
				value
			});
			index = lastIndex;
		} else if (code === 35) {
			if (index + 1 < str.length) {
				var nextCode = str.charCodeAt(index + 1);
				if (nextCode === 95 || nextCode >= 65 && nextCode <= 90 || nextCode >= 97 && nextCode <= 122 || nextCode >= 128 || nextCode >= 48 && nextCode <= 57 || nextCode === 92 && index + 2 < str.length && str.charCodeAt(index + 2) !== 10) {
					var flag = wouldStartIdentifier(str, index + 1) ? "id" : "unrestricted";
					var result = consumeIdentUnsafe(str, index + 1);
					if (result !== null) {
						var _b = __read(result, 2), lastIndex = _b[0], value = _b[1];
						tokens.push({
							type: "<hash-token>",
							value: value.toLowerCase(),
							flag
						});
						index = lastIndex;
						continue;
					}
				}
			}
			tokens.push({
				type: "<delim-token>",
				value: code
			});
		} else if (code === 39) {
			var result = consumeString(str, index);
			if (result === null) return null;
			var _c = __read(result, 2), lastIndex = _c[0], value = _c[1];
			tokens.push({
				type: "<string-token>",
				value
			});
			index = lastIndex;
		} else if (code === 40) tokens.push({ type: "<(-token>" });
		else if (code === 41) tokens.push({ type: "<)-token>" });
		else if (code === 43) {
			var plusNumeric = consumeNumeric(str, index);
			if (plusNumeric === null) tokens.push({
				type: "<delim-token>",
				value: code
			});
			else {
				var _d = __read(plusNumeric, 2), lastIndex = _d[0], tokenTuple = _d[1];
				if (tokenTuple[0] === "<dimension-token>") tokens.push({
					type: "<dimension-token>",
					value: tokenTuple[1],
					unit: tokenTuple[2].toLowerCase(),
					flag: "number"
				});
				else if (tokenTuple[0] === "<number-token>") tokens.push({
					type: tokenTuple[0],
					value: tokenTuple[1],
					flag: tokenTuple[2]
				});
				else tokens.push({
					type: tokenTuple[0],
					value: tokenTuple[1],
					flag: "number"
				});
				index = lastIndex;
			}
		} else if (code === 44) tokens.push({ type: "<comma-token>" });
		else if (code === 45) {
			var minusNumeric = consumeNumeric(str, index);
			if (minusNumeric !== null) {
				var _e = __read(minusNumeric, 2), lastIndex = _e[0], tokenTuple = _e[1];
				if (tokenTuple[0] === "<dimension-token>") tokens.push({
					type: "<dimension-token>",
					value: tokenTuple[1],
					unit: tokenTuple[2].toLowerCase(),
					flag: "number"
				});
				else if (tokenTuple[0] === "<number-token>") tokens.push({
					type: tokenTuple[0],
					value: tokenTuple[1],
					flag: tokenTuple[2]
				});
				else tokens.push({
					type: tokenTuple[0],
					value: tokenTuple[1],
					flag: "number"
				});
				index = lastIndex;
				continue;
			}
			if (index + 2 < str.length) {
				var nextCode = str.charCodeAt(index + 1);
				var nextNextCode = str.charCodeAt(index + 2);
				if (nextCode === 45 && nextNextCode === 62) {
					tokens.push({ type: "<CDC-token>" });
					index += 2;
					continue;
				}
			}
			var result = consumeIdentLike(str, index);
			if (result !== null) {
				var _f = __read(result, 3), lastIndex = _f[0], value = _f[1], type = _f[2];
				tokens.push({
					type,
					value
				});
				index = lastIndex;
				continue;
			}
			tokens.push({
				type: "<delim-token>",
				value: code
			});
		} else if (code === 46) {
			var minusNumeric = consumeNumeric(str, index);
			if (minusNumeric === null) tokens.push({
				type: "<delim-token>",
				value: code
			});
			else {
				var _g = __read(minusNumeric, 2), lastIndex = _g[0], tokenTuple = _g[1];
				if (tokenTuple[0] === "<dimension-token>") tokens.push({
					type: "<dimension-token>",
					value: tokenTuple[1],
					unit: tokenTuple[2].toLowerCase(),
					flag: "number"
				});
				else if (tokenTuple[0] === "<number-token>") tokens.push({
					type: tokenTuple[0],
					value: tokenTuple[1],
					flag: tokenTuple[2]
				});
				else tokens.push({
					type: tokenTuple[0],
					value: tokenTuple[1],
					flag: "number"
				});
				index = lastIndex;
				continue;
			}
		} else if (code === 58) tokens.push({ type: "<colon-token>" });
		else if (code === 59) tokens.push({ type: "<semicolon-token>" });
		else if (code === 60) {
			if (index + 3 < str.length) {
				var nextCode = str.charCodeAt(index + 1);
				var nextNextCode = str.charCodeAt(index + 2);
				var nextNextNextCode = str.charCodeAt(index + 3);
				if (nextCode === 33 && nextNextCode === 45 && nextNextNextCode === 45) {
					tokens.push({ type: "<CDO-token>" });
					index += 3;
					continue;
				}
			}
			tokens.push({
				type: "<delim-token>",
				value: code
			});
		} else if (code === 64) {
			var result = consumeIdent(str, index + 1);
			if (result !== null) {
				var _h = __read(result, 2), lastIndex = _h[0], value = _h[1];
				tokens.push({
					type: "<at-keyword-token>",
					value: value.toLowerCase()
				});
				index = lastIndex;
				continue;
			}
			tokens.push({
				type: "<delim-token>",
				value: code
			});
		} else if (code === 91) tokens.push({ type: "<[-token>" });
		else if (code === 92) {
			var result = consumeEscape(str, index);
			if (result === null) return null;
			var _j = __read(result, 2), lastIndex = _j[0], value = _j[1];
			str = str.slice(0, index) + value + str.slice(lastIndex + 1);
			index -= 1;
		} else if (code === 93) tokens.push({ type: "<]-token>" });
		else if (code === 123) tokens.push({ type: "<{-token>" });
		else if (code === 125) tokens.push({ type: "<}-token>" });
		else if (code >= 48 && code <= 57) {
			var result = consumeNumeric(str, index);
			var _k = __read(result, 2), lastIndex = _k[0], tokenTuple = _k[1];
			if (tokenTuple[0] === "<dimension-token>") tokens.push({
				type: "<dimension-token>",
				value: tokenTuple[1],
				unit: tokenTuple[2].toLowerCase(),
				flag: "number"
			});
			else if (tokenTuple[0] === "<number-token>") tokens.push({
				type: tokenTuple[0],
				value: tokenTuple[1],
				flag: tokenTuple[2]
			});
			else tokens.push({
				type: tokenTuple[0],
				value: tokenTuple[1],
				flag: "number"
			});
			index = lastIndex;
		} else if (code === 95 || code >= 65 && code <= 90 || code >= 97 && code <= 122 || code >= 128) {
			var result = consumeIdentLike(str, index);
			if (result === null) return null;
			var _l = __read(result, 3), lastIndex = _l[0], value = _l[1], type = _l[2];
			tokens.push({
				type,
				value
			});
			index = lastIndex;
		} else tokens.push({
			type: "<delim-token>",
			value: code
		});
	}
	tokens.push({ type: "<EOF-token>" });
	return tokens;
};
var consumeString = function consumeString$1(str, index) {
	if (str.length <= index + 1) return null;
	var firstCode = str.charCodeAt(index);
	var charCodes = [];
	for (var i = index + 1; i < str.length; i += 1) {
		var code = str.charCodeAt(i);
		if (code === firstCode) return [i, String.fromCharCode.apply(null, charCodes)];
		else if (code === 92) {
			var result = consumeEscape(str, i);
			if (result === null) return null;
			var _a = __read(result, 2), lastIndex = _a[0], charCode = _a[1];
			charCodes.push(charCode);
			i = lastIndex;
		} else if (code === 10) return null;
		else charCodes.push(code);
	}
	return null;
};
var wouldStartIdentifier = function wouldStartIdentifier$1(str, index) {
	if (str.length <= index) return false;
	var code = str.charCodeAt(index);
	if (code === 45) {
		if (str.length <= index + 1) return false;
		var nextCode = str.charCodeAt(index + 1);
		if (nextCode === 45 || nextCode === 95 || nextCode >= 65 && nextCode <= 90 || nextCode >= 97 && nextCode <= 122 || nextCode >= 128) return true;
		else if (nextCode === 92) {
			if (str.length <= index + 2) return false;
			return str.charCodeAt(index + 2) !== 10;
		} else return false;
	} else if (code === 95 || code >= 65 && code <= 90 || code >= 97 && code <= 122 || code >= 128) return true;
	else if (code === 92) {
		if (str.length <= index + 1) return false;
		var nextCode = str.charCodeAt(index + 1);
		return nextCode !== 10;
	} else return false;
};
var consumeEscape = function consumeEscape$1(str, index) {
	if (str.length <= index + 1) return null;
	if (str.charCodeAt(index) !== 92) return null;
	var code = str.charCodeAt(index + 1);
	if (code === 10) return null;
	else if (code >= 48 && code <= 57 || code >= 65 && code <= 70 || code >= 97 && code <= 102) {
		var hexCharCodes = [code];
		var min = Math.min(index + 7, str.length);
		var i = index + 2;
		for (; i < min; i += 1) {
			var code_2 = str.charCodeAt(i);
			if (code_2 >= 48 && code_2 <= 57 || code_2 >= 65 && code_2 <= 70 || code_2 >= 97 && code_2 <= 102) hexCharCodes.push(code_2);
			else break;
		}
		if (i < str.length) {
			var code_3 = str.charCodeAt(i);
			if (code_3 === 9 || code_3 === 32 || code_3 === 10) i += 1;
		}
		return [i - 1, parseInt(String.fromCharCode.apply(null, hexCharCodes), 16)];
	} else return [index + 1, code];
};
var consumeNumeric = function consumeNumeric$1(str, index) {
	var numberResult = consumeNumber(str, index);
	if (numberResult === null) return null;
	var _a = __read(numberResult, 3), numberEndIndex = _a[0], numberValue = _a[1], numberFlag = _a[2];
	var identResult = consumeIdent(str, numberEndIndex + 1);
	if (identResult !== null) {
		var _b = __read(identResult, 2);
		return [_b[0], [
			"<dimension-token>",
			numberValue,
			_b[1]
		]];
	}
	if (numberEndIndex + 1 < str.length && str.charCodeAt(numberEndIndex + 1) === 37) return [numberEndIndex + 1, ["<percentage-token>", numberValue]];
	return [numberEndIndex, [
		"<number-token>",
		numberValue,
		numberFlag
	]];
};
var consumeNumber = function consumeNumber$1(str, index) {
	if (str.length <= index) return null;
	var flag = "integer";
	var numberChars = [];
	var firstCode = str.charCodeAt(index);
	if (firstCode === 43 || firstCode === 45) {
		index += 1;
		if (firstCode === 45) numberChars.push(45);
	}
	while (index < str.length) {
		var code = str.charCodeAt(index);
		if (code >= 48 && code <= 57) {
			numberChars.push(code);
			index += 1;
		} else break;
	}
	if (index + 1 < str.length) {
		var nextCode = str.charCodeAt(index);
		var nextNextCode = str.charCodeAt(index + 1);
		if (nextCode === 46 && nextNextCode >= 48 && nextNextCode <= 57) {
			numberChars.push(nextCode, nextNextCode);
			flag = "number";
			index += 2;
			while (index < str.length) {
				var code = str.charCodeAt(index);
				if (code >= 48 && code <= 57) {
					numberChars.push(code);
					index += 1;
				} else break;
			}
		}
	}
	if (index + 1 < str.length) {
		var nextCode = str.charCodeAt(index);
		var nextNextCode = str.charCodeAt(index + 1);
		var nextNextNextCode = str.charCodeAt(index + 2);
		if (nextCode === 69 || nextCode === 101) {
			var nextNextIsDigit = nextNextCode >= 48 && nextNextCode <= 57;
			if (nextNextIsDigit || (nextNextCode === 43 || nextNextCode === 45) && nextNextNextCode >= 48 && nextNextNextCode <= 57) {
				flag = "number";
				if (nextNextIsDigit) {
					numberChars.push(69, nextNextCode);
					index += 2;
				} else if (nextNextCode === 45) {
					numberChars.push(69, 45, nextNextNextCode);
					index += 3;
				} else {
					numberChars.push(69, nextNextNextCode);
					index += 3;
				}
				while (index < str.length) {
					var code = str.charCodeAt(index);
					if (code >= 48 && code <= 57) {
						numberChars.push(code);
						index += 1;
					} else break;
				}
			}
		}
	}
	var numberString = String.fromCharCode.apply(null, numberChars);
	var value = flag === "number" ? parseFloat(numberString) : parseInt(numberString);
	if (value === -0) value = 0;
	return Number.isNaN(value) ? null : [
		index - 1,
		value,
		flag
	];
};
var consumeIdentUnsafe = function consumeIdentUnsafe$1(str, index) {
	if (str.length <= index) return null;
	var identChars = [];
	for (var code = str.charCodeAt(index); index < str.length; code = str.charCodeAt(++index)) {
		if (code === 45 || code === 95 || code >= 65 && code <= 90 || code >= 97 && code <= 122 || code >= 128 || code >= 48 && code <= 57) {
			identChars.push(code);
			continue;
		} else {
			var result = consumeEscape(str, index);
			if (result !== null) {
				var _a = __read(result, 2), lastIndex = _a[0], code_4 = _a[1];
				identChars.push(code_4);
				index = lastIndex;
				continue;
			}
		}
		break;
	}
	return index === 0 ? null : [index - 1, String.fromCharCode.apply(null, identChars)];
};
var consumeIdent = function consumeIdent$1(str, index) {
	if (str.length <= index || !wouldStartIdentifier(str, index)) return null;
	var identChars = [];
	for (var code = str.charCodeAt(index); index < str.length; code = str.charCodeAt(++index)) {
		if (code === 45 || code === 95 || code >= 65 && code <= 90 || code >= 97 && code <= 122 || code >= 128 || code >= 48 && code <= 57) {
			identChars.push(code);
			continue;
		} else {
			var result = consumeEscape(str, index);
			if (result !== null) {
				var _a = __read(result, 2), lastIndex = _a[0], code_5 = _a[1];
				identChars.push(code_5);
				index = lastIndex;
				continue;
			}
		}
		break;
	}
	return [index - 1, String.fromCharCode.apply(null, identChars)];
};
var consumeUrl = function consumeUrl$1(str, index) {
	var code = str.charCodeAt(index);
	while (code === 9 || code === 32 || code === 10) code = str.charCodeAt(++index);
	var urlChars = [];
	var hasFinishedWord = false;
	while (index < str.length) {
		if (code === 41) return [index, String.fromCharCode.apply(null, urlChars)];
		else if (code === 34 || code === 39 || code === 40) return null;
		else if (code === 9 || code === 32 || code === 10) {
			if (!hasFinishedWord && urlChars.length !== 0) hasFinishedWord = true;
		} else if (code === 92) {
			var result = consumeEscape(str, index);
			if (result === null || hasFinishedWord) return null;
			var _a = __read(result, 2), lastIndex = _a[0], value = _a[1];
			urlChars.push(value);
			index = lastIndex;
		} else {
			if (hasFinishedWord) return null;
			urlChars.push(code);
		}
		code = str.charCodeAt(++index);
	}
	return null;
};
var consumeIdentLike = function consumeIdentLike$1(str, index) {
	var result = consumeIdent(str, index);
	if (result === null) return null;
	var _a = __read(result, 2), lastIndex = _a[0], value = _a[1];
	if (value.toLowerCase() === "url") {
		if (str.length > lastIndex + 1) {
			var nextCode = str.charCodeAt(lastIndex + 1);
			if (nextCode === 40) {
				for (var offset = 2; lastIndex + offset < str.length; offset += 1) {
					var nextNextCode = str.charCodeAt(lastIndex + offset);
					if (nextNextCode === 34 || nextNextCode === 39) return [
						lastIndex + 1,
						value.toLowerCase(),
						"<function-token>"
					];
					else if (nextNextCode !== 9 && nextNextCode !== 32 && nextNextCode !== 10) {
						var result_1 = consumeUrl(str, lastIndex + offset);
						if (result_1 === null) return null;
						var _b = __read(result_1, 2);
						return [
							_b[0],
							_b[1],
							"<url-token>"
						];
					}
				}
				return [
					lastIndex + 1,
					value.toLowerCase(),
					"<function-token>"
				];
			}
		}
	} else if (str.length > lastIndex + 1) {
		var nextCode = str.charCodeAt(lastIndex + 1);
		if (nextCode === 40) return [
			lastIndex + 1,
			value.toLowerCase(),
			"<function-token>"
		];
	}
	return [
		lastIndex,
		value.toLowerCase(),
		"<ident-token>"
	];
};
var simplifyAST = function simplifyAST$1(ast) {
	for (var i = ast.length - 1; i >= 0; i--) ast[i] = simplifyMediaQuery(ast[i]);
	return ast;
};
var simplifyMediaQuery = function simplifyMediaQuery$1(mediaQuery) {
	if (mediaQuery.mediaCondition === null) return mediaQuery;
	var mediaCondition = simplifyMediaCondition(mediaQuery.mediaCondition);
	if (mediaCondition.operator === null && mediaCondition.children.length === 1 && "children" in mediaCondition.children[0]) mediaCondition = mediaCondition.children[0];
	return {
		mediaPrefix: mediaQuery.mediaPrefix,
		mediaType: mediaQuery.mediaType,
		mediaCondition
	};
};
var simplifyMediaCondition = function simplifyMediaCondition$1(mediaCondition) {
	for (var i = mediaCondition.children.length - 1; i >= 0; i--) {
		var unsimplifiedChild = mediaCondition.children[i];
		if (!("context" in unsimplifiedChild)) {
			var child = simplifyMediaCondition$1(unsimplifiedChild);
			if (child.operator === null && child.children.length === 1) mediaCondition.children[i] = child.children[0];
			else if (child.operator === mediaCondition.operator && (child.operator === "and" || child.operator === "or")) {
				var spliceArgs = [i, 1];
				for (var i_1 = 0; i_1 < child.children.length; i_1++) spliceArgs.push(child.children[i_1]);
				mediaCondition.children.splice.apply(mediaCondition.children, spliceArgs);
			}
		}
	}
	return mediaCondition;
};
var createError = function createError$1(message, err) {
	if (err instanceof Error) return new Error("".concat(err.message.trim(), "\n").concat(message.trim()));
	else return new Error(message.trim());
};
var toAST = function toAST$1(str) {
	return simplifyAST(toUnflattenedAST(str));
};
var toUnflattenedAST = function toUnflattenedAST$1(str) {
	var tokenList = lexicalAnalysis(str.trim());
	if (tokenList === null) throw createError("Failed tokenizing");
	var startIndex = 0;
	var endIndex = tokenList.length - 1;
	if (tokenList[0].type === "<at-keyword-token>" && tokenList[0].value === "media") {
		if (tokenList[1].type !== "<whitespace-token>") throw createError("Expected whitespace after media");
		startIndex = 2;
		for (var i = 2; i < tokenList.length - 1; i++) {
			var token = tokenList[i];
			if (token.type === "<{-token>") {
				endIndex = i;
				break;
			} else if (token.type === "<semicolon-token>") throw createError("Expected '{' in media query but found ';'");
		}
	}
	tokenList = tokenList.slice(startIndex, endIndex);
	return syntacticAnalysis(tokenList);
};
var removeWhitespace = function removeWhitespace$1(tokenList) {
	var newTokenList = [];
	var before = false;
	for (var i = 0; i < tokenList.length; i++) if (tokenList[i].type === "<whitespace-token>") {
		before = true;
		if (newTokenList.length > 0) newTokenList[newTokenList.length - 1].wsAfter = true;
	} else {
		newTokenList.push(__assign(__assign({}, tokenList[i]), {
			wsBefore: before,
			wsAfter: false
		}));
		before = false;
	}
	return newTokenList;
};
var syntacticAnalysis = function syntacticAnalysis$1(tokenList) {
	var e_1, _a;
	var mediaQueryList = [[]];
	for (var i = 0; i < tokenList.length; i++) {
		var token = tokenList[i];
		if (token.type === "<comma-token>") mediaQueryList.push([]);
		else mediaQueryList[mediaQueryList.length - 1].push(token);
	}
	var mediaQueries = mediaQueryList.map(removeWhitespace);
	if (mediaQueries.length === 1 && mediaQueries[0].length === 0) return [{
		mediaCondition: null,
		mediaPrefix: null,
		mediaType: "all"
	}];
	else {
		var mediaQueryTokens = mediaQueries.map(function(mediaQueryTokens$1) {
			if (mediaQueryTokens$1.length === 0) return null;
			else return tokenizeMediaQuery(mediaQueryTokens$1);
		});
		var nonNullMediaQueryTokens = [];
		try {
			for (var mediaQueryTokens_1 = __values(mediaQueryTokens), mediaQueryTokens_1_1 = mediaQueryTokens_1.next(); !mediaQueryTokens_1_1.done; mediaQueryTokens_1_1 = mediaQueryTokens_1.next()) {
				var mediaQueryToken = mediaQueryTokens_1_1.value;
				if (mediaQueryToken !== null) nonNullMediaQueryTokens.push(mediaQueryToken);
			}
		} catch (e_1_1) {
			e_1 = { error: e_1_1 };
		} finally {
			try {
				if (mediaQueryTokens_1_1 && !mediaQueryTokens_1_1.done && (_a = mediaQueryTokens_1["return"])) _a.call(mediaQueryTokens_1);
			} finally {
				if (e_1) throw e_1.error;
			}
		}
		if (nonNullMediaQueryTokens.length === 0) throw createError("No valid media queries");
		return nonNullMediaQueryTokens;
	}
};
var tokenizeMediaQuery = function tokenizeMediaQuery$1(tokens) {
	var firstToken = tokens[0];
	if (firstToken.type === "<(-token>") try {
		return {
			mediaPrefix: null,
			mediaType: "all",
			mediaCondition: tokenizeMediaCondition(tokens, true)
		};
	} catch (err) {
		throw createError("Expected media condition after '('", err);
	}
	else if (firstToken.type === "<ident-token>") {
		var mediaPrefix = null;
		var mediaType = void 0;
		var value = firstToken.value;
		if (value === "only" || value === "not") mediaPrefix = value;
		var firstIndex = mediaPrefix === null ? 0 : 1;
		if (tokens.length <= firstIndex) throw createError("Expected extra token in media query");
		var firstNonUnaryToken = tokens[firstIndex];
		if (firstNonUnaryToken.type === "<ident-token>") {
			var value_1 = firstNonUnaryToken.value;
			if (value_1 === "all") mediaType = "all";
			else if (value_1 === "print" || value_1 === "screen") mediaType = value_1;
			else if (value_1 === "tty" || value_1 === "tv" || value_1 === "projection" || value_1 === "handheld" || value_1 === "braille" || value_1 === "embossed" || value_1 === "aural" || value_1 === "speech") {
				mediaPrefix = mediaPrefix === "not" ? null : "not";
				mediaType = "all";
			} else throw createError("Unknown ident '".concat(value_1, "' in media query"));
		} else if (mediaPrefix === "not" && firstNonUnaryToken.type === "<(-token>") {
			var tokensWithParens = [{
				type: "<(-token>",
				wsBefore: false,
				wsAfter: false
			}];
			tokensWithParens.push.apply(tokensWithParens, tokens);
			tokensWithParens.push({
				type: "<)-token>",
				wsBefore: false,
				wsAfter: false
			});
			try {
				return {
					mediaPrefix: null,
					mediaType: "all",
					mediaCondition: tokenizeMediaCondition(tokensWithParens, true)
				};
			} catch (err) {
				throw createError("Expected media condition after '('", err);
			}
		} else throw createError("Invalid media query");
		if (firstIndex + 1 === tokens.length) return {
			mediaPrefix,
			mediaType,
			mediaCondition: null
		};
		else if (firstIndex + 4 < tokens.length) {
			var secondNonUnaryToken = tokens[firstIndex + 1];
			if (secondNonUnaryToken.type === "<ident-token>" && secondNonUnaryToken.value === "and") try {
				return {
					mediaPrefix,
					mediaType,
					mediaCondition: tokenizeMediaCondition(tokens.slice(firstIndex + 2), false)
				};
			} catch (err) {
				throw createError("Expected media condition after 'and'", err);
			}
			else throw createError("Expected 'and' after media prefix");
		} else throw createError("Expected media condition after media prefix");
	} else throw createError("Expected media condition or media prefix");
};
var tokenizeMediaCondition = function tokenizeMediaCondition$1(tokens, mayContainOr, previousOperator) {
	if (previousOperator === void 0) previousOperator = null;
	if (tokens.length < 3 || tokens[0].type !== "<(-token>" || tokens[tokens.length - 1].type !== "<)-token>") throw new Error("Invalid media condition");
	var endIndexOfFirstFeature = tokens.length - 1;
	var maxDepth = 0;
	var count = 0;
	for (var i = 0; i < tokens.length; i++) {
		var token = tokens[i];
		if (token.type === "<(-token>") {
			count += 1;
			maxDepth = Math.max(maxDepth, count);
		} else if (token.type === "<)-token>") count -= 1;
		if (count === 0) {
			endIndexOfFirstFeature = i;
			break;
		}
	}
	if (count !== 0) throw new Error("Mismatched parens\nInvalid media condition");
	var child;
	var featureTokens = tokens.slice(0, endIndexOfFirstFeature + 1);
	if (maxDepth === 1) child = tokenizeMediaFeature(featureTokens);
	else if (featureTokens[1].type === "<ident-token>" && featureTokens[1].value === "not") child = tokenizeMediaCondition$1(featureTokens.slice(2, -1), true, "not");
	else child = tokenizeMediaCondition$1(featureTokens.slice(1, -1), true);
	if (endIndexOfFirstFeature === tokens.length - 1) return {
		operator: previousOperator,
		children: [child]
	};
	else {
		var nextToken = tokens[endIndexOfFirstFeature + 1];
		if (nextToken.type !== "<ident-token>") throw new Error("Invalid operator\nInvalid media condition");
		else if (previousOperator !== null && previousOperator !== nextToken.value) throw new Error("'".concat(nextToken.value, "' and '").concat(previousOperator, "' must not be at same level\nInvalid media condition"));
		else if (nextToken.value === "or" && !mayContainOr) throw new Error("Cannot use 'or' at top level of a media query\nInvalid media condition");
		else if (nextToken.value !== "and" && nextToken.value !== "or") throw new Error("Invalid operator: '".concat(nextToken.value, "'\nInvalid media condition"));
		var siblings = tokenizeMediaCondition$1(tokens.slice(endIndexOfFirstFeature + 2), mayContainOr, nextToken.value);
		return {
			operator: nextToken.value,
			children: [child].concat(siblings.children)
		};
	}
};
var tokenizeMediaFeature = function tokenizeMediaFeature$1(rawTokens) {
	if (rawTokens.length < 3 || rawTokens[0].type !== "<(-token>" || rawTokens[rawTokens.length - 1].type !== "<)-token>") throw new Error("Invalid media feature");
	var tokens = [rawTokens[0]];
	for (var i = 1; i < rawTokens.length; i++) {
		if (i < rawTokens.length - 2) {
			var a = rawTokens[i];
			var b = rawTokens[i + 1];
			var c = rawTokens[i + 2];
			if (a.type === "<number-token>" && a.value > 0 && b.type === "<delim-token>" && b.value === 47 && c.type === "<number-token>" && c.value > 0) {
				tokens.push({
					type: "<ratio-token>",
					numerator: a.value,
					denominator: c.value,
					wsBefore: a.wsBefore,
					wsAfter: c.wsAfter
				});
				i += 2;
				continue;
			}
		}
		tokens.push(rawTokens[i]);
	}
	var nextToken = tokens[1];
	if (nextToken.type === "<ident-token>" && tokens.length === 3) return {
		context: "boolean",
		feature: nextToken.value
	};
	else if (tokens.length === 5 && tokens[1].type === "<ident-token>" && tokens[2].type === "<colon-token>") {
		var valueToken = tokens[3];
		if (valueToken.type === "<number-token>" || valueToken.type === "<dimension-token>" || valueToken.type === "<ratio-token>" || valueToken.type === "<ident-token>") {
			var feature = tokens[1].value;
			var prefix = null;
			var slice = feature.slice(0, 4);
			if (slice === "min-") {
				prefix = "min";
				feature = feature.slice(4);
			} else if (slice === "max-") {
				prefix = "max";
				feature = feature.slice(4);
			}
			valueToken.wsBefore;
			valueToken.wsAfter;
			var value = __rest(valueToken, ["wsBefore", "wsAfter"]);
			return {
				context: "value",
				prefix,
				feature,
				value
			};
		}
	} else if (tokens.length >= 5) try {
		var range = tokenizeRange(tokens);
		return {
			context: "range",
			feature: range.featureName,
			range
		};
	} catch (err) {
		throw createError("Invalid media feature", err);
	}
	throw new Error("Invalid media feature");
};
var tokenizeRange = function tokenizeRange$1(tokens) {
	var _a, _b, _c, _d;
	if (tokens.length < 5 || tokens[0].type !== "<(-token>" || tokens[tokens.length - 1].type !== "<)-token>") throw new Error("Invalid range");
	var range = {
		leftToken: null,
		leftOp: null,
		featureName: "",
		rightOp: null,
		rightToken: null
	};
	var hasLeft = tokens[1].type === "<number-token>" || tokens[1].type === "<dimension-token>" || tokens[1].type === "<ratio-token>" || tokens[1].type === "<ident-token>" && tokens[1].value === "infinite";
	if (tokens[2].type === "<delim-token>") {
		if (tokens[2].value === 60) if (tokens[3].type === "<delim-token>" && tokens[3].value === 61 && !tokens[3].wsBefore) range[hasLeft ? "leftOp" : "rightOp"] = "<=";
		else range[hasLeft ? "leftOp" : "rightOp"] = "<";
		else if (tokens[2].value === 62) if (tokens[3].type === "<delim-token>" && tokens[3].value === 61 && !tokens[3].wsBefore) range[hasLeft ? "leftOp" : "rightOp"] = ">=";
		else range[hasLeft ? "leftOp" : "rightOp"] = ">";
		else if (tokens[2].value === 61) range[hasLeft ? "leftOp" : "rightOp"] = "=";
		else throw new Error("Invalid range");
		if (hasLeft) range.leftToken = tokens[1];
		else if (tokens[1].type === "<ident-token>") range.featureName = tokens[1].value;
		else throw new Error("Invalid range");
		var tokenIndexAfterFirstOp = 2 + ((_b = (_a = range[hasLeft ? "leftOp" : "rightOp"]) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0);
		var tokenAfterFirstOp = tokens[tokenIndexAfterFirstOp];
		if (hasLeft) if (tokenAfterFirstOp.type === "<ident-token>") {
			range.featureName = tokenAfterFirstOp.value;
			if (tokens.length >= 7) {
				var secondOpToken = tokens[tokenIndexAfterFirstOp + 1];
				var followingToken = tokens[tokenIndexAfterFirstOp + 2];
				if (secondOpToken.type === "<delim-token>") {
					var charCode = secondOpToken.value;
					if (charCode === 60) if (followingToken.type === "<delim-token>" && followingToken.value === 61 && !followingToken.wsBefore) range.rightOp = "<=";
					else range.rightOp = "<";
					else if (charCode === 62) if (followingToken.type === "<delim-token>" && followingToken.value === 61 && !followingToken.wsBefore) range.rightOp = ">=";
					else range.rightOp = ">";
					else throw new Error("Invalid range");
					range.rightToken = tokens[tokenIndexAfterFirstOp + 1 + ((_d = (_c = range.rightOp) === null || _c === void 0 ? void 0 : _c.length) !== null && _d !== void 0 ? _d : 0)];
				} else throw new Error("Invalid range");
			} else if (tokenIndexAfterFirstOp + 2 !== tokens.length) throw new Error("Invalid range");
		} else throw new Error("Invalid range");
		else range.rightToken = tokenAfterFirstOp;
		var validRange = null;
		var lt = range.leftToken, leftOp = range.leftOp, featureName = range.featureName, rightOp = range.rightOp, rt = range.rightToken;
		var leftToken = null;
		if (lt !== null) {
			if (lt.type === "<ident-token>") {
				var type = lt.type, value = lt.value;
				if (value === "infinite") leftToken = {
					type,
					value
				};
			} else if (lt.type === "<number-token>" || lt.type === "<dimension-token>" || lt.type === "<ratio-token>") {
				lt.wsBefore;
				lt.wsAfter;
				leftToken = __rest(lt, ["wsBefore", "wsAfter"]);
			}
		}
		var rightToken = null;
		if (rt !== null) {
			if (rt.type === "<ident-token>") {
				var type = rt.type, value = rt.value;
				if (value === "infinite") rightToken = {
					type,
					value
				};
			} else if (rt.type === "<number-token>" || rt.type === "<dimension-token>" || rt.type === "<ratio-token>") {
				rt.wsBefore;
				rt.wsAfter;
				rightToken = __rest(rt, ["wsBefore", "wsAfter"]);
			}
		}
		if (leftToken !== null && rightToken !== null) if ((leftOp === "<" || leftOp === "<=") && (rightOp === "<" || rightOp === "<=")) validRange = {
			leftToken,
			leftOp,
			featureName,
			rightOp,
			rightToken
		};
		else if ((leftOp === ">" || leftOp === ">=") && (rightOp === ">" || rightOp === ">=")) validRange = {
			leftToken,
			leftOp,
			featureName,
			rightOp,
			rightToken
		};
		else throw new Error("Invalid range");
		else if (leftToken === null && leftOp === null && rightOp !== null && rightToken !== null) validRange = {
			leftToken,
			leftOp,
			featureName,
			rightOp,
			rightToken
		};
		else if (leftToken !== null && leftOp !== null && rightOp === null && rightToken === null) validRange = {
			leftToken,
			leftOp,
			featureName,
			rightOp,
			rightToken
		};
		return validRange;
	} else throw new Error("Invalid range");
};

//#endregion
//#region node_modules/.pnpm/@vanilla-extract+css@1.18.0/node_modules/@vanilla-extract/css/dist/transformCss-20240126.browser.esm.js
function toPrimitive(t, r$1) {
	if ("object" != typeof t || !t) return t;
	var e = t[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i = e.call(t, r$1 || "default");
		if ("object" != typeof i) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r$1 ? String : Number)(t);
}
function toPropertyKey(t) {
	var i = toPrimitive(t, "string");
	return "symbol" == typeof i ? i : String(i);
}
function _defineProperty(obj, key, value) {
	key = toPropertyKey(key);
	if (key in obj) Object.defineProperty(obj, key, {
		value,
		enumerable: true,
		configurable: true,
		writable: true
	});
	else obj[key] = value;
	return obj;
}
function ownKeys(e, r$1) {
	var t = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o = Object.getOwnPropertySymbols(e);
		r$1 && (o = o.filter(function(r$2) {
			return Object.getOwnPropertyDescriptor(e, r$2).enumerable;
		})), t.push.apply(t, o);
	}
	return t;
}
function _objectSpread2(e) {
	for (var r$1 = 1; r$1 < arguments.length; r$1++) {
		var t = null != arguments[r$1] ? arguments[r$1] : {};
		r$1 % 2 ? ownKeys(Object(t), !0).forEach(function(r$2) {
			_defineProperty(e, r$2, t[r$2]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r$2) {
			Object.defineProperty(e, r$2, Object.getOwnPropertyDescriptor(t, r$2));
		});
	}
	return e;
}
function _objectWithoutPropertiesLoose(source, excluded) {
	if (source == null) return {};
	var target = {};
	var sourceKeys = Object.keys(source);
	var key, i;
	for (i = 0; i < sourceKeys.length; i++) {
		key = sourceKeys[i];
		if (excluded.indexOf(key) >= 0) continue;
		target[key] = source[key];
	}
	return target;
}
function _objectWithoutProperties(source, excluded) {
	if (source == null) return {};
	var target = _objectWithoutPropertiesLoose(source, excluded);
	var key, i;
	if (Object.getOwnPropertySymbols) {
		var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
		for (i = 0; i < sourceSymbolKeys.length; i++) {
			key = sourceSymbolKeys[i];
			if (excluded.indexOf(key) >= 0) continue;
			if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
			target[key] = source[key];
		}
	}
	return target;
}
function forEach(obj, fn) {
	for (var _key in obj) fn(obj[_key], _key);
}
function omit(obj, omitKeys) {
	var result = {};
	for (var _key2 in obj) if (omitKeys.indexOf(_key2) === -1) result[_key2] = obj[_key2];
	return result;
}
function mapKeys(obj, fn) {
	var result = {};
	for (var _key3 in obj) result[fn(obj[_key3], _key3)] = obj[_key3];
	return result;
}
var _templateObject$1;
function escapeRegex(string$1) {
	return string$1.replace(/[-/\\^$*+?.()|[\]{}]/g, "\\$&");
}
var validateSelector = (selector, targetClassName) => {
	var replaceTarget = () => {
		var targetRegex = new RegExp(".".concat(escapeRegex((0, import_cssesc$1.default)(targetClassName, { isIdentifier: true }))), "g");
		return selector.replace(targetRegex, "&");
	};
	var selectorParts;
	try {
		selectorParts = parse(selector);
	} catch (err) {
		throw new Error("Invalid selector: ".concat(replaceTarget()), { cause: err });
	}
	selectorParts.forEach((tokens) => {
		try {
			for (var i = tokens.length - 1; i >= -1; i--) {
				if (!tokens[i]) throw new Error();
				var token = tokens[i];
				if (token.type === "child" || token.type === "parent" || token.type === "sibling" || token.type === "adjacent" || token.type === "descendant") throw new Error();
				if (token.type === "attribute" && token.name === "class" && token.value === targetClassName) return;
			}
		} catch (err) {
			throw new Error(dedent_default(_templateObject$1 || (_templateObject$1 = _taggedTemplateLiteral([
				"\n        Invalid selector: ",
				"\n    \n        Style selectors must target the '&' character (along with any modifiers), e.g. ",
				" or ",
				".\n        \n        This is to ensure that each style block only affects the styling of a single class.\n        \n        If your selector is targeting another class, you should move it to the style definition for that class, e.g. given we have styles for 'parent' and 'child' elements, instead of adding a selector of ",
				") to 'parent', you should add ",
				" to 'child').\n        \n        If your selector is targeting something global, use the 'globalStyle' function instead, e.g. if you wanted to write ",
				", you should instead write 'globalStyle(",
				", { ... })'\n      "
			])), replaceTarget(), "`${parent} &`", "`${parent} &:hover`", "`& ${child}`", "`${parent} &`", "`& h1`", "`${parent} h1`"), { cause: err });
		}
	});
};
/** e.g. @media screen and (min-width: 500px) */
var ConditionalRuleset = class ConditionalRuleset {
	/**
	* Stores information about where conditions must be in relation to other conditions
	*
	* e.g. mobile -> tablet, desktop
	*/
	constructor() {
		this.ruleset = /* @__PURE__ */ new Map();
		this.precedenceLookup = /* @__PURE__ */ new Map();
	}
	findOrCreateCondition(conditionQuery) {
		var targetCondition = this.ruleset.get(conditionQuery);
		if (!targetCondition) {
			targetCondition = {
				query: conditionQuery,
				rules: [],
				children: new ConditionalRuleset()
			};
			this.ruleset.set(conditionQuery, targetCondition);
		}
		return targetCondition;
	}
	getConditionalRulesetByPath(conditionPath) {
		var currRuleset = this;
		for (var query of conditionPath) currRuleset = currRuleset.findOrCreateCondition(query).children;
		return currRuleset;
	}
	addRule(rule, conditionQuery, conditionPath) {
		var targetCondition = this.getConditionalRulesetByPath(conditionPath).findOrCreateCondition(conditionQuery);
		if (!targetCondition) throw new Error("Failed to add conditional rule");
		targetCondition.rules.push(rule);
	}
	addConditionPrecedence(conditionPath, conditionOrder) {
		var ruleset = this.getConditionalRulesetByPath(conditionPath);
		for (var i = 0; i < conditionOrder.length; i++) {
			var _ruleset$precedenceLo;
			var query = conditionOrder[i];
			var conditionPrecedence = (_ruleset$precedenceLo = ruleset.precedenceLookup.get(query)) !== null && _ruleset$precedenceLo !== void 0 ? _ruleset$precedenceLo : /* @__PURE__ */ new Set();
			for (var lowerPrecedenceCondition of conditionOrder.slice(i + 1)) conditionPrecedence.add(lowerPrecedenceCondition);
			ruleset.precedenceLookup.set(query, conditionPrecedence);
		}
	}
	isCompatible(incomingRuleset) {
		for (var [condition, orderPrecedence] of this.precedenceLookup.entries()) for (var lowerPrecedenceCondition of orderPrecedence) {
			var _incomingRuleset$prec;
			if ((_incomingRuleset$prec = incomingRuleset.precedenceLookup.get(lowerPrecedenceCondition)) !== null && _incomingRuleset$prec !== void 0 && _incomingRuleset$prec.has(condition)) return false;
		}
		for (var { query, children } of incomingRuleset.ruleset.values()) {
			var matchingCondition = this.ruleset.get(query);
			if (matchingCondition && !matchingCondition.children.isCompatible(children)) return false;
		}
		return true;
	}
	merge(incomingRuleset) {
		for (var { query, rules, children } of incomingRuleset.ruleset.values()) {
			var matchingCondition = this.ruleset.get(query);
			if (matchingCondition) {
				matchingCondition.rules.push(...rules);
				matchingCondition.children.merge(children);
			} else this.ruleset.set(query, {
				query,
				rules,
				children
			});
		}
		for (var [condition, incomingOrderPrecedence] of incomingRuleset.precedenceLookup.entries()) {
			var _this$precedenceLooku;
			var orderPrecedence = (_this$precedenceLooku = this.precedenceLookup.get(condition)) !== null && _this$precedenceLooku !== void 0 ? _this$precedenceLooku : /* @__PURE__ */ new Set();
			this.precedenceLookup.set(condition, new Set([...orderPrecedence, ...incomingOrderPrecedence]));
		}
	}
	/**
	* Merge another ConditionalRuleset into this one if they are compatible
	*
	* @returns true if successful, false if the ruleset is incompatible
	*/
	mergeIfCompatible(incomingRuleset) {
		if (!this.isCompatible(incomingRuleset)) return false;
		this.merge(incomingRuleset);
		return true;
	}
	getSortedRuleset() {
		var _this = this;
		var sortedRuleset = [];
		var _loop = function _loop$1(dependents$1) {
			var conditionForQuery = _this.ruleset.get(query);
			if (!conditionForQuery) throw new Error("Can't find condition for ".concat(query));
			var firstMatchingDependent = sortedRuleset.findIndex((condition) => dependents$1.has(condition.query));
			if (firstMatchingDependent > -1) sortedRuleset.splice(firstMatchingDependent, 0, conditionForQuery);
			else sortedRuleset.push(conditionForQuery);
		};
		for (var [query, dependents] of this.precedenceLookup.entries()) _loop(dependents);
		return sortedRuleset;
	}
	renderToArray() {
		var arr = [];
		for (var { query, rules, children } of this.getSortedRuleset()) {
			var selectors = {};
			for (var rule of rules) selectors[rule.selector] = _objectSpread2(_objectSpread2({}, selectors[rule.selector]), rule.rule);
			Object.assign(selectors, ...children.renderToArray());
			arr.push({ [query]: selectors });
		}
		return arr;
	}
};
var simplePseudoMap = {
	":-moz-any-link": true,
	":-moz-full-screen": true,
	":-moz-placeholder": true,
	":-moz-read-only": true,
	":-moz-read-write": true,
	":-ms-fullscreen": true,
	":-ms-input-placeholder": true,
	":-webkit-any-link": true,
	":-webkit-full-screen": true,
	"::-moz-color-swatch": true,
	"::-moz-list-bullet": true,
	"::-moz-list-number": true,
	"::-moz-page-sequence": true,
	"::-moz-page": true,
	"::-moz-placeholder": true,
	"::-moz-progress-bar": true,
	"::-moz-range-progress": true,
	"::-moz-range-thumb": true,
	"::-moz-range-track": true,
	"::-moz-scrolled-page-sequence": true,
	"::-moz-selection": true,
	"::-ms-backdrop": true,
	"::-ms-browse": true,
	"::-ms-check": true,
	"::-ms-clear": true,
	"::-ms-fill-lower": true,
	"::-ms-fill-upper": true,
	"::-ms-fill": true,
	"::-ms-reveal": true,
	"::-ms-thumb": true,
	"::-ms-ticks-after": true,
	"::-ms-ticks-before": true,
	"::-ms-tooltip": true,
	"::-ms-track": true,
	"::-ms-value": true,
	"::-webkit-backdrop": true,
	"::-webkit-calendar-picker-indicator": true,
	"::-webkit-inner-spin-button": true,
	"::-webkit-input-placeholder": true,
	"::-webkit-meter-bar": true,
	"::-webkit-meter-even-less-good-value": true,
	"::-webkit-meter-inner-element": true,
	"::-webkit-meter-optimum-value": true,
	"::-webkit-meter-suboptimum-value": true,
	"::-webkit-outer-spin-button": true,
	"::-webkit-progress-bar": true,
	"::-webkit-progress-inner-element": true,
	"::-webkit-progress-inner-value": true,
	"::-webkit-progress-value": true,
	"::-webkit-resizer": true,
	"::-webkit-scrollbar-button": true,
	"::-webkit-scrollbar-corner": true,
	"::-webkit-scrollbar-thumb": true,
	"::-webkit-scrollbar-track-piece": true,
	"::-webkit-scrollbar-track": true,
	"::-webkit-scrollbar": true,
	"::-webkit-search-cancel-button": true,
	"::-webkit-search-results-button": true,
	"::-webkit-slider-runnable-track": true,
	"::-webkit-slider-thumb": true,
	"::after": true,
	"::backdrop": true,
	"::before": true,
	"::cue": true,
	"::file-selector-button": true,
	"::first-letter": true,
	"::first-line": true,
	"::grammar-error": true,
	"::marker": true,
	"::placeholder": true,
	"::selection": true,
	"::spelling-error": true,
	"::target-text": true,
	"::view-transition-group": true,
	"::view-transition-image-pair": true,
	"::view-transition-new": true,
	"::view-transition-old": true,
	"::view-transition": true,
	":active": true,
	":after": true,
	":any-link": true,
	":before": true,
	":blank": true,
	":checked": true,
	":default": true,
	":defined": true,
	":disabled": true,
	":empty": true,
	":enabled": true,
	":first-child": true,
	":first-letter": true,
	":first-line": true,
	":first-of-type": true,
	":first": true,
	":focus-visible": true,
	":focus-within": true,
	":focus": true,
	":fullscreen": true,
	":hover": true,
	":in-range": true,
	":indeterminate": true,
	":invalid": true,
	":last-child": true,
	":last-of-type": true,
	":left": true,
	":link": true,
	":only-child": true,
	":only-of-type": true,
	":optional": true,
	":out-of-range": true,
	":placeholder-shown": true,
	":read-only": true,
	":read-write": true,
	":required": true,
	":right": true,
	":root": true,
	":scope": true,
	":target": true,
	":valid": true,
	":visited": true
};
var simplePseudos = Object.keys(simplePseudoMap);
var simplePseudoLookup = simplePseudoMap;
var _templateObject;
var createMediaQueryError = (mediaQuery, msg) => new Error(dedent_default(_templateObject || (_templateObject = _taggedTemplateLiteral([
	"\n    Invalid media query: \"",
	"\"\n\n    ",
	"\n\n    Read more on MDN: https://developer.mozilla.org/en-US/docs/Web/CSS/Media_Queries/Using_media_queries\n  "
])), mediaQuery, msg));
var validateMediaQuery = (mediaQuery) => {
	if (mediaQuery === "@media ") throw createMediaQueryError(mediaQuery, "Query is empty");
	try {
		toAST(mediaQuery);
	} catch (e) {
		throw createMediaQueryError(mediaQuery, e.message);
	}
};
var _excluded = ["vars"], _excluded2 = ["content"];
var DECLARATION = "__DECLARATION";
var UNITLESS = {
	animationIterationCount: true,
	borderImage: true,
	borderImageOutset: true,
	borderImageSlice: true,
	borderImageWidth: true,
	boxFlex: true,
	boxFlexGroup: true,
	columnCount: true,
	columns: true,
	flex: true,
	flexGrow: true,
	flexShrink: true,
	fontWeight: true,
	gridArea: true,
	gridColumn: true,
	gridColumnEnd: true,
	gridColumnStart: true,
	gridRow: true,
	gridRowEnd: true,
	gridRowStart: true,
	initialLetter: true,
	lineClamp: true,
	lineHeight: true,
	maxLines: true,
	opacity: true,
	order: true,
	orphans: true,
	scale: true,
	tabSize: true,
	WebkitLineClamp: true,
	widows: true,
	zIndex: true,
	zoom: true,
	fillOpacity: true,
	floodOpacity: true,
	maskBorder: true,
	maskBorderOutset: true,
	maskBorderSlice: true,
	maskBorderWidth: true,
	shapeImageThreshold: true,
	stopOpacity: true,
	strokeDashoffset: true,
	strokeMiterlimit: true,
	strokeOpacity: true,
	strokeWidth: true
};
function dashify(str) {
	return str.replace(/([A-Z])/g, "-$1").replace(/^ms-/, "-ms-").toLowerCase();
}
function replaceBetweenIndexes(target, startIndex, endIndex, replacement) {
	var start = target.slice(0, startIndex);
	var end = target.slice(endIndex);
	return "".concat(start).concat(replacement).concat(end);
}
var DOUBLE_SPACE = "  ";
var specialKeys = [
	...simplePseudos,
	"@layer",
	"@media",
	"@supports",
	"@container",
	"@starting-style",
	"selectors"
];
var Stylesheet = class {
	constructor(localClassNames$1, composedClassLists$1) {
		this.rules = [];
		this.conditionalRulesets = [new ConditionalRuleset()];
		this.fontFaceRules = [];
		this.keyframesRules = [];
		this.propertyRules = [];
		this.localClassNamesMap = new Map(localClassNames$1.map((localClassName) => [localClassName, localClassName]));
		this.localClassNamesSearch = new AhoCorasick(localClassNames$1);
		this.layers = /* @__PURE__ */ new Map();
		this.composedClassLists = composedClassLists$1.map((_ref) => {
			var { identifier, classList } = _ref;
			return {
				identifier,
				regex: RegExp("(".concat(classList, ")"), "g")
			};
		}).reverse();
	}
	processCssObj(root) {
		if (root.type === "fontFace") {
			this.fontFaceRules.push(root.rule);
			return;
		}
		if (root.type === "property") {
			this.propertyRules.push(root);
			return;
		}
		if (root.type === "keyframes") {
			root.rule = Object.fromEntries(Object.entries(root.rule).map((_ref2) => {
				var [keyframe, rule] = _ref2;
				return [keyframe, this.transformVars(this.transformProperties(rule))];
			}));
			this.keyframesRules.push(root);
			return;
		}
		this.currConditionalRuleset = new ConditionalRuleset();
		if (root.type === "layer") {
			var layerDefinition = "@layer ".concat(root.name);
			this.addLayer([layerDefinition]);
		} else {
			var mainRule = omit(root.rule, specialKeys);
			this.addRule({
				selector: root.selector,
				rule: mainRule
			});
			this.transformLayer(root, root.rule["@layer"]);
			this.transformMedia(root, root.rule["@media"]);
			this.transformSupports(root, root.rule["@supports"]);
			this.transformContainer(root, root.rule["@container"]);
			this.transformStartingStyle(root, root.rule["@starting-style"]);
			this.transformSimplePseudos(root, root.rule);
			this.transformSelectors(root, root.rule);
		}
		if (!this.conditionalRulesets[this.conditionalRulesets.length - 1].mergeIfCompatible(this.currConditionalRuleset)) this.conditionalRulesets.push(this.currConditionalRuleset);
	}
	addConditionalRule(cssRule, conditions) {
		var rule = this.transformVars(this.transformProperties(cssRule.rule));
		var selector = this.transformSelector(cssRule.selector);
		if (!this.currConditionalRuleset) throw new Error("Couldn't add conditional rule");
		var conditionQuery = conditions[conditions.length - 1];
		var parentConditions = conditions.slice(0, conditions.length - 1);
		this.currConditionalRuleset.addRule({
			selector,
			rule
		}, conditionQuery, parentConditions);
	}
	addRule(cssRule) {
		var rule = this.transformVars(this.transformProperties(cssRule.rule));
		var selector = this.transformSelector(cssRule.selector);
		this.rules.push({
			selector,
			rule
		});
	}
	addLayer(layer) {
		var uniqueLayerKey = layer.join(" - ");
		this.layers.set(uniqueLayerKey, layer);
	}
	transformProperties(cssRule) {
		return this.transformContent(this.pixelifyProperties(cssRule));
	}
	pixelifyProperties(cssRule) {
		forEach(cssRule, (value, key) => {
			if (typeof value === "number" && value !== 0 && !UNITLESS[key]) cssRule[key] = "".concat(value, "px");
		});
		return cssRule;
	}
	transformVars(_ref3) {
		var { vars } = _ref3, rest = _objectWithoutProperties(_ref3, _excluded);
		if (!vars) return rest;
		return _objectSpread2(_objectSpread2({}, mapKeys(vars, (_value, key) => getVarName(key))), rest);
	}
	transformContent(_ref4) {
		var { content: content$1 } = _ref4, rest = _objectWithoutProperties(_ref4, _excluded2);
		if (typeof content$1 === "undefined") return rest;
		return _objectSpread2({ content: (Array.isArray(content$1) ? content$1 : [content$1]).map((value) => value && (value.includes("\"") || value.includes("'") || /^([A-Za-z-]+\([^]*|[^]*-quote|inherit|initial|none|normal|revert|unset)(\s|$)/.test(value)) ? value : "\"".concat(value, "\"")) }, rest);
	}
	transformClassname(identifier) {
		return ".".concat((0, import_cssesc$1.default)(identifier, { isIdentifier: true }));
	}
	transformSelector(selector) {
		var transformedSelector = selector;
		var _loop = function _loop$1(identifier$1) {
			transformedSelector = transformedSelector.replace(regex, () => {
				markCompositionUsed(identifier$1);
				return identifier$1;
			});
		};
		for (var { identifier, regex } of this.composedClassLists) _loop(identifier);
		if (this.localClassNamesMap.has(transformedSelector)) return this.transformClassname(transformedSelector);
		var results = this.localClassNamesSearch.search(transformedSelector);
		var lastReplaceIndex = transformedSelector.length;
		for (var i = results.length - 1; i >= 0; i--) {
			var [endIndex, [firstMatch]] = results[i];
			var startIndex = endIndex - firstMatch.length + 1;
			if (lastReplaceIndex <= endIndex) continue;
			lastReplaceIndex = startIndex;
			if (transformedSelector[startIndex - 1] !== ".") transformedSelector = replaceBetweenIndexes(transformedSelector, startIndex, endIndex + 1, this.transformClassname(firstMatch));
		}
		return transformedSelector;
	}
	transformSelectors(root, rule, conditions) {
		forEach(rule.selectors, (selectorRule, selector) => {
			if (root.type !== "local") throw new Error("Selectors are not allowed within ".concat(root.type === "global" ? "\"globalStyle\"" : "\"selectors\""));
			var transformedSelector = this.transformSelector(selector.replace(RegExp("&", "g"), root.selector));
			validateSelector(transformedSelector, root.selector);
			var rule$1 = {
				selector: transformedSelector,
				rule: omit(selectorRule, specialKeys)
			};
			if (conditions) this.addConditionalRule(rule$1, conditions);
			else this.addRule(rule$1);
			var selectorRoot = {
				type: "selector",
				selector: transformedSelector,
				rule: selectorRule
			};
			this.transformLayer(selectorRoot, selectorRule["@layer"], conditions);
			this.transformSupports(selectorRoot, selectorRule["@supports"], conditions);
			this.transformMedia(selectorRoot, selectorRule["@media"], conditions);
			this.transformContainer(selectorRoot, selectorRule["@container"], conditions);
			this.transformStartingStyle(selectorRoot, selectorRule["@starting-style"], conditions);
		});
	}
	transformMedia(root, rules) {
		var parentConditions = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
		if (rules) {
			var _this$currConditional;
			(_this$currConditional = this.currConditionalRuleset) === null || _this$currConditional === void 0 || _this$currConditional.addConditionPrecedence(parentConditions, Object.keys(rules).map((query$1) => "@media ".concat(query$1)));
			for (var [query, mediaRule] of Object.entries(rules)) {
				var mediaQuery = "@media ".concat(query);
				validateMediaQuery(mediaQuery);
				var conditions = [...parentConditions, mediaQuery];
				this.addConditionalRule({
					selector: root.selector,
					rule: omit(mediaRule, specialKeys)
				}, conditions);
				if (root.type === "local") {
					this.transformSimplePseudos(root, mediaRule, conditions);
					this.transformSelectors(root, mediaRule, conditions);
				}
				this.transformLayer(root, mediaRule["@layer"], conditions);
				this.transformSupports(root, mediaRule["@supports"], conditions);
				this.transformContainer(root, mediaRule["@container"], conditions);
				this.transformStartingStyle(root, mediaRule["@starting-style"], conditions);
			}
		}
	}
	transformContainer(root, rules) {
		var parentConditions = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
		if (rules) {
			var _this$currConditional2;
			(_this$currConditional2 = this.currConditionalRuleset) === null || _this$currConditional2 === void 0 || _this$currConditional2.addConditionPrecedence(parentConditions, Object.keys(rules).map((query) => "@container ".concat(query)));
			forEach(rules, (containerRule, query) => {
				var containerQuery = "@container ".concat(query);
				var conditions = [...parentConditions, containerQuery];
				this.addConditionalRule({
					selector: root.selector,
					rule: omit(containerRule, specialKeys)
				}, conditions);
				if (root.type === "local") {
					this.transformSimplePseudos(root, containerRule, conditions);
					this.transformSelectors(root, containerRule, conditions);
				}
				this.transformLayer(root, containerRule["@layer"], conditions);
				this.transformSupports(root, containerRule["@supports"], conditions);
				this.transformMedia(root, containerRule["@media"], conditions);
				this.transformStartingStyle(root, containerRule["@starting-style"], conditions);
			});
		}
	}
	transformLayer(root, rules) {
		var parentConditions = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
		if (rules) {
			var _this$currConditional3;
			(_this$currConditional3 = this.currConditionalRuleset) === null || _this$currConditional3 === void 0 || _this$currConditional3.addConditionPrecedence(parentConditions, Object.keys(rules).map((name) => "@layer ".concat(name)));
			forEach(rules, (layerRule, name) => {
				var conditions = [...parentConditions, "@layer ".concat(name)];
				this.addLayer(conditions);
				this.addConditionalRule({
					selector: root.selector,
					rule: omit(layerRule, specialKeys)
				}, conditions);
				if (root.type === "local") {
					this.transformSimplePseudos(root, layerRule, conditions);
					this.transformSelectors(root, layerRule, conditions);
				}
				this.transformMedia(root, layerRule["@media"], conditions);
				this.transformSupports(root, layerRule["@supports"], conditions);
				this.transformContainer(root, layerRule["@container"], conditions);
				this.transformStartingStyle(root, layerRule["@starting-style"], conditions);
			});
		}
	}
	transformSupports(root, rules) {
		var parentConditions = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
		if (rules) {
			var _this$currConditional4;
			(_this$currConditional4 = this.currConditionalRuleset) === null || _this$currConditional4 === void 0 || _this$currConditional4.addConditionPrecedence(parentConditions, Object.keys(rules).map((query) => "@supports ".concat(query)));
			forEach(rules, (supportsRule, query) => {
				var conditions = [...parentConditions, "@supports ".concat(query)];
				this.addConditionalRule({
					selector: root.selector,
					rule: omit(supportsRule, specialKeys)
				}, conditions);
				if (root.type === "local") {
					this.transformSimplePseudos(root, supportsRule, conditions);
					this.transformSelectors(root, supportsRule, conditions);
				}
				this.transformLayer(root, supportsRule["@layer"], conditions);
				this.transformMedia(root, supportsRule["@media"], conditions);
				this.transformContainer(root, supportsRule["@container"], conditions);
				this.transformStartingStyle(root, supportsRule["@starting-style"], conditions);
			});
		}
	}
	transformSimplePseudos(root, rule, conditions) {
		for (var key of Object.keys(rule)) if (simplePseudoLookup[key]) {
			if (root.type !== "local") throw new Error("Simple pseudos are not valid in ".concat(root.type === "global" ? "\"globalStyle\"" : "\"selectors\""));
			if (conditions) this.addConditionalRule({
				selector: "".concat(root.selector).concat(key),
				rule: rule[key]
			}, conditions);
			else this.addRule({
				conditions,
				selector: "".concat(root.selector).concat(key),
				rule: rule[key]
			});
		}
	}
	transformStartingStyle(root, rules) {
		var parentConditions = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
		if (rules) {
			var _this$currConditional5;
			var nestedAtRuleKey = Object.keys(rules).find((key) => key.startsWith("@"));
			if (nestedAtRuleKey) throw new Error("Nested at-rules (e.g. \"".concat(nestedAtRuleKey, "\") are not allowed inside @starting-style."));
			(_this$currConditional5 = this.currConditionalRuleset) === null || _this$currConditional5 === void 0 || _this$currConditional5.addConditionPrecedence(parentConditions, ["@starting-style"]);
			var conditions = [...parentConditions, "@starting-style"];
			this.addConditionalRule({
				selector: root.selector,
				rule: omit(rules, specialKeys)
			}, conditions);
			if (root.type === "local") {
				this.transformSimplePseudos(root, rules, conditions);
				this.transformSelectors(root, rules, conditions);
			}
		}
	}
	toCss() {
		var css = [];
		for (var fontFaceRule of this.fontFaceRules) css.push(renderCss({ "@font-face": fontFaceRule }));
		for (var property of this.propertyRules) css.push(renderCss({ ["@property ".concat(property.name)]: property.rule }));
		for (var keyframe of this.keyframesRules) css.push(renderCss({ ["@keyframes ".concat(keyframe.name)]: keyframe.rule }));
		for (var layer of this.layers.values()) {
			var [definition, ...nesting] = layer.reverse();
			var cssObj = { [definition]: DECLARATION };
			for (var part of nesting) cssObj = { [part]: cssObj };
			css.push(renderCss(cssObj));
		}
		for (var rule of this.rules) css.push(renderCss({ [rule.selector]: rule.rule }));
		for (var conditionalRuleset of this.conditionalRulesets) for (var conditionalRule of conditionalRuleset.renderToArray()) css.push(renderCss(conditionalRule));
		return css.filter(Boolean);
	}
};
function renderCss(v) {
	var indent = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
	var rules = [];
	var _loop2 = function _loop2$1(key$1) {
		var value = v[key$1];
		if (value && Array.isArray(value)) rules.push(...value.map((v$1) => renderCss({ [key$1]: v$1 }, indent)));
		else if (value && typeof value === "object") {
			if (!(Object.keys(value).length === 0)) rules.push("".concat(indent).concat(key$1, " {\n").concat(renderCss(value, indent + DOUBLE_SPACE), "\n").concat(indent, "}"));
		} else if (value === DECLARATION) rules.push("".concat(indent).concat(key$1, ";"));
		else rules.push("".concat(indent).concat(key$1.startsWith("--") ? key$1 : dashify(key$1), ": ").concat(value, ";"));
	};
	for (var key of Object.keys(v)) _loop2(key);
	return rules.join("\n");
}
function transformCss(_ref5) {
	var { localClassNames: localClassNames$1, cssObjs, composedClassLists: composedClassLists$1 } = _ref5;
	var stylesheet = new Stylesheet(localClassNames$1, composedClassLists$1);
	for (var root of cssObjs) stylesheet.processCssObj(root);
	return stylesheet.toCss();
}

//#endregion
//#region node_modules/.pnpm/lru-cache@10.4.3/node_modules/lru-cache/dist/esm/index.js
/**
* @module LRUCache
*/
var perf = typeof performance === "object" && performance && typeof performance.now === "function" ? performance : Date;
var warned = /* @__PURE__ */ new Set();
/* c8 ignore start */
var PROCESS = typeof process === "object" && !!process ? process : {};
/* c8 ignore start */
var emitWarning = (msg, type, code, fn) => {
	typeof PROCESS.emitWarning === "function" ? PROCESS.emitWarning(msg, type, code, fn) : console.error(`[${code}] ${type}: ${msg}`);
};
var AC = globalThis.AbortController;
var AS = globalThis.AbortSignal;
/* c8 ignore start */
if (typeof AC === "undefined") {
	AS = class AbortSignal {
		onabort;
		_onabort = [];
		reason;
		aborted = false;
		addEventListener(_, fn) {
			this._onabort.push(fn);
		}
	};
	AC = class AbortController {
		constructor() {
			warnACPolyfill();
		}
		signal = new AS();
		abort(reason) {
			if (this.signal.aborted) return;
			this.signal.reason = reason;
			this.signal.aborted = true;
			for (const fn of this.signal._onabort) fn(reason);
			this.signal.onabort?.(reason);
		}
	};
	let printACPolyfillWarning = PROCESS.env?.LRU_CACHE_IGNORE_AC_WARNING !== "1";
	const warnACPolyfill = () => {
		if (!printACPolyfillWarning) return;
		printACPolyfillWarning = false;
		emitWarning("AbortController is not defined. If using lru-cache in node 14, load an AbortController polyfill from the `node-abort-controller` package. A minimal polyfill is provided for use by LRUCache.fetch(), but it should not be relied upon in other contexts (eg, passing it to other APIs that use AbortController/AbortSignal might have undesirable effects). You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.", "NO_ABORT_CONTROLLER", "ENOTSUP", warnACPolyfill);
	};
}
/* c8 ignore stop */
var shouldWarn = (code) => !warned.has(code);
var isPosInt = (n) => n && n === Math.floor(n) && n > 0 && isFinite(n);
/* c8 ignore start */
var getUintArray = (max) => !isPosInt(max) ? null : max <= Math.pow(2, 8) ? Uint8Array : max <= Math.pow(2, 16) ? Uint16Array : max <= Math.pow(2, 32) ? Uint32Array : max <= Number.MAX_SAFE_INTEGER ? ZeroArray : null;
/* c8 ignore stop */
var ZeroArray = class extends Array {
	constructor(size) {
		super(size);
		this.fill(0);
	}
};
var Stack = class Stack {
	heap;
	length;
	static #constructing = false;
	static create(max) {
		const HeapCls = getUintArray(max);
		if (!HeapCls) return [];
		Stack.#constructing = true;
		const s = new Stack(max, HeapCls);
		Stack.#constructing = false;
		return s;
	}
	constructor(max, HeapCls) {
		/* c8 ignore start */
		if (!Stack.#constructing) throw new TypeError("instantiate Stack using Stack.create(n)");
		/* c8 ignore stop */
		this.heap = new HeapCls(max);
		this.length = 0;
	}
	push(n) {
		this.heap[this.length++] = n;
	}
	pop() {
		return this.heap[--this.length];
	}
};
/**
* Default export, the thing you're using this module to get.
*
* The `K` and `V` types define the key and value types, respectively. The
* optional `FC` type defines the type of the `context` object passed to
* `cache.fetch()` and `cache.memo()`.
*
* Keys and values **must not** be `null` or `undefined`.
*
* All properties from the options object (with the exception of `max`,
* `maxSize`, `fetchMethod`, `memoMethod`, `dispose` and `disposeAfter`) are
* added as normal public members. (The listed options are read-only getters.)
*
* Changing any of these will alter the defaults for subsequent method calls.
*/
var LRUCache = class LRUCache {
	#max;
	#maxSize;
	#dispose;
	#disposeAfter;
	#fetchMethod;
	#memoMethod;
	/**
	* {@link LRUCache.OptionsBase.ttl}
	*/
	ttl;
	/**
	* {@link LRUCache.OptionsBase.ttlResolution}
	*/
	ttlResolution;
	/**
	* {@link LRUCache.OptionsBase.ttlAutopurge}
	*/
	ttlAutopurge;
	/**
	* {@link LRUCache.OptionsBase.updateAgeOnGet}
	*/
	updateAgeOnGet;
	/**
	* {@link LRUCache.OptionsBase.updateAgeOnHas}
	*/
	updateAgeOnHas;
	/**
	* {@link LRUCache.OptionsBase.allowStale}
	*/
	allowStale;
	/**
	* {@link LRUCache.OptionsBase.noDisposeOnSet}
	*/
	noDisposeOnSet;
	/**
	* {@link LRUCache.OptionsBase.noUpdateTTL}
	*/
	noUpdateTTL;
	/**
	* {@link LRUCache.OptionsBase.maxEntrySize}
	*/
	maxEntrySize;
	/**
	* {@link LRUCache.OptionsBase.sizeCalculation}
	*/
	sizeCalculation;
	/**
	* {@link LRUCache.OptionsBase.noDeleteOnFetchRejection}
	*/
	noDeleteOnFetchRejection;
	/**
	* {@link LRUCache.OptionsBase.noDeleteOnStaleGet}
	*/
	noDeleteOnStaleGet;
	/**
	* {@link LRUCache.OptionsBase.allowStaleOnFetchAbort}
	*/
	allowStaleOnFetchAbort;
	/**
	* {@link LRUCache.OptionsBase.allowStaleOnFetchRejection}
	*/
	allowStaleOnFetchRejection;
	/**
	* {@link LRUCache.OptionsBase.ignoreFetchAbort}
	*/
	ignoreFetchAbort;
	#size;
	#calculatedSize;
	#keyMap;
	#keyList;
	#valList;
	#next;
	#prev;
	#head;
	#tail;
	#free;
	#disposed;
	#sizes;
	#starts;
	#ttls;
	#hasDispose;
	#hasFetchMethod;
	#hasDisposeAfter;
	/**
	* Do not call this method unless you need to inspect the
	* inner workings of the cache.  If anything returned by this
	* object is modified in any way, strange breakage may occur.
	*
	* These fields are private for a reason!
	*
	* @internal
	*/
	static unsafeExposeInternals(c) {
		return {
			starts: c.#starts,
			ttls: c.#ttls,
			sizes: c.#sizes,
			keyMap: c.#keyMap,
			keyList: c.#keyList,
			valList: c.#valList,
			next: c.#next,
			prev: c.#prev,
			get head() {
				return c.#head;
			},
			get tail() {
				return c.#tail;
			},
			free: c.#free,
			isBackgroundFetch: (p) => c.#isBackgroundFetch(p),
			backgroundFetch: (k, index, options, context) => c.#backgroundFetch(k, index, options, context),
			moveToTail: (index) => c.#moveToTail(index),
			indexes: (options) => c.#indexes(options),
			rindexes: (options) => c.#rindexes(options),
			isStale: (index) => c.#isStale(index)
		};
	}
	/**
	* {@link LRUCache.OptionsBase.max} (read-only)
	*/
	get max() {
		return this.#max;
	}
	/**
	* {@link LRUCache.OptionsBase.maxSize} (read-only)
	*/
	get maxSize() {
		return this.#maxSize;
	}
	/**
	* The total computed size of items in the cache (read-only)
	*/
	get calculatedSize() {
		return this.#calculatedSize;
	}
	/**
	* The number of items stored in the cache (read-only)
	*/
	get size() {
		return this.#size;
	}
	/**
	* {@link LRUCache.OptionsBase.fetchMethod} (read-only)
	*/
	get fetchMethod() {
		return this.#fetchMethod;
	}
	get memoMethod() {
		return this.#memoMethod;
	}
	/**
	* {@link LRUCache.OptionsBase.dispose} (read-only)
	*/
	get dispose() {
		return this.#dispose;
	}
	/**
	* {@link LRUCache.OptionsBase.disposeAfter} (read-only)
	*/
	get disposeAfter() {
		return this.#disposeAfter;
	}
	constructor(options) {
		const { max = 0, ttl, ttlResolution = 1, ttlAutopurge, updateAgeOnGet, updateAgeOnHas, allowStale, dispose, disposeAfter, noDisposeOnSet, noUpdateTTL, maxSize = 0, maxEntrySize = 0, sizeCalculation, fetchMethod, memoMethod, noDeleteOnFetchRejection, noDeleteOnStaleGet, allowStaleOnFetchRejection, allowStaleOnFetchAbort, ignoreFetchAbort } = options;
		if (max !== 0 && !isPosInt(max)) throw new TypeError("max option must be a nonnegative integer");
		const UintArray = max ? getUintArray(max) : Array;
		if (!UintArray) throw new Error("invalid max value: " + max);
		this.#max = max;
		this.#maxSize = maxSize;
		this.maxEntrySize = maxEntrySize || this.#maxSize;
		this.sizeCalculation = sizeCalculation;
		if (this.sizeCalculation) {
			if (!this.#maxSize && !this.maxEntrySize) throw new TypeError("cannot set sizeCalculation without setting maxSize or maxEntrySize");
			if (typeof this.sizeCalculation !== "function") throw new TypeError("sizeCalculation set to non-function");
		}
		if (memoMethod !== void 0 && typeof memoMethod !== "function") throw new TypeError("memoMethod must be a function if defined");
		this.#memoMethod = memoMethod;
		if (fetchMethod !== void 0 && typeof fetchMethod !== "function") throw new TypeError("fetchMethod must be a function if specified");
		this.#fetchMethod = fetchMethod;
		this.#hasFetchMethod = !!fetchMethod;
		this.#keyMap = /* @__PURE__ */ new Map();
		this.#keyList = new Array(max).fill(void 0);
		this.#valList = new Array(max).fill(void 0);
		this.#next = new UintArray(max);
		this.#prev = new UintArray(max);
		this.#head = 0;
		this.#tail = 0;
		this.#free = Stack.create(max);
		this.#size = 0;
		this.#calculatedSize = 0;
		if (typeof dispose === "function") this.#dispose = dispose;
		if (typeof disposeAfter === "function") {
			this.#disposeAfter = disposeAfter;
			this.#disposed = [];
		} else {
			this.#disposeAfter = void 0;
			this.#disposed = void 0;
		}
		this.#hasDispose = !!this.#dispose;
		this.#hasDisposeAfter = !!this.#disposeAfter;
		this.noDisposeOnSet = !!noDisposeOnSet;
		this.noUpdateTTL = !!noUpdateTTL;
		this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection;
		this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection;
		this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort;
		this.ignoreFetchAbort = !!ignoreFetchAbort;
		if (this.maxEntrySize !== 0) {
			if (this.#maxSize !== 0) {
				if (!isPosInt(this.#maxSize)) throw new TypeError("maxSize must be a positive integer if specified");
			}
			if (!isPosInt(this.maxEntrySize)) throw new TypeError("maxEntrySize must be a positive integer if specified");
			this.#initializeSizeTracking();
		}
		this.allowStale = !!allowStale;
		this.noDeleteOnStaleGet = !!noDeleteOnStaleGet;
		this.updateAgeOnGet = !!updateAgeOnGet;
		this.updateAgeOnHas = !!updateAgeOnHas;
		this.ttlResolution = isPosInt(ttlResolution) || ttlResolution === 0 ? ttlResolution : 1;
		this.ttlAutopurge = !!ttlAutopurge;
		this.ttl = ttl || 0;
		if (this.ttl) {
			if (!isPosInt(this.ttl)) throw new TypeError("ttl must be a positive integer if specified");
			this.#initializeTTLTracking();
		}
		if (this.#max === 0 && this.ttl === 0 && this.#maxSize === 0) throw new TypeError("At least one of max, maxSize, or ttl is required");
		if (!this.ttlAutopurge && !this.#max && !this.#maxSize) {
			const code = "LRU_CACHE_UNBOUNDED";
			if (shouldWarn(code)) {
				warned.add(code);
				emitWarning("TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.", "UnboundedCacheWarning", code, LRUCache);
			}
		}
	}
	/**
	* Return the number of ms left in the item's TTL. If item is not in cache,
	* returns `0`. Returns `Infinity` if item is in cache without a defined TTL.
	*/
	getRemainingTTL(key) {
		return this.#keyMap.has(key) ? Infinity : 0;
	}
	#initializeTTLTracking() {
		const ttls = new ZeroArray(this.#max);
		const starts = new ZeroArray(this.#max);
		this.#ttls = ttls;
		this.#starts = starts;
		this.#setItemTTL = (index, ttl, start = perf.now()) => {
			starts[index] = ttl !== 0 ? start : 0;
			ttls[index] = ttl;
			if (ttl !== 0 && this.ttlAutopurge) {
				const t = setTimeout(() => {
					if (this.#isStale(index)) this.#delete(this.#keyList[index], "expire");
				}, ttl + 1);
				/* c8 ignore start */
				if (t.unref) t.unref();
			}
		};
		this.#updateItemAge = (index) => {
			starts[index] = ttls[index] !== 0 ? perf.now() : 0;
		};
		this.#statusTTL = (status, index) => {
			if (ttls[index]) {
				const ttl = ttls[index];
				const start = starts[index];
				/* c8 ignore next */
				if (!ttl || !start) return;
				status.ttl = ttl;
				status.start = start;
				status.now = cachedNow || getNow();
				status.remainingTTL = ttl - (status.now - start);
			}
		};
		let cachedNow = 0;
		const getNow = () => {
			const n = perf.now();
			if (this.ttlResolution > 0) {
				cachedNow = n;
				const t = setTimeout(() => cachedNow = 0, this.ttlResolution);
				/* c8 ignore start */
				if (t.unref) t.unref();
			}
			return n;
		};
		this.getRemainingTTL = (key) => {
			const index = this.#keyMap.get(key);
			if (index === void 0) return 0;
			const ttl = ttls[index];
			const start = starts[index];
			if (!ttl || !start) return Infinity;
			return ttl - ((cachedNow || getNow()) - start);
		};
		this.#isStale = (index) => {
			const s = starts[index];
			const t = ttls[index];
			return !!t && !!s && (cachedNow || getNow()) - s > t;
		};
	}
	#updateItemAge = () => {};
	#statusTTL = () => {};
	#setItemTTL = () => {};
	/* c8 ignore stop */
	#isStale = () => false;
	#initializeSizeTracking() {
		const sizes = new ZeroArray(this.#max);
		this.#calculatedSize = 0;
		this.#sizes = sizes;
		this.#removeItemSize = (index) => {
			this.#calculatedSize -= sizes[index];
			sizes[index] = 0;
		};
		this.#requireSize = (k, v, size, sizeCalculation) => {
			if (this.#isBackgroundFetch(v)) return 0;
			if (!isPosInt(size)) if (sizeCalculation) {
				if (typeof sizeCalculation !== "function") throw new TypeError("sizeCalculation must be a function");
				size = sizeCalculation(v, k);
				if (!isPosInt(size)) throw new TypeError("sizeCalculation return invalid (expect positive integer)");
			} else throw new TypeError("invalid size value (must be positive integer). When maxSize or maxEntrySize is used, sizeCalculation or size must be set.");
			return size;
		};
		this.#addItemSize = (index, size, status) => {
			sizes[index] = size;
			if (this.#maxSize) {
				const maxSize = this.#maxSize - sizes[index];
				while (this.#calculatedSize > maxSize) this.#evict(true);
			}
			this.#calculatedSize += sizes[index];
			if (status) {
				status.entrySize = size;
				status.totalCalculatedSize = this.#calculatedSize;
			}
		};
	}
	#removeItemSize = (_i) => {};
	#addItemSize = (_i, _s, _st) => {};
	#requireSize = (_k, _v, size, sizeCalculation) => {
		if (size || sizeCalculation) throw new TypeError("cannot set size without setting maxSize or maxEntrySize on cache");
		return 0;
	};
	*#indexes({ allowStale = this.allowStale } = {}) {
		if (this.#size) for (let i = this.#tail;;) {
			if (!this.#isValidIndex(i)) break;
			if (allowStale || !this.#isStale(i)) yield i;
			if (i === this.#head) break;
			else i = this.#prev[i];
		}
	}
	*#rindexes({ allowStale = this.allowStale } = {}) {
		if (this.#size) for (let i = this.#head;;) {
			if (!this.#isValidIndex(i)) break;
			if (allowStale || !this.#isStale(i)) yield i;
			if (i === this.#tail) break;
			else i = this.#next[i];
		}
	}
	#isValidIndex(index) {
		return index !== void 0 && this.#keyMap.get(this.#keyList[index]) === index;
	}
	/**
	* Return a generator yielding `[key, value]` pairs,
	* in order from most recently used to least recently used.
	*/
	*entries() {
		for (const i of this.#indexes()) if (this.#valList[i] !== void 0 && this.#keyList[i] !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) yield [this.#keyList[i], this.#valList[i]];
	}
	/**
	* Inverse order version of {@link LRUCache.entries}
	*
	* Return a generator yielding `[key, value]` pairs,
	* in order from least recently used to most recently used.
	*/
	*rentries() {
		for (const i of this.#rindexes()) if (this.#valList[i] !== void 0 && this.#keyList[i] !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) yield [this.#keyList[i], this.#valList[i]];
	}
	/**
	* Return a generator yielding the keys in the cache,
	* in order from most recently used to least recently used.
	*/
	*keys() {
		for (const i of this.#indexes()) {
			const k = this.#keyList[i];
			if (k !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) yield k;
		}
	}
	/**
	* Inverse order version of {@link LRUCache.keys}
	*
	* Return a generator yielding the keys in the cache,
	* in order from least recently used to most recently used.
	*/
	*rkeys() {
		for (const i of this.#rindexes()) {
			const k = this.#keyList[i];
			if (k !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) yield k;
		}
	}
	/**
	* Return a generator yielding the values in the cache,
	* in order from most recently used to least recently used.
	*/
	*values() {
		for (const i of this.#indexes()) if (this.#valList[i] !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) yield this.#valList[i];
	}
	/**
	* Inverse order version of {@link LRUCache.values}
	*
	* Return a generator yielding the values in the cache,
	* in order from least recently used to most recently used.
	*/
	*rvalues() {
		for (const i of this.#rindexes()) if (this.#valList[i] !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) yield this.#valList[i];
	}
	/**
	* Iterating over the cache itself yields the same results as
	* {@link LRUCache.entries}
	*/
	[Symbol.iterator]() {
		return this.entries();
	}
	/**
	* A String value that is used in the creation of the default string
	* description of an object. Called by the built-in method
	* `Object.prototype.toString`.
	*/
	[Symbol.toStringTag] = "LRUCache";
	/**
	* Find a value for which the supplied fn method returns a truthy value,
	* similar to `Array.find()`. fn is called as `fn(value, key, cache)`.
	*/
	find(fn, getOptions = {}) {
		for (const i of this.#indexes()) {
			const v = this.#valList[i];
			const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
			if (value === void 0) continue;
			if (fn(value, this.#keyList[i], this)) return this.get(this.#keyList[i], getOptions);
		}
	}
	/**
	* Call the supplied function on each item in the cache, in order from most
	* recently used to least recently used.
	*
	* `fn` is called as `fn(value, key, cache)`.
	*
	* If `thisp` is provided, function will be called in the `this`-context of
	* the provided object, or the cache if no `thisp` object is provided.
	*
	* Does not update age or recenty of use, or iterate over stale values.
	*/
	forEach(fn, thisp = this) {
		for (const i of this.#indexes()) {
			const v = this.#valList[i];
			const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
			if (value === void 0) continue;
			fn.call(thisp, value, this.#keyList[i], this);
		}
	}
	/**
	* The same as {@link LRUCache.forEach} but items are iterated over in
	* reverse order.  (ie, less recently used items are iterated over first.)
	*/
	rforEach(fn, thisp = this) {
		for (const i of this.#rindexes()) {
			const v = this.#valList[i];
			const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
			if (value === void 0) continue;
			fn.call(thisp, value, this.#keyList[i], this);
		}
	}
	/**
	* Delete any stale entries. Returns true if anything was removed,
	* false otherwise.
	*/
	purgeStale() {
		let deleted = false;
		for (const i of this.#rindexes({ allowStale: true })) if (this.#isStale(i)) {
			this.#delete(this.#keyList[i], "expire");
			deleted = true;
		}
		return deleted;
	}
	/**
	* Get the extended info about a given entry, to get its value, size, and
	* TTL info simultaneously. Returns `undefined` if the key is not present.
	*
	* Unlike {@link LRUCache#dump}, which is designed to be portable and survive
	* serialization, the `start` value is always the current timestamp, and the
	* `ttl` is a calculated remaining time to live (negative if expired).
	*
	* Always returns stale values, if their info is found in the cache, so be
	* sure to check for expirations (ie, a negative {@link LRUCache.Entry#ttl})
	* if relevant.
	*/
	info(key) {
		const i = this.#keyMap.get(key);
		if (i === void 0) return void 0;
		const v = this.#valList[i];
		const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
		if (value === void 0) return void 0;
		const entry = { value };
		if (this.#ttls && this.#starts) {
			const ttl = this.#ttls[i];
			const start = this.#starts[i];
			if (ttl && start) {
				entry.ttl = ttl - (perf.now() - start);
				entry.start = Date.now();
			}
		}
		if (this.#sizes) entry.size = this.#sizes[i];
		return entry;
	}
	/**
	* Return an array of [key, {@link LRUCache.Entry}] tuples which can be
	* passed to {@link LRLUCache#load}.
	*
	* The `start` fields are calculated relative to a portable `Date.now()`
	* timestamp, even if `performance.now()` is available.
	*
	* Stale entries are always included in the `dump`, even if
	* {@link LRUCache.OptionsBase.allowStale} is false.
	*
	* Note: this returns an actual array, not a generator, so it can be more
	* easily passed around.
	*/
	dump() {
		const arr = [];
		for (const i of this.#indexes({ allowStale: true })) {
			const key = this.#keyList[i];
			const v = this.#valList[i];
			const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
			if (value === void 0 || key === void 0) continue;
			const entry = { value };
			if (this.#ttls && this.#starts) {
				entry.ttl = this.#ttls[i];
				const age = perf.now() - this.#starts[i];
				entry.start = Math.floor(Date.now() - age);
			}
			if (this.#sizes) entry.size = this.#sizes[i];
			arr.unshift([key, entry]);
		}
		return arr;
	}
	/**
	* Reset the cache and load in the items in entries in the order listed.
	*
	* The shape of the resulting cache may be different if the same options are
	* not used in both caches.
	*
	* The `start` fields are assumed to be calculated relative to a portable
	* `Date.now()` timestamp, even if `performance.now()` is available.
	*/
	load(arr) {
		this.clear();
		for (const [key, entry] of arr) {
			if (entry.start) {
				const age = Date.now() - entry.start;
				entry.start = perf.now() - age;
			}
			this.set(key, entry.value, entry);
		}
	}
	/**
	* Add a value to the cache.
	*
	* Note: if `undefined` is specified as a value, this is an alias for
	* {@link LRUCache#delete}
	*
	* Fields on the {@link LRUCache.SetOptions} options param will override
	* their corresponding values in the constructor options for the scope
	* of this single `set()` operation.
	*
	* If `start` is provided, then that will set the effective start
	* time for the TTL calculation. Note that this must be a previous
	* value of `performance.now()` if supported, or a previous value of
	* `Date.now()` if not.
	*
	* Options object may also include `size`, which will prevent
	* calling the `sizeCalculation` function and just use the specified
	* number if it is a positive integer, and `noDisposeOnSet` which
	* will prevent calling a `dispose` function in the case of
	* overwrites.
	*
	* If the `size` (or return value of `sizeCalculation`) for a given
	* entry is greater than `maxEntrySize`, then the item will not be
	* added to the cache.
	*
	* Will update the recency of the entry.
	*
	* If the value is `undefined`, then this is an alias for
	* `cache.delete(key)`. `undefined` is never stored in the cache.
	*/
	set(k, v, setOptions = {}) {
		if (v === void 0) {
			this.delete(k);
			return this;
		}
		const { ttl = this.ttl, start, noDisposeOnSet = this.noDisposeOnSet, sizeCalculation = this.sizeCalculation, status } = setOptions;
		let { noUpdateTTL = this.noUpdateTTL } = setOptions;
		const size = this.#requireSize(k, v, setOptions.size || 0, sizeCalculation);
		if (this.maxEntrySize && size > this.maxEntrySize) {
			if (status) {
				status.set = "miss";
				status.maxEntrySizeExceeded = true;
			}
			this.#delete(k, "set");
			return this;
		}
		let index = this.#size === 0 ? void 0 : this.#keyMap.get(k);
		if (index === void 0) {
			index = this.#size === 0 ? this.#tail : this.#free.length !== 0 ? this.#free.pop() : this.#size === this.#max ? this.#evict(false) : this.#size;
			this.#keyList[index] = k;
			this.#valList[index] = v;
			this.#keyMap.set(k, index);
			this.#next[this.#tail] = index;
			this.#prev[index] = this.#tail;
			this.#tail = index;
			this.#size++;
			this.#addItemSize(index, size, status);
			if (status) status.set = "add";
			noUpdateTTL = false;
		} else {
			this.#moveToTail(index);
			const oldVal = this.#valList[index];
			if (v !== oldVal) {
				if (this.#hasFetchMethod && this.#isBackgroundFetch(oldVal)) {
					oldVal.__abortController.abort(/* @__PURE__ */ new Error("replaced"));
					const { __staleWhileFetching: s } = oldVal;
					if (s !== void 0 && !noDisposeOnSet) {
						if (this.#hasDispose) this.#dispose?.(s, k, "set");
						if (this.#hasDisposeAfter) this.#disposed?.push([
							s,
							k,
							"set"
						]);
					}
				} else if (!noDisposeOnSet) {
					if (this.#hasDispose) this.#dispose?.(oldVal, k, "set");
					if (this.#hasDisposeAfter) this.#disposed?.push([
						oldVal,
						k,
						"set"
					]);
				}
				this.#removeItemSize(index);
				this.#addItemSize(index, size, status);
				this.#valList[index] = v;
				if (status) {
					status.set = "replace";
					const oldValue = oldVal && this.#isBackgroundFetch(oldVal) ? oldVal.__staleWhileFetching : oldVal;
					if (oldValue !== void 0) status.oldValue = oldValue;
				}
			} else if (status) status.set = "update";
		}
		if (ttl !== 0 && !this.#ttls) this.#initializeTTLTracking();
		if (this.#ttls) {
			if (!noUpdateTTL) this.#setItemTTL(index, ttl, start);
			if (status) this.#statusTTL(status, index);
		}
		if (!noDisposeOnSet && this.#hasDisposeAfter && this.#disposed) {
			const dt = this.#disposed;
			let task;
			while (task = dt?.shift()) this.#disposeAfter?.(...task);
		}
		return this;
	}
	/**
	* Evict the least recently used item, returning its value or
	* `undefined` if cache is empty.
	*/
	pop() {
		try {
			while (this.#size) {
				const val = this.#valList[this.#head];
				this.#evict(true);
				if (this.#isBackgroundFetch(val)) {
					if (val.__staleWhileFetching) return val.__staleWhileFetching;
				} else if (val !== void 0) return val;
			}
		} finally {
			if (this.#hasDisposeAfter && this.#disposed) {
				const dt = this.#disposed;
				let task;
				while (task = dt?.shift()) this.#disposeAfter?.(...task);
			}
		}
	}
	#evict(free) {
		const head = this.#head;
		const k = this.#keyList[head];
		const v = this.#valList[head];
		if (this.#hasFetchMethod && this.#isBackgroundFetch(v)) v.__abortController.abort(/* @__PURE__ */ new Error("evicted"));
		else if (this.#hasDispose || this.#hasDisposeAfter) {
			if (this.#hasDispose) this.#dispose?.(v, k, "evict");
			if (this.#hasDisposeAfter) this.#disposed?.push([
				v,
				k,
				"evict"
			]);
		}
		this.#removeItemSize(head);
		if (free) {
			this.#keyList[head] = void 0;
			this.#valList[head] = void 0;
			this.#free.push(head);
		}
		if (this.#size === 1) {
			this.#head = this.#tail = 0;
			this.#free.length = 0;
		} else this.#head = this.#next[head];
		this.#keyMap.delete(k);
		this.#size--;
		return head;
	}
	/**
	* Check if a key is in the cache, without updating the recency of use.
	* Will return false if the item is stale, even though it is technically
	* in the cache.
	*
	* Check if a key is in the cache, without updating the recency of
	* use. Age is updated if {@link LRUCache.OptionsBase.updateAgeOnHas} is set
	* to `true` in either the options or the constructor.
	*
	* Will return `false` if the item is stale, even though it is technically in
	* the cache. The difference can be determined (if it matters) by using a
	* `status` argument, and inspecting the `has` field.
	*
	* Will not update item age unless
	* {@link LRUCache.OptionsBase.updateAgeOnHas} is set.
	*/
	has(k, hasOptions = {}) {
		const { updateAgeOnHas = this.updateAgeOnHas, status } = hasOptions;
		const index = this.#keyMap.get(k);
		if (index !== void 0) {
			const v = this.#valList[index];
			if (this.#isBackgroundFetch(v) && v.__staleWhileFetching === void 0) return false;
			if (!this.#isStale(index)) {
				if (updateAgeOnHas) this.#updateItemAge(index);
				if (status) {
					status.has = "hit";
					this.#statusTTL(status, index);
				}
				return true;
			} else if (status) {
				status.has = "stale";
				this.#statusTTL(status, index);
			}
		} else if (status) status.has = "miss";
		return false;
	}
	/**
	* Like {@link LRUCache#get} but doesn't update recency or delete stale
	* items.
	*
	* Returns `undefined` if the item is stale, unless
	* {@link LRUCache.OptionsBase.allowStale} is set.
	*/
	peek(k, peekOptions = {}) {
		const { allowStale = this.allowStale } = peekOptions;
		const index = this.#keyMap.get(k);
		if (index === void 0 || !allowStale && this.#isStale(index)) return;
		const v = this.#valList[index];
		return this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
	}
	#backgroundFetch(k, index, options, context) {
		const v = index === void 0 ? void 0 : this.#valList[index];
		if (this.#isBackgroundFetch(v)) return v;
		const ac = new AC();
		const { signal } = options;
		signal?.addEventListener("abort", () => ac.abort(signal.reason), { signal: ac.signal });
		const fetchOpts = {
			signal: ac.signal,
			options,
			context
		};
		const cb = (v$1, updateCache = false) => {
			const { aborted } = ac.signal;
			const ignoreAbort = options.ignoreFetchAbort && v$1 !== void 0;
			if (options.status) if (aborted && !updateCache) {
				options.status.fetchAborted = true;
				options.status.fetchError = ac.signal.reason;
				if (ignoreAbort) options.status.fetchAbortIgnored = true;
			} else options.status.fetchResolved = true;
			if (aborted && !ignoreAbort && !updateCache) return fetchFail(ac.signal.reason);
			const bf$1 = p;
			if (this.#valList[index] === p) if (v$1 === void 0) if (bf$1.__staleWhileFetching) this.#valList[index] = bf$1.__staleWhileFetching;
			else this.#delete(k, "fetch");
			else {
				if (options.status) options.status.fetchUpdated = true;
				this.set(k, v$1, fetchOpts.options);
			}
			return v$1;
		};
		const eb = (er) => {
			if (options.status) {
				options.status.fetchRejected = true;
				options.status.fetchError = er;
			}
			return fetchFail(er);
		};
		const fetchFail = (er) => {
			const { aborted } = ac.signal;
			const allowStaleAborted = aborted && options.allowStaleOnFetchAbort;
			const allowStale = allowStaleAborted || options.allowStaleOnFetchRejection;
			const noDelete = allowStale || options.noDeleteOnFetchRejection;
			const bf$1 = p;
			if (this.#valList[index] === p) {
				if (!noDelete || bf$1.__staleWhileFetching === void 0) this.#delete(k, "fetch");
				else if (!allowStaleAborted) this.#valList[index] = bf$1.__staleWhileFetching;
			}
			if (allowStale) {
				if (options.status && bf$1.__staleWhileFetching !== void 0) options.status.returnedStale = true;
				return bf$1.__staleWhileFetching;
			} else if (bf$1.__returned === bf$1) throw er;
		};
		const pcall = (res, rej) => {
			const fmp = this.#fetchMethod?.(k, v, fetchOpts);
			if (fmp && fmp instanceof Promise) fmp.then((v$1) => res(v$1 === void 0 ? void 0 : v$1), rej);
			ac.signal.addEventListener("abort", () => {
				if (!options.ignoreFetchAbort || options.allowStaleOnFetchAbort) {
					res(void 0);
					if (options.allowStaleOnFetchAbort) res = (v$1) => cb(v$1, true);
				}
			});
		};
		if (options.status) options.status.fetchDispatched = true;
		const p = new Promise(pcall).then(cb, eb);
		const bf = Object.assign(p, {
			__abortController: ac,
			__staleWhileFetching: v,
			__returned: void 0
		});
		if (index === void 0) {
			this.set(k, bf, {
				...fetchOpts.options,
				status: void 0
			});
			index = this.#keyMap.get(k);
		} else this.#valList[index] = bf;
		return bf;
	}
	#isBackgroundFetch(p) {
		if (!this.#hasFetchMethod) return false;
		const b = p;
		return !!b && b instanceof Promise && b.hasOwnProperty("__staleWhileFetching") && b.__abortController instanceof AC;
	}
	async fetch(k, fetchOptions = {}) {
		const { allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, ttl = this.ttl, noDisposeOnSet = this.noDisposeOnSet, size = 0, sizeCalculation = this.sizeCalculation, noUpdateTTL = this.noUpdateTTL, noDeleteOnFetchRejection = this.noDeleteOnFetchRejection, allowStaleOnFetchRejection = this.allowStaleOnFetchRejection, ignoreFetchAbort = this.ignoreFetchAbort, allowStaleOnFetchAbort = this.allowStaleOnFetchAbort, context, forceRefresh = false, status, signal } = fetchOptions;
		if (!this.#hasFetchMethod) {
			if (status) status.fetch = "get";
			return this.get(k, {
				allowStale,
				updateAgeOnGet,
				noDeleteOnStaleGet,
				status
			});
		}
		const options = {
			allowStale,
			updateAgeOnGet,
			noDeleteOnStaleGet,
			ttl,
			noDisposeOnSet,
			size,
			sizeCalculation,
			noUpdateTTL,
			noDeleteOnFetchRejection,
			allowStaleOnFetchRejection,
			allowStaleOnFetchAbort,
			ignoreFetchAbort,
			status,
			signal
		};
		let index = this.#keyMap.get(k);
		if (index === void 0) {
			if (status) status.fetch = "miss";
			const p = this.#backgroundFetch(k, index, options, context);
			return p.__returned = p;
		} else {
			const v = this.#valList[index];
			if (this.#isBackgroundFetch(v)) {
				const stale = allowStale && v.__staleWhileFetching !== void 0;
				if (status) {
					status.fetch = "inflight";
					if (stale) status.returnedStale = true;
				}
				return stale ? v.__staleWhileFetching : v.__returned = v;
			}
			const isStale = this.#isStale(index);
			if (!forceRefresh && !isStale) {
				if (status) status.fetch = "hit";
				this.#moveToTail(index);
				if (updateAgeOnGet) this.#updateItemAge(index);
				if (status) this.#statusTTL(status, index);
				return v;
			}
			const p = this.#backgroundFetch(k, index, options, context);
			const staleVal = p.__staleWhileFetching !== void 0 && allowStale;
			if (status) {
				status.fetch = isStale ? "stale" : "refresh";
				if (staleVal && isStale) status.returnedStale = true;
			}
			return staleVal ? p.__staleWhileFetching : p.__returned = p;
		}
	}
	async forceFetch(k, fetchOptions = {}) {
		const v = await this.fetch(k, fetchOptions);
		if (v === void 0) throw new Error("fetch() returned undefined");
		return v;
	}
	memo(k, memoOptions = {}) {
		const memoMethod = this.#memoMethod;
		if (!memoMethod) throw new Error("no memoMethod provided to constructor");
		const { context, forceRefresh, ...options } = memoOptions;
		const v = this.get(k, options);
		if (!forceRefresh && v !== void 0) return v;
		const vv = memoMethod(k, v, {
			options,
			context
		});
		this.set(k, vv, options);
		return vv;
	}
	/**
	* Return a value from the cache. Will update the recency of the cache
	* entry found.
	*
	* If the key is not found, get() will return `undefined`.
	*/
	get(k, getOptions = {}) {
		const { allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, status } = getOptions;
		const index = this.#keyMap.get(k);
		if (index !== void 0) {
			const value = this.#valList[index];
			const fetching = this.#isBackgroundFetch(value);
			if (status) this.#statusTTL(status, index);
			if (this.#isStale(index)) {
				if (status) status.get = "stale";
				if (!fetching) {
					if (!noDeleteOnStaleGet) this.#delete(k, "expire");
					if (status && allowStale) status.returnedStale = true;
					return allowStale ? value : void 0;
				} else {
					if (status && allowStale && value.__staleWhileFetching !== void 0) status.returnedStale = true;
					return allowStale ? value.__staleWhileFetching : void 0;
				}
			} else {
				if (status) status.get = "hit";
				if (fetching) return value.__staleWhileFetching;
				this.#moveToTail(index);
				if (updateAgeOnGet) this.#updateItemAge(index);
				return value;
			}
		} else if (status) status.get = "miss";
	}
	#connect(p, n) {
		this.#prev[n] = p;
		this.#next[p] = n;
	}
	#moveToTail(index) {
		if (index !== this.#tail) {
			if (index === this.#head) this.#head = this.#next[index];
			else this.#connect(this.#prev[index], this.#next[index]);
			this.#connect(this.#tail, index);
			this.#tail = index;
		}
	}
	/**
	* Deletes a key out of the cache.
	*
	* Returns true if the key was deleted, false otherwise.
	*/
	delete(k) {
		return this.#delete(k, "delete");
	}
	#delete(k, reason) {
		let deleted = false;
		if (this.#size !== 0) {
			const index = this.#keyMap.get(k);
			if (index !== void 0) {
				deleted = true;
				if (this.#size === 1) this.#clear(reason);
				else {
					this.#removeItemSize(index);
					const v = this.#valList[index];
					if (this.#isBackgroundFetch(v)) v.__abortController.abort(/* @__PURE__ */ new Error("deleted"));
					else if (this.#hasDispose || this.#hasDisposeAfter) {
						if (this.#hasDispose) this.#dispose?.(v, k, reason);
						if (this.#hasDisposeAfter) this.#disposed?.push([
							v,
							k,
							reason
						]);
					}
					this.#keyMap.delete(k);
					this.#keyList[index] = void 0;
					this.#valList[index] = void 0;
					if (index === this.#tail) this.#tail = this.#prev[index];
					else if (index === this.#head) this.#head = this.#next[index];
					else {
						const pi = this.#prev[index];
						this.#next[pi] = this.#next[index];
						const ni = this.#next[index];
						this.#prev[ni] = this.#prev[index];
					}
					this.#size--;
					this.#free.push(index);
				}
			}
		}
		if (this.#hasDisposeAfter && this.#disposed?.length) {
			const dt = this.#disposed;
			let task;
			while (task = dt?.shift()) this.#disposeAfter?.(...task);
		}
		return deleted;
	}
	/**
	* Clear the cache entirely, throwing away all values.
	*/
	clear() {
		return this.#clear("delete");
	}
	#clear(reason) {
		for (const index of this.#rindexes({ allowStale: true })) {
			const v = this.#valList[index];
			if (this.#isBackgroundFetch(v)) v.__abortController.abort(/* @__PURE__ */ new Error("deleted"));
			else {
				const k = this.#keyList[index];
				if (this.#hasDispose) this.#dispose?.(v, k, reason);
				if (this.#hasDisposeAfter) this.#disposed?.push([
					v,
					k,
					reason
				]);
			}
		}
		this.#keyMap.clear();
		this.#valList.fill(void 0);
		this.#keyList.fill(void 0);
		if (this.#ttls && this.#starts) {
			this.#ttls.fill(0);
			this.#starts.fill(0);
		}
		if (this.#sizes) this.#sizes.fill(0);
		this.#head = 0;
		this.#tail = 0;
		this.#free.length = 0;
		this.#calculatedSize = 0;
		this.#size = 0;
		if (this.#hasDisposeAfter && this.#disposed) {
			const dt = this.#disposed;
			let task;
			while (task = dt?.shift()) this.#disposeAfter?.(...task);
		}
	}
};

//#endregion
//#region node_modules/.pnpm/picocolors@1.1.1/node_modules/picocolors/picocolors.browser.js
var require_picocolors_browser = /* @__PURE__ */ __commonJS$1({ "node_modules/.pnpm/picocolors@1.1.1/node_modules/picocolors/picocolors.browser.js": ((exports, module) => {
	var x = String;
	var create = function() {
		return {
			isColorSupported: false,
			reset: x,
			bold: x,
			dim: x,
			italic: x,
			underline: x,
			inverse: x,
			hidden: x,
			strikethrough: x,
			black: x,
			red: x,
			green: x,
			yellow: x,
			blue: x,
			magenta: x,
			cyan: x,
			white: x,
			gray: x,
			bgBlack: x,
			bgRed: x,
			bgGreen: x,
			bgYellow: x,
			bgBlue: x,
			bgMagenta: x,
			bgCyan: x,
			bgWhite: x,
			blackBright: x,
			redBright: x,
			greenBright: x,
			yellowBright: x,
			blueBright: x,
			magentaBright: x,
			cyanBright: x,
			whiteBright: x,
			bgBlackBright: x,
			bgRedBright: x,
			bgGreenBright: x,
			bgYellowBright: x,
			bgBlueBright: x,
			bgMagentaBright: x,
			bgCyanBright: x,
			bgWhiteBright: x
		};
	};
	module.exports = create();
	module.exports.createColors = create;
}) });

//#endregion
//#region node_modules/.pnpm/deepmerge@4.3.1/node_modules/deepmerge/dist/cjs.js
var require_cjs = /* @__PURE__ */ __commonJS$1({ "node_modules/.pnpm/deepmerge@4.3.1/node_modules/deepmerge/dist/cjs.js": ((exports, module) => {
	var isMergeableObject = function isMergeableObject$1(value) {
		return isNonNullObject(value) && !isSpecial(value);
	};
	function isNonNullObject(value) {
		return !!value && typeof value === "object";
	}
	function isSpecial(value) {
		var stringValue = Object.prototype.toString.call(value);
		return stringValue === "[object RegExp]" || stringValue === "[object Date]" || isReactElement(value);
	}
	var REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for ? Symbol.for("react.element") : 60103;
	function isReactElement(value) {
		return value.$$typeof === REACT_ELEMENT_TYPE;
	}
	function emptyTarget(val) {
		return Array.isArray(val) ? [] : {};
	}
	function cloneUnlessOtherwiseSpecified(value, options) {
		return options.clone !== false && options.isMergeableObject(value) ? deepmerge$1(emptyTarget(value), value, options) : value;
	}
	function defaultArrayMerge(target, source, options) {
		return target.concat(source).map(function(element) {
			return cloneUnlessOtherwiseSpecified(element, options);
		});
	}
	function getMergeFunction(key, options) {
		if (!options.customMerge) return deepmerge$1;
		var customMerge = options.customMerge(key);
		return typeof customMerge === "function" ? customMerge : deepmerge$1;
	}
	function getEnumerableOwnPropertySymbols(target) {
		return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(target).filter(function(symbol) {
			return Object.propertyIsEnumerable.call(target, symbol);
		}) : [];
	}
	function getKeys(target) {
		return Object.keys(target).concat(getEnumerableOwnPropertySymbols(target));
	}
	function propertyIsOnObject(object$1, property) {
		try {
			return property in object$1;
		} catch (_) {
			return false;
		}
	}
	function propertyIsUnsafe(target, key) {
		return propertyIsOnObject(target, key) && !(Object.hasOwnProperty.call(target, key) && Object.propertyIsEnumerable.call(target, key));
	}
	function mergeObject(target, source, options) {
		var destination = {};
		if (options.isMergeableObject(target)) getKeys(target).forEach(function(key) {
			destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);
		});
		getKeys(source).forEach(function(key) {
			if (propertyIsUnsafe(target, key)) return;
			if (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) destination[key] = getMergeFunction(key, options)(target[key], source[key], options);
			else destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);
		});
		return destination;
	}
	function deepmerge$1(target, source, options) {
		options = options || {};
		options.arrayMerge = options.arrayMerge || defaultArrayMerge;
		options.isMergeableObject = options.isMergeableObject || isMergeableObject;
		options.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;
		var sourceIsArray = Array.isArray(source);
		if (!(sourceIsArray === Array.isArray(target))) return cloneUnlessOtherwiseSpecified(source, options);
		else if (sourceIsArray) return options.arrayMerge(target, source, options);
		else return mergeObject(target, source, options);
	}
	deepmerge$1.all = function deepmergeAll(array$1, options) {
		if (!Array.isArray(array$1)) throw new Error("first argument should be an array");
		return array$1.reduce(function(prev, next) {
			return deepmerge$1(prev, next, options);
		}, {});
	};
	var deepmerge_1 = deepmerge$1;
	module.exports = deepmerge_1;
}) });

//#endregion
//#region node_modules/.pnpm/@vanilla-extract+css@1.18.0/node_modules/@vanilla-extract/css/dist/vanilla-extract-css.browser.esm.js
var import_cssesc = /* @__PURE__ */ __toESM$1(require_cssesc());
var import_picocolors_browser = /* @__PURE__ */ __toESM$1(require_picocolors_browser());
var import_cjs = /* @__PURE__ */ __toESM$1(require_cjs());
var localClassNames = /* @__PURE__ */ new Set();
var composedClassLists = [];
var bufferedCSSObjs = [];
setAdapterIfNotSet({
	appendCss: (cssObj) => {
		bufferedCSSObjs.push(cssObj);
	},
	registerClassName: (className) => {
		localClassNames.add(className);
	},
	registerComposition: (composition) => {
		composedClassLists.push(composition);
	},
	markCompositionUsed: () => {},
	onEndFileScope: (fileScope) => {
		injectStyles({
			fileScope,
			css: transformCss({
				localClassNames: Array.from(localClassNames),
				composedClassLists,
				cssObjs: bufferedCSSObjs
			}).join("\n")
		});
		bufferedCSSObjs = [];
	},
	getIdentOption: () => "debug"
});
var getLastSlashBeforeIndex = (path, index) => {
	var pathIndex = index - 1;
	while (pathIndex >= 0) {
		if (path[pathIndex] === "/") return pathIndex;
		pathIndex--;
	}
	return -1;
};
/**
* Assumptions:
* - The path is always normalized to use posix file separators (/) (see `addFileScope`)
* - The path is always relative to the project root, i.e. there will never be a leading slash (see `addFileScope`)
* - As long as `.css` is there, we have a valid `.css.*` file path, because otherwise there wouldn't
*   be a file scope to begin with
*
* The LRU cache we use can't cache undefined/null values, so we opt to return an empty string,
* rather than using a custom Symbol or something similar.
*/
var _getDebugFileName = (path) => {
	var file;
	var lastIndexOfDotCss = path.lastIndexOf(".css");
	if (lastIndexOfDotCss === -1) return "";
	var lastSlashIndex = getLastSlashBeforeIndex(path, lastIndexOfDotCss);
	file = path.slice(lastSlashIndex + 1, lastIndexOfDotCss);
	if (lastSlashIndex === -1) return file;
	var secondLastSlashIndex = getLastSlashBeforeIndex(path, lastSlashIndex - 1);
	var dir = path.slice(secondLastSlashIndex + 1, lastSlashIndex);
	return file !== "index" ? file : dir;
};
var memoizedGetDebugFileName = () => {
	var cache = new LRUCache({ max: 500 });
	return (path) => {
		var cachedResult = cache.get(path);
		if (cachedResult) return cachedResult;
		var result = _getDebugFileName(path);
		cache.set(path, result);
		return result;
	};
};
var getDebugFileName = memoizedGetDebugFileName();
function createGlobalThemeContract(tokens, mapFn) {
	return walkObject(tokens, (value, path) => {
		var rawVarName = typeof mapFn === "function" ? mapFn(value, path) : value;
		var varName = typeof rawVarName === "string" ? rawVarName.replace(/^--/, "") : null;
		if (typeof varName !== "string" || varName !== (0, import_cssesc.default)(varName, { isIdentifier: true })) throw new Error("Invalid variable name for \"".concat(path.join("."), "\": ").concat(varName));
		return "var(--".concat(varName, ")");
	});
}

//#endregion
//#region node_modules/.pnpm/@mysten+dapp-kit@0.19.11_@tanstack+react-query@5.90.14_react@19.2.3__@types+react-dom@1_a463d101980818a1a0857326626a02ff/node_modules/@mysten/dapp-kit/dist/esm/index.js
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __typeError = (msg) => {
	throw TypeError(msg);
};
var __esm = (fn, res) => function __init() {
	return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod$1) => function __require() {
	return mod$1 || (0, cb[__getOwnPropNames(cb)[0]])((mod$1 = { exports: {} }).exports, mod$1), mod$1.exports;
};
var __copyProps = (to, from, except, desc) => {
	if (from && typeof from === "object" || typeof from === "function") {
		for (let key of __getOwnPropNames(from)) if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
			get: () => from[key],
			enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
		});
	}
	return to;
};
var __toESM = (mod$1, isNodeMode, target) => (target = mod$1 != null ? __create(__getProtoOf(mod$1)) : {}, __copyProps(isNodeMode || !mod$1 || !mod$1.__esModule ? __defProp(target, "default", {
	value: mod$1,
	enumerable: true
}) : target, mod$1));
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var init_StyleMarker_css_ts_vanilla = __esm({ "vanilla-extract-css-ns:src/components/styling/StyleMarker.css.ts.vanilla.css?source=OndoZXJlKCopIHsKICBib3gtc2l6aW5nOiBib3JkZXItYm94OwogIGNvbG9yOiB2YXIoLS1kYXBwLWtpdC1jb2xvcnMtYm9keSk7CiAgZm9udC1mYW1pbHk6IHZhcigtLWRhcHAta2l0LXR5cG9ncmFwaHktZm9udEZhbWlseSk7CiAgZm9udC1zaXplOiB2YXIoLS1kYXBwLWtpdC1mb250V2VpZ2h0cy1ub3JtYWwpOwogIGZvbnQtc3R5bGU6IHZhcigtLWRhcHAta2l0LXR5cG9ncmFwaHktZm9udFN0eWxlKTsKICBmb250LXdlaWdodDogdmFyKC0tZGFwcC1raXQtZm9udFdlaWdodHMtbm9ybWFsKTsKICBsaW5lLWhlaWdodDogdmFyKC0tZGFwcC1raXQtdHlwb2dyYXBoeS1saW5lSGVpZ2h0KTsKICBsZXR0ZXItc3BhY2luZzogdmFyKC0tZGFwcC1raXQtdHlwb2dyYXBoeS1sZXR0ZXJTcGFjaW5nKTsKfQo6d2hlcmUoYnV0dG9uKSB7CiAgYXBwZWFyYW5jZTogbm9uZTsKICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDsKICBmb250LXNpemU6IGluaGVyaXQ7CiAgZm9udC1mYW1pbHk6IGluaGVyaXQ7CiAgbGluZS1oZWlnaHQ6IGluaGVyaXQ7CiAgbGV0dGVyLXNwYWNpbmc6IGluaGVyaXQ7CiAgY29sb3I6IGluaGVyaXQ7CiAgYm9yZGVyOiAwOwogIHBhZGRpbmc6IDA7CiAgbWFyZ2luOiAwOwp9Cjp3aGVyZShhKSB7CiAgdGV4dC1kZWNvcmF0aW9uOiBub25lOwogIGNvbG9yOiBpbmhlcml0OwogIG91dGxpbmU6IG5vbmU7Cn0KOndoZXJlKG9sLCB1bCkgewogIGxpc3Qtc3R5bGU6IG5vbmU7CiAgbWFyZ2luOiAwOwogIHBhZGRpbmc6IDA7Cn0KOndoZXJlKGgxLCBoMiwgaDMsIGg0LCBoNSwgaDYpIHsKICBmb250LXNpemU6IGluaGVyaXQ7CiAgZm9udC13ZWlnaHQ6IGluaGVyaXQ7CiAgbWFyZ2luOiAwOwp9"() {} });
var require_StyleMarker_css = __commonJS({ "src/components/styling/StyleMarker.css.ts"() {
	init_StyleMarker_css_ts_vanilla();
} });
function createInMemoryStore() {
	const store = /* @__PURE__ */ new Map();
	return {
		getItem(key) {
			return store.get(key);
		},
		setItem(key, value) {
			store.set(key, value);
		},
		removeItem(key) {
			store.delete(key);
		}
	};
}
var SUI_WALLET_NAME = "Sui Wallet";
var DEFAULT_STORAGE = typeof window !== "undefined" && window.localStorage ? localStorage : createInMemoryStore();
var DEFAULT_STORAGE_KEY = "sui-dapp-kit:wallet-connection-info";
var SIGN_FEATURES = ["sui:signTransaction", "sui:signTransactionBlock"];
var DEFAULT_WALLET_FILTER = (wallet) => SIGN_FEATURES.some((feature) => wallet.features[feature]);
var DEFAULT_PREFERRED_WALLETS = [SUI_WALLET_NAME, SLUSH_WALLET_NAME];
var walletMutationKeys = {
	all: { baseScope: "wallet" },
	connectWallet: formMutationKeyFn("connect-wallet"),
	autoconnectWallet: formMutationKeyFn("autoconnect-wallet"),
	disconnectWallet: formMutationKeyFn("disconnect-wallet"),
	signPersonalMessage: formMutationKeyFn("sign-personal-message"),
	signTransaction: formMutationKeyFn("sign-transaction"),
	signAndExecuteTransaction: formMutationKeyFn("sign-and-execute-transaction"),
	switchAccount: formMutationKeyFn("switch-account"),
	reportTransactionEffects: formMutationKeyFn("report-transaction-effects")
};
function formMutationKeyFn(baseEntity) {
	return function mutationKeyFn(additionalKeys = []) {
		return [{
			...walletMutationKeys.all,
			baseEntity
		}, ...additionalKeys];
	};
}
var WalletContext = (0, import_react.createContext)(null);
function useWalletStore(selector) {
	const store = (0, import_react.useContext)(WalletContext);
	if (!store) throw new Error("Could not find WalletContext. Ensure that you have set up the WalletProvider.");
	return useStore(store, selector);
}
function useConnectWallet({ mutationKey, ...mutationOptions } = {}) {
	const setWalletConnected = useWalletStore((state) => state.setWalletConnected);
	const setConnectionStatus = useWalletStore((state) => state.setConnectionStatus);
	return useMutation({
		mutationKey: walletMutationKeys.connectWallet(mutationKey),
		mutationFn: async ({ wallet, accountAddress, ...connectArgs }) => {
			try {
				setConnectionStatus("connecting");
				const connectResult = await wallet.features["standard:connect"].connect(connectArgs);
				let supportedIntents = connectResult.supportedIntents;
				if (!supportedIntents && wallet.features["sui:getCapabilities"]) supportedIntents = (await wallet.features["sui:getCapabilities"].getCapabilities()).supportedIntents ?? [];
				const connectedSuiAccounts = connectResult.accounts.filter((account) => account.chains.some((chain) => chain.split(":")[0] === "sui"));
				setWalletConnected(wallet, connectedSuiAccounts, getSelectedAccount(connectedSuiAccounts, accountAddress), supportedIntents);
				return { accounts: connectedSuiAccounts };
			} catch (error) {
				setConnectionStatus("disconnected");
				throw error;
			}
		},
		...mutationOptions
	});
}
function getSelectedAccount(connectedAccounts, accountAddress) {
	if (connectedAccounts.length === 0) return null;
	if (accountAddress) return connectedAccounts.find((account) => account.address === accountAddress) ?? connectedAccounts[0];
	return connectedAccounts[0];
}
function useWallets() {
	return useWalletStore((state) => state.wallets);
}
function getRegisteredWallets(preferredWallets, walletFilter) {
	const suiWallets = getWallets().get().filter((wallet) => isWalletWithRequiredFeatureSet(wallet) && (!walletFilter || walletFilter(wallet)));
	return [...preferredWallets.map((name) => suiWallets.find((wallet) => wallet.name === name)).filter(Boolean), ...suiWallets.filter((wallet) => !preferredWallets.includes(wallet.name))];
}
function getWalletUniqueIdentifier(wallet) {
	return wallet?.id ?? wallet?.name;
}
function BackIcon(props) {
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)("svg", {
		width: 24,
		height: 24,
		fill: "none",
		xmlns: "http://www.w3.org/2000/svg",
		...props,
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", {
			d: "M7.57 12.262c0 .341.13.629.403.895l5.175 5.059c.204.205.45.307.751.307.609 0 1.101-.485 1.101-1.087 0-.293-.123-.574-.349-.8L10.14 12.27l4.511-4.375A1.13 1.13 0 0 0 15 7.087C15 6.485 14.508 6 13.9 6c-.295 0-.54.103-.752.308l-5.175 5.058c-.28.28-.404.56-.404.896Z",
			fill: "currentColor"
		})
	});
}
function CloseIcon(props) {
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)("svg", {
		width: 10,
		height: 10,
		fill: "none",
		xmlns: "http://www.w3.org/2000/svg",
		...props,
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", {
			d: "M9.708.292a.999.999 0 0 0-1.413 0l-3.289 3.29L1.717.291A.999.999 0 0 0 .305 1.705l3.289 3.289-3.29 3.289a.999.999 0 1 0 1.413 1.412l3.29-3.289 3.288 3.29a.999.999 0 0 0 1.413-1.413l-3.29-3.29 3.29-3.288a.999.999 0 0 0 0-1.413Z",
			fill: "currentColor"
		})
	});
}
var styleDataAttributeName = "data-dapp-kit";
var styleDataAttributeSelector = `[${styleDataAttributeName}]`;
var styleDataAttribute = { [styleDataAttributeName]: "" };
__toESM(require_StyleMarker_css());
var StyleMarker = (0, import_react.forwardRef)(({ children, ...props }, forwardedRef) => /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Slot, {
	ref: forwardedRef,
	...props,
	...styleDataAttribute,
	children
}));
StyleMarker.displayName = "StyleMarker";
var headingVariants = createRuntimeFn({
	defaultClassName: "Heading__1aa835k0",
	variantClassNames: {
		size: {
			sm: "Heading_headingVariants_size_sm__1aa835k1",
			md: "Heading_headingVariants_size_md__1aa835k2",
			lg: "Heading_headingVariants_size_lg__1aa835k3",
			xl: "Heading_headingVariants_size_xl__1aa835k4"
		},
		weight: {
			normal: "Heading_headingVariants_weight_normal__1aa835k5",
			bold: "Heading_headingVariants_weight_bold__1aa835k6"
		},
		truncate: { true: "Heading_headingVariants_truncate_true__1aa835k7" }
	},
	defaultVariants: {
		size: "lg",
		weight: "bold"
	},
	compoundVariants: []
});
var Heading = (0, import_react.forwardRef)(({ children, className, asChild = false, as: Tag = "h1", size, weight, truncate, ...headingProps }, forwardedRef) => {
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Slot, {
		...headingProps,
		ref: forwardedRef,
		className: clsx_default(headingVariants({
			size,
			weight,
			truncate
		}), className),
		children: asChild ? children : /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Tag, { children })
	});
});
Heading.displayName = "Heading";
var container = "IconButton_container__s6n7bq0";
var IconButton = (0, import_react.forwardRef)(({ className, asChild = false, ...props }, forwardedRef) => {
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(asChild ? Slot : "button", {
		...props,
		className: clsx_default(container, className),
		ref: forwardedRef
	});
});
IconButton.displayName = "Button";
var backButtonContainer = "ConnectModal_backButtonContainer__gz8z96";
var closeButtonContainer = "ConnectModal_closeButtonContainer__gz8z97";
var content = "ConnectModal_content__gz8z92";
var overlay = "ConnectModal_overlay__gz8z90";
var selectedViewContainer = "ConnectModal_selectedViewContainer__gz8z95";
var title = "ConnectModal_title__gz8z91";
var viewContainer = "ConnectModal_viewContainer__gz8z94";
var walletListContainer = "ConnectModal_walletListContainer__gz8z99";
var walletListContainerWithViewSelected = "ConnectModal_walletListContainerWithViewSelected__gz8z9a";
var walletListContent = "ConnectModal_walletListContent__gz8z98";
var whatIsAWalletButton = "ConnectModal_whatIsAWalletButton__gz8z93";
var buttonVariants = createRuntimeFn({
	defaultClassName: "Button_buttonVariants__x1s81q0",
	variantClassNames: {
		variant: {
			primary: "Button_buttonVariants_variant_primary__x1s81q1",
			outline: "Button_buttonVariants_variant_outline__x1s81q2"
		},
		size: {
			md: "Button_buttonVariants_size_md__x1s81q3",
			lg: "Button_buttonVariants_size_lg__x1s81q4"
		}
	},
	defaultVariants: {
		variant: "primary",
		size: "md"
	},
	compoundVariants: []
});
var Button = (0, import_react.forwardRef)(({ className, variant: variant$1, size, asChild = false, ...props }, forwardedRef) => {
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(asChild ? Slot : "button", {
		...props,
		className: clsx_default(buttonVariants({
			variant: variant$1,
			size
		}), className),
		ref: forwardedRef
	});
});
Button.displayName = "Button";
var textVariants = createRuntimeFn({
	defaultClassName: "Text__2bv1ur0",
	variantClassNames: {
		size: { sm: "Text_textVariants_size_sm__2bv1ur1" },
		weight: {
			normal: "Text_textVariants_weight_normal__2bv1ur2",
			medium: "Text_textVariants_weight_medium__2bv1ur3",
			bold: "Text_textVariants_weight_bold__2bv1ur4"
		},
		color: {
			muted: "Text_textVariants_color_muted__2bv1ur5",
			danger: "Text_textVariants_color_danger__2bv1ur6"
		},
		mono: { true: "Text_textVariants_mono_true__2bv1ur7" }
	},
	defaultVariants: {
		size: "sm",
		weight: "normal"
	},
	compoundVariants: []
});
var Text = (0, import_react.forwardRef)(({ children, className, asChild = false, as: Tag = "div", size, weight, color, mono, ...textProps }, forwardedRef) => {
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Slot, {
		...textProps,
		ref: forwardedRef,
		className: clsx_default(textVariants({
			size,
			weight,
			color,
			mono
		}), className),
		children: asChild ? children : /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Tag, { children })
	});
});
Text.displayName = "Text";
var connectionStatus = "ConnectionStatus_connectionStatus__nckm2d3";
var container2 = "ConnectionStatus_container__nckm2d0";
var retryButtonContainer = "ConnectionStatus_retryButtonContainer__nckm2d4";
var title2 = "ConnectionStatus_title__nckm2d2";
var walletIcon = "ConnectionStatus_walletIcon__nckm2d1";
function ConnectionStatus({ selectedWallet, hadConnectionError, onRetryConnection }) {
	return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
		className: container2,
		children: [
			selectedWallet.icon && /* @__PURE__ */ (0, import_jsx_runtime.jsx)("img", {
				className: walletIcon,
				src: selectedWallet.icon,
				alt: `${selectedWallet.name} logo`
			}),
			/* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
				className: title2,
				children: /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(Heading, {
					as: "h2",
					size: "xl",
					children: ["Opening ", selectedWallet.name]
				})
			}),
			/* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
				className: connectionStatus,
				children: hadConnectionError ? /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Text, {
					color: "danger",
					children: "Connection failed"
				}) : /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Text, {
					color: "muted",
					children: "Confirm connection in the wallet..."
				})
			}),
			hadConnectionError ? /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
				className: retryButtonContainer,
				children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Button, {
					type: "button",
					variant: "outline",
					onClick: () => onRetryConnection(selectedWallet),
					children: "Retry Connection"
				})
			}) : null
		]
	});
}
var container3 = "InfoSection_container__1wtioi70";
function InfoSection({ title: title3, children }) {
	return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("section", {
		className: container3,
		children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)(Heading, {
			as: "h3",
			size: "sm",
			weight: "normal",
			children: title3
		}), /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Text, {
			weight: "medium",
			color: "muted",
			children
		})]
	});
}
var container4 = "GettingStarted_container__1fp07e10";
var content2 = "GettingStarted_content__1fp07e11";
var installButtonContainer = "GettingStarted_installButtonContainer__1fp07e12";
function GettingStarted() {
	return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
		className: container4,
		children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)(Heading, {
			as: "h2",
			children: "Get Started with Sui"
		}), /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
			className: content2,
			children: [
				/* @__PURE__ */ (0, import_jsx_runtime.jsx)(InfoSection, {
					title: "Install the Sui Wallet Extension",
					children: "We recommend pinning Sui Wallet to your taskbar for quicker access."
				}),
				/* @__PURE__ */ (0, import_jsx_runtime.jsx)(InfoSection, {
					title: "Create or Import a Wallet",
					children: "Be sure to back up your wallet using a secure method. Never share your secret phrase with anyone."
				}),
				/* @__PURE__ */ (0, import_jsx_runtime.jsx)(InfoSection, {
					title: "Refresh Your Browser",
					children: "Once you set up your wallet, refresh this window browser to load up the extension."
				}),
				/* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
					className: installButtonContainer,
					children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Button, {
						variant: "outline",
						asChild: true,
						children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)("a", {
							href: "https://chrome.google.com/webstore/detail/sui-wallet/opcgpfmipidbgpenhmajoajpbobppdil",
							target: "_blank",
							rel: "noreferrer",
							children: "Install Wallet Extension"
						})
					})
				})
			]
		})]
	});
}
var container5 = "WhatIsAWallet_container__1ktpkq90";
var content3 = "WhatIsAWallet_content__1ktpkq91";
function WhatIsAWallet() {
	return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
		className: container5,
		children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)(Heading, {
			as: "h2",
			children: "What is a Wallet"
		}), /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
			className: content3,
			children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)(InfoSection, {
				title: "Easy Login",
				children: "No need to create new accounts and passwords for every website. Just connect your wallet and get going."
			}), /* @__PURE__ */ (0, import_jsx_runtime.jsx)(InfoSection, {
				title: "Store your Digital Assets",
				children: "Send, receive, store, and display your digital assets like NFTs & coins."
			})]
		})]
	});
}
function SuiIcon(props) {
	return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("svg", {
		width: 28,
		height: 28,
		fill: "none",
		xmlns: "http://www.w3.org/2000/svg",
		...props,
		children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)("rect", {
			width: 28,
			height: 28,
			rx: 6,
			fill: "#6FBCF0"
		}), /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", {
			fillRule: "evenodd",
			clipRule: "evenodd",
			d: "M7.942 20.527A6.875 6.875 0 0 0 13.957 24c2.51 0 4.759-1.298 6.015-3.473a6.875 6.875 0 0 0 0-6.945l-5.29-9.164a.837.837 0 0 0-1.45 0l-5.29 9.164a6.875 6.875 0 0 0 0 6.945Zm4.524-11.75 1.128-1.953a.418.418 0 0 1 .725 0l4.34 7.516a5.365 5.365 0 0 1 .449 4.442 4.675 4.675 0 0 0-.223-.73c-.599-1.512-1.954-2.68-4.029-3.47-1.426-.54-2.336-1.336-2.706-2.364-.476-1.326.021-2.77.316-3.44Zm-1.923 3.332L9.255 14.34a5.373 5.373 0 0 0 0 5.43 5.373 5.373 0 0 0 4.702 2.714 5.38 5.38 0 0 0 3.472-1.247c.125-.314.51-1.462.034-2.646-.44-1.093-1.5-1.965-3.15-2.594-1.864-.707-3.076-1.811-3.6-3.28a4.601 4.601 0 0 1-.17-.608Z",
			fill: "#fff"
		})]
	});
}
var container6 = "WalletList_container__1v2s6cz0";
var container7 = "WalletListItem_container__1dqqtqs0";
var selectedWalletItem = "WalletListItem_selectedWalletItem__1dqqtqs2";
var walletIcon2 = "WalletListItem_walletIcon__1dqqtqs3";
var walletItem = "WalletListItem_walletItem__1dqqtqs1";
function WalletListItem({ name, icon, onClick, isSelected = false }) {
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)("li", {
		className: container7,
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("button", {
			className: clsx(walletItem, { [selectedWalletItem]: isSelected }),
			type: "button",
			onClick,
			children: [icon && typeof icon === "string" ? /* @__PURE__ */ (0, import_jsx_runtime.jsx)("img", {
				className: walletIcon2,
				src: icon,
				alt: `${name} logo`
			}) : icon, /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Heading, {
				size: "md",
				truncate: true,
				asChild: true,
				children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", { children: name })
			})]
		})
	});
}
function WalletList({ selectedWalletName, onPlaceholderClick, onSelect, wallets: wallets$1 }) {
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)("ul", {
		className: container6,
		children: wallets$1.length > 0 ? wallets$1.map((wallet) => /* @__PURE__ */ (0, import_jsx_runtime.jsx)(WalletListItem, {
			name: wallet.name,
			icon: wallet.icon,
			isSelected: getWalletUniqueIdentifier(wallet) === selectedWalletName,
			onClick: () => onSelect(wallet)
		}, getWalletUniqueIdentifier(wallet))) : /* @__PURE__ */ (0, import_jsx_runtime.jsx)(WalletListItem, {
			name: "Sui Wallet",
			icon: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(SuiIcon, {}),
			onClick: onPlaceholderClick,
			isSelected: true
		})
	});
}
function ConnectModal({ trigger, open, defaultOpen, onOpenChange, walletFilter = DEFAULT_WALLET_FILTER }) {
	const [isModalOpen, setModalOpen] = (0, import_react.useState)(open ?? defaultOpen);
	const [currentView, setCurrentView] = (0, import_react.useState)();
	const [selectedWallet, setSelectedWallet] = (0, import_react.useState)();
	const wallets$1 = useWallets().filter(walletFilter);
	const { mutate, isError } = useConnectWallet();
	const resetSelection = () => {
		setSelectedWallet(void 0);
		setCurrentView(void 0);
	};
	const handleOpenChange = (open2) => {
		if (!open2) resetSelection();
		setModalOpen(open2);
		onOpenChange?.(open2);
	};
	const connectWallet = (wallet) => {
		setCurrentView("connection-status");
		mutate({ wallet }, { onSuccess: () => handleOpenChange(false) });
	};
	let modalContent;
	switch (currentView) {
		case "what-is-a-wallet":
			modalContent = /* @__PURE__ */ (0, import_jsx_runtime.jsx)(WhatIsAWallet, {});
			break;
		case "getting-started":
			modalContent = /* @__PURE__ */ (0, import_jsx_runtime.jsx)(GettingStarted, {});
			break;
		case "connection-status":
			modalContent = /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ConnectionStatus, {
				selectedWallet,
				hadConnectionError: isError,
				onRetryConnection: connectWallet
			});
			break;
		default: modalContent = /* @__PURE__ */ (0, import_jsx_runtime.jsx)(WhatIsAWallet, {});
	}
	return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(Root, {
		open: open ?? isModalOpen,
		onOpenChange: handleOpenChange,
		children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)(Trigger, {
			asChild: true,
			children: trigger
		}), /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Portal, { children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(StyleMarker, { children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Overlay, {
			className: overlay,
			children: /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(Content, {
				className: content,
				"aria-describedby": void 0,
				children: [
					/* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
						className: clsx_default(walletListContainer, { [walletListContainerWithViewSelected]: !!currentView }),
						children: [/* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
							className: walletListContent,
							children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)(Title, {
								className: title,
								asChild: true,
								children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Heading, {
									as: "h2",
									children: "Connect a Wallet"
								})
							}), /* @__PURE__ */ (0, import_jsx_runtime.jsx)(WalletList, {
								wallets: wallets$1,
								selectedWalletName: getWalletUniqueIdentifier(selectedWallet),
								onPlaceholderClick: () => setCurrentView("getting-started"),
								onSelect: (wallet) => {
									if (getWalletUniqueIdentifier(selectedWallet) !== getWalletUniqueIdentifier(wallet)) {
										setSelectedWallet(wallet);
										connectWallet(wallet);
									}
								}
							})]
						}), /* @__PURE__ */ (0, import_jsx_runtime.jsx)("button", {
							className: whatIsAWalletButton,
							onClick: () => setCurrentView("what-is-a-wallet"),
							type: "button",
							children: "What is a Wallet?"
						})]
					}),
					/* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
						className: clsx_default(viewContainer, { [selectedViewContainer]: !!currentView }),
						children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
							className: backButtonContainer,
							children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(IconButton, {
								type: "button",
								"aria-label": "Back",
								onClick: () => resetSelection(),
								children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(BackIcon, {})
							})
						}), modalContent]
					}),
					/* @__PURE__ */ (0, import_jsx_runtime.jsx)(Close, {
						className: closeButtonContainer,
						asChild: true,
						children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(IconButton, {
							type: "button",
							"aria-label": "Close",
							children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(CloseIcon, {})
						})
					})
				]
			})
		}) }) })]
	});
}
function useCurrentAccount() {
	return useWalletStore((state) => state.currentAccount);
}
var SuiClientContext = (0, import_react.createContext)(null);
var DEFAULT_NETWORKS = { localnet: { url: getFullnodeUrl("localnet") } };
var DEFAULT_CREATE_CLIENT = function createClient(_name$1, config) {
	if (isSuiJsonRpcClient(config)) return config;
	return new SuiJsonRpcClient(config);
};
function SuiClientProvider(props) {
	const { onNetworkChange, network, children } = props;
	const networks = props.networks ?? DEFAULT_NETWORKS;
	const createClient2 = props.createClient ?? DEFAULT_CREATE_CLIENT;
	const [selectedNetwork, setSelectedNetwork] = (0, import_react.useState)(props.network ?? props.defaultNetwork ?? Object.keys(networks)[0]);
	const currentNetwork = props.network ?? selectedNetwork;
	const client = (0, import_react.useMemo)(() => {
		return createClient2(currentNetwork, networks[currentNetwork]);
	}, [
		createClient2,
		currentNetwork,
		networks
	]);
	const ctx = (0, import_react.useMemo)(() => {
		return {
			client,
			networks,
			network: currentNetwork,
			config: networks[currentNetwork] instanceof SuiJsonRpcClient ? null : networks[currentNetwork],
			selectNetwork: (newNetwork) => {
				if (currentNetwork === newNetwork) return;
				if (!network && newNetwork !== selectedNetwork) setSelectedNetwork(newNetwork);
				onNetworkChange?.(newNetwork);
			}
		};
	}, [
		client,
		networks,
		selectedNetwork,
		currentNetwork,
		network,
		onNetworkChange
	]);
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(SuiClientContext.Provider, {
		value: ctx,
		children
	});
}
function useSuiClientContext() {
	const suiClient = (0, import_react.useContext)(SuiClientContext);
	if (!suiClient) throw new Error("Could not find SuiClientContext. Ensure that you have set up the SuiClientProvider");
	return suiClient;
}
function useSuiClient() {
	return useSuiClientContext().client;
}
function getSuiClientQuery({ client, network, method, params, options }) {
	return queryOptions({
		...options,
		queryKey: [
			network,
			method,
			params
		],
		queryFn: async () => {
			return await client[method](params);
		}
	});
}
function useSuiClientQuery(...args) {
	const [method, params, { queryKey = [], ...options } = {}] = args;
	const suiContext = useSuiClientContext();
	return useQuery({
		...options,
		queryKey: [
			suiContext.network,
			method,
			params,
			...queryKey
		],
		queryFn: async () => {
			return await suiContext.client[method](params);
		}
	});
}
function useSuiClientSuspenseQuery(...args) {
	const [method, params, options = {}] = args;
	const suiContext = useSuiClientContext();
	return useSuspenseQuery((0, import_react.useMemo)(() => {
		return getSuiClientQuery({
			client: suiContext.client,
			network: suiContext.network,
			method,
			params,
			options
		});
	}, [
		suiContext.client,
		suiContext.network,
		method,
		params,
		options
	]));
}
function useResolveSuiNSName(address, options) {
	return useSuiClientQuery("resolveNameServiceNames", {
		address,
		limit: 1
	}, {
		...options,
		refetchOnWindowFocus: false,
		retry: false,
		select: (data) => data.data.length > 0 ? data.data[0] : null,
		enabled: !!address && options?.enabled !== false
	});
}
function useAccounts() {
	return useWalletStore((state) => state.accounts);
}
var WalletNotConnectedError = class extends Error {};
var WalletNoAccountSelectedError = class extends Error {};
var WalletFeatureNotSupportedError = class extends Error {};
var WalletAccountNotFoundError = class extends Error {};
function useCurrentWallet() {
	const currentWallet = useWalletStore((state) => state.currentWallet);
	const connectionStatus2 = useWalletStore((state) => state.connectionStatus);
	const supportedIntents = useWalletStore((state) => state.supportedIntents);
	switch (connectionStatus2) {
		case "connecting": return {
			connectionStatus: connectionStatus2,
			currentWallet: null,
			isDisconnected: false,
			isConnecting: true,
			isConnected: false,
			supportedIntents: []
		};
		case "disconnected": return {
			connectionStatus: connectionStatus2,
			currentWallet: null,
			isDisconnected: true,
			isConnecting: false,
			isConnected: false,
			supportedIntents: []
		};
		case "connected": return {
			connectionStatus: connectionStatus2,
			currentWallet,
			isDisconnected: false,
			isConnecting: false,
			isConnected: true,
			supportedIntents
		};
	}
}
function useDisconnectWallet({ mutationKey, ...mutationOptions } = {}) {
	const { currentWallet } = useCurrentWallet();
	const setWalletDisconnected = useWalletStore((state) => state.setWalletDisconnected);
	return useMutation({
		mutationKey: walletMutationKeys.disconnectWallet(mutationKey),
		mutationFn: async () => {
			if (!currentWallet) throw new WalletNotConnectedError("No wallet is connected.");
			try {
				await currentWallet.features["standard:disconnect"]?.disconnect();
			} catch (error) {
				console.error("Failed to disconnect the application from the current wallet.", error);
			}
			setWalletDisconnected();
		},
		...mutationOptions
	});
}
function useSwitchAccount({ mutationKey, ...mutationOptions } = {}) {
	const { currentWallet } = useCurrentWallet();
	const setAccountSwitched = useWalletStore((state) => state.setAccountSwitched);
	return useMutation({
		mutationKey: walletMutationKeys.switchAccount(mutationKey),
		mutationFn: async ({ account }) => {
			if (!currentWallet) throw new WalletNotConnectedError("No wallet is connected.");
			const accountToSelect = currentWallet.accounts.find((walletAccount) => walletAccount.address === account.address);
			if (!accountToSelect) throw new WalletAccountNotFoundError(`No account with address ${account.address} is connected to ${currentWallet.name}.`);
			setAccountSwitched(accountToSelect);
		},
		...mutationOptions
	});
}
var connectedAccount = "AccountDropdownMenu_connectedAccount__div2ql0";
var menuContainer = "AccountDropdownMenu_menuContainer__div2ql1";
var menuContent = "AccountDropdownMenu_menuContent__div2ql2";
var menuItem = "AccountDropdownMenu_menuItem__div2ql3";
var separator = "AccountDropdownMenu_separator__div2ql5";
var switchAccountMenuItem = "AccountDropdownMenu_switchAccountMenuItem__div2ql4";
function CheckIcon(props) {
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)("svg", {
		xmlns: "http://www.w3.org/2000/svg",
		width: 16,
		height: 16,
		fill: "none",
		...props,
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", {
			fill: "currentColor",
			d: "m11.726 5.048-4.73 5.156-1.722-1.879a.72.72 0 0 0-.529-.23.722.722 0 0 0-.525.24.858.858 0 0 0-.22.573.86.86 0 0 0 .211.576l2.255 2.458c.14.153.332.24.53.24.2 0 .391-.087.532-.24l5.261-5.735A.86.86 0 0 0 13 5.63a.858.858 0 0 0-.22-.572.722.722 0 0 0-.525-.24.72.72 0 0 0-.529.23Z"
		})
	});
}
function ChevronIcon(props) {
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)("svg", {
		xmlns: "http://www.w3.org/2000/svg",
		width: 16,
		height: 16,
		fill: "none",
		...props,
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", {
			stroke: "#A0B6C3",
			strokeLinecap: "round",
			strokeLinejoin: "round",
			strokeWidth: 1.5,
			d: "m4 6 4 4 4-4"
		})
	});
}
function AccountDropdownMenu({ currentAccount }) {
	const { mutate: disconnectWallet } = useDisconnectWallet();
	const { data: domain } = useResolveSuiNSName(currentAccount.label ? null : currentAccount.address);
	const accounts = useAccounts();
	return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(Root2, {
		modal: false,
		children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)(StyleMarker, { children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Trigger$1, {
			asChild: true,
			children: /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(Button, {
				size: "lg",
				className: connectedAccount,
				children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)(Text, {
					mono: true,
					weight: "bold",
					children: currentAccount.label ?? domain ?? formatAddress(currentAccount.address)
				}), /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ChevronIcon, {})]
			})
		}) }), /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Portal2, { children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(StyleMarker, {
			className: menuContainer,
			children: /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(Content2, {
				className: menuContent,
				children: [
					accounts.map((account) => /* @__PURE__ */ (0, import_jsx_runtime.jsx)(AccountDropdownMenuItem, {
						account,
						active: currentAccount.address === account.address
					}, account.address)),
					/* @__PURE__ */ (0, import_jsx_runtime.jsx)(Separator2, { className: separator }),
					/* @__PURE__ */ (0, import_jsx_runtime.jsx)(Item2, {
						className: clsx_default(menuItem),
						onSelect: () => disconnectWallet(),
						children: "Disconnect"
					})
				]
			})
		}) })]
	});
}
function AccountDropdownMenuItem({ account, active }) {
	const { mutate: switchAccount } = useSwitchAccount();
	const { data: domain } = useResolveSuiNSName(account.label ? null : account.address);
	return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(Item2, {
		className: clsx_default(menuItem, switchAccountMenuItem),
		onSelect: () => switchAccount({ account }),
		children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)(Text, {
			mono: true,
			children: account.label ?? domain ?? formatAddress(account.address)
		}), active ? /* @__PURE__ */ (0, import_jsx_runtime.jsx)(CheckIcon, {}) : null]
	});
}
function ConnectButton({ connectText = "Connect Wallet", walletFilter, ...buttonProps }) {
	const currentAccount = useCurrentAccount();
	return currentAccount ? /* @__PURE__ */ (0, import_jsx_runtime.jsx)(AccountDropdownMenu, { currentAccount }) : /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ConnectModal, {
		walletFilter,
		trigger: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(StyleMarker, { children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Button, {
			...buttonProps,
			children: connectText
		}) })
	});
}
function useAutoConnectWallet() {
	const { mutateAsync: connectWallet } = useConnectWallet();
	const autoConnectEnabled = useWalletStore((state) => state.autoConnectEnabled);
	const lastConnectedWalletName = useWalletStore((state) => state.lastConnectedWalletName);
	const lastConnectedAccountAddress = useWalletStore((state) => state.lastConnectedAccountAddress);
	const wallets$1 = useWallets();
	const { isConnected } = useCurrentWallet();
	const [clientOnly, setClientOnly] = (0, import_react.useState)(false);
	(0, import_react.useLayoutEffect)(() => {
		setClientOnly(true);
	}, []);
	const { data, isError } = useQuery({
		queryKey: [
			"@mysten/dapp-kit",
			"autoconnect",
			{
				isConnected,
				autoConnectEnabled,
				lastConnectedWalletName,
				lastConnectedAccountAddress,
				walletCount: wallets$1.length
			}
		],
		queryFn: async () => {
			if (!autoConnectEnabled) return "disabled";
			if (!lastConnectedWalletName || !lastConnectedAccountAddress || isConnected) return "attempted";
			const wallet = wallets$1.find((wallet2) => getWalletUniqueIdentifier(wallet2) === lastConnectedWalletName);
			if (wallet) await connectWallet({
				wallet,
				accountAddress: lastConnectedAccountAddress,
				silent: true
			});
			return "attempted";
		},
		enabled: autoConnectEnabled,
		persister: void 0,
		gcTime: 0,
		staleTime: 0,
		networkMode: "always",
		retry: false,
		retryOnMount: false,
		refetchInterval: false,
		refetchIntervalInBackground: false,
		refetchOnMount: false,
		refetchOnReconnect: false,
		refetchOnWindowFocus: false
	});
	if (!autoConnectEnabled) return "disabled";
	if (!clientOnly) return "idle";
	if (isConnected) return "attempted";
	if (!lastConnectedWalletName) return "attempted";
	return isError ? "attempted" : data ?? "idle";
}
function useSlushWallet(config) {
	(0, import_react.useLayoutEffect)(() => {
		if (!config?.name) return;
		let cleanup;
		let isMounted = true;
		try {
			const result = registerSlushWallet(config.name, { origin: config.origin });
			if (isMounted && result) cleanup = result.unregister;
			else if (result) result.unregister();
		} catch (error) {
			console.error("Failed to register Slush wallet:", error);
		}
		return () => {
			isMounted = false;
			if (cleanup) cleanup();
		};
	}, [config?.name, config?.origin]);
}
var WALLET_NAME = "Unsafe Burner Wallet";
function useUnsafeBurnerWallet(enabled) {
	const suiClient = useSuiClient();
	(0, import_react.useEffect)(() => {
		if (!enabled) return;
		return registerUnsafeBurnerWallet(suiClient);
	}, [enabled, suiClient]);
}
function registerUnsafeBurnerWallet(suiClient) {
	var _on$1, _connect$1, _signPersonalMessage$1, _signTransactionBlock$1, _signTransaction$1, _signAndExecuteTransactionBlock, _signAndExecuteTransaction$1;
	const walletsApi = getWallets();
	if (walletsApi.get().find((wallet) => wallet.name === WALLET_NAME)) {
		console.warn("registerUnsafeBurnerWallet: Unsafe Burner Wallet already registered, skipping duplicate registration.");
		return;
	}
	console.warn("Your application is currently using the unsafe burner wallet. Make sure that this wallet is disabled in production.");
	const keypair = new Ed25519Keypair();
	const account = new ReadonlyWalletAccount({
		address: keypair.getPublicKey().toSuiAddress(),
		publicKey: keypair.getPublicKey().toSuiBytes(),
		chains: ["sui:unknown"],
		features: [
			"sui:signAndExecuteTransactionBlock",
			"sui:signTransactionBlock",
			"sui:signTransaction",
			"sui:signAndExecuteTransaction"
		]
	});
	class UnsafeBurnerWallet {
		constructor() {
			__privateAdd(this, _on$1, () => {
				return () => {};
			});
			__privateAdd(this, _connect$1, async () => {
				return { accounts: this.accounts };
			});
			__privateAdd(this, _signPersonalMessage$1, async (messageInput) => {
				const { bytes, signature } = await keypair.signPersonalMessage(messageInput.message);
				return {
					bytes,
					signature
				};
			});
			__privateAdd(this, _signTransactionBlock$1, async (transactionInput) => {
				const { bytes, signature } = await transactionInput.transactionBlock.sign({
					client: suiClient,
					signer: keypair
				});
				return {
					transactionBlockBytes: bytes,
					signature
				};
			});
			__privateAdd(this, _signTransaction$1, async (transactionInput) => {
				const { bytes, signature } = await Transaction.from(await transactionInput.transaction.toJSON()).sign({
					client: suiClient,
					signer: keypair
				});
				transactionInput.signal?.throwIfAborted();
				return {
					bytes,
					signature
				};
			});
			__privateAdd(this, _signAndExecuteTransactionBlock, async (transactionInput) => {
				const { bytes, signature } = await transactionInput.transactionBlock.sign({
					client: suiClient,
					signer: keypair
				});
				return suiClient.executeTransactionBlock({
					signature,
					transactionBlock: bytes,
					options: transactionInput.options
				});
			});
			__privateAdd(this, _signAndExecuteTransaction$1, async (transactionInput) => {
				const { bytes, signature } = await Transaction.from(await transactionInput.transaction.toJSON()).sign({
					client: suiClient,
					signer: keypair
				});
				transactionInput.signal?.throwIfAborted();
				const { rawEffects, digest } = await suiClient.executeTransactionBlock({
					signature,
					transactionBlock: bytes,
					options: { showRawEffects: true }
				});
				return {
					bytes,
					signature,
					digest,
					effects: toBase64(new Uint8Array(rawEffects))
				};
			});
		}
		get version() {
			return "1.0.0";
		}
		get name() {
			return WALLET_NAME;
		}
		get icon() {
			return "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADwAAAA8CAYAAAA6/NlyAAAJrElEQVR42tWbe2xT1x3H7UxAyD3XrdrSbGXlUbKWsq5rWdVuVOMRSEqSOmnVRZMmJqZNYv1nf3R/jWmVmVrtRRM/YwPd1nVTNcrE3pQCoikrIRAC4VVNY0hlD9ZOo1uCfe3ra9979v0dcy3s5Pper76Oh/STE+495/4+5/c85zqe2f7HAx5vKsS+monJj/CdHi/f4/HWW4f6AwdblmXjTM0NyS+movKtw9v+j6C5gKhyTMTTpA2x15Qwy+Pz75motOGdgKep8WF5ATgVZIt5NeO2wMqD0hfVGNPh3oYaYflsjG0l63PeyLCDnqbsLpZIhaRNFI+Ox+Le5KB0RybK8gDmJOkI07U4i/FhT1NDQl8Me5rUIfaDfELOJ0NsFa/SJQHm1WLsHcDqRWiy9BCL8s0N5t6UWWFVvxplejYm60hC91cNjPtzCTZsAptCVoeLP8PDDQJNCSodap6H+LtE8ZcdkvVkkD38vwDn4/Jvy4EhBhZSvRaUHiTXn31gJJxkUPoClBKKFizM+inhVA2cYIdM4HJouPvoe9s9H+KzDhyGK6KkmIqitBhww2C11rjQL2L4kgUwFxk8yPyzauUA3Pk/353XnA6zKbKCaQ2UlMvJF6W5uF5F8yHfZWZpC9HRmBziaEpm1bpY9XvhxuWJRldC7Mt03WlZwpjnkZUNa2DMG2EaPj9MGd2l2mofd0hQ7ZSopsXckHxVCUp32fXGdD0ZktrgFUmMqwhcWFjp87RArsD+9bn585IRaSHAKgBL3SZwOTRc8BKg7yYoskp5OJDiiPmF2Sj7ox0siYJ7lJA04EqvzZ9B1xSVt6PlW0IxZgUMJdZYAJuWngLQt9IRuZXmoTEkmci8ZtTXTViUKyasA9FRun5d8z6bfw0gYWm9mmCXxZatQgxfC7I2NVpRYQOxKWppLs4mcgn5NcibgL1K40xYp8CYY5TXEpjcb3LAJ0OZyyg3+2nySm6fjEtzkEz+7VBx3RTb+60z9dma7pkvwO2QQL5HzTtAdpKF7euw/HuzfrosBHy+ZsBimzbQshjWTVMDgez53B5MbjcGbr1ZjdUJOM5O0SLXzJ2R+uOA1dMAVoLsm5zb73JSId8t8Aa1LsAJdoTCrCaw6e3NC2DdFMUXWRg173mysJNOSUNskUJ1cOlXa2LhcbgmSszXYSn9hl3KSxTDjrZ2cbbfbWDyumsh9m3e7zCG7a3ETt+gtI7fx6lEOanZKDVvuA2cjYmt5xNOd2Louz3IQ12UZ2Zo3lkb9cDlvSs6m4Vk5Yqlabs0B97wT7PUuCXQz0Bnt9QxMPTW4iwBtmUlY8hFsHJPlzcQ1xuG75CVK1kXofCUGnU9fg1aVD7kfE9MoabtYkcAvIUYS2op3Hc3TTrDQzIAeojugTVLFolWDR6wFPtY0R66n6HltwjCIawnE2ymresk9NtN+pfUUi0mX6RJLfrh9zMRaRPOqubSA8W2MNzC0mHpK7j2ruuw5mYkxl5+2+HGQeg4yNYg7vNg+xMxFsuRMuiTsRJZG3cysAl4D9n4aC4un8L9qUyVvbCyYwFXX1nGUxFf1cCiEQqy75O+TpMwYKNKSPQUqhLyyWLsRbESLctx0YnixgfphRWA8pOPc+N4F9d+eV9V4OlCX/As5w5g+wtGhJGukp5go2R3D7EW9rSDcnGL56YgJHj+8GcFND/Vy41jj/H0jxc6HU/AA2QlR01UlH3D7CmITQnJq4lVWBi1yl8XYEh278c5H++F+Iui7r7bYR8tH/gbqoJN7fVODUhLYVVxzmYCEyOxFg7RUVa0egCHZZ55eRHnp/tKgMna6s/bbMdTxZgMzl9CCcmq7k690OzDfaeSN4QcsREjsQpgXHwyWyfg9K5WE7hc6JqTWjyihObfygOFOkv6i5K5TZx8LsL1sVS4NL8ItiB7sgAcEKcWHfUCVhK3kUVnBNbfXIs4l5xAv5sJs234eTUy93L0Au2otQOw5ORMyfQ6WwexFupVSHowG6uThXfebmlhWojMS3fazmMeGxEI6S2SUti6RAo2vKohVuH3qUG5FWm/PjH8kzutgSH5g58xrVwzIbZkxHf7OFjFC+wrMDXcpOqOKX/g01U/XPvVJyxdWsiJblqYmnZoWbDxAcR56X5WPuh4ewcL5PY9JBRUYjc7fzjG6Uc3mHBWbg23X1BLaFHOSnrw4bWiNAXSEWcWRntIignXTP/oDsfKZX66mMbZAPfhviU1AyYmJLYAMZa/QXjUSeIiixpj3UUFtd884KytjN7EjdGNNMbWwtlf3FvbQ4OQtIoYSzbxqVDLXMTxP8jnnbiyKcaJLvueGLD6kXW2sKZov1tpn7hwXf3ZUvq0K2FXOM7Op/Xgb6PhxsWIErYGVuK3WGXWkkwMMZVCVl5kWtax5A6usgemvnx4DelUcYcFC0eIbcbXKzggeyBjeXIhkftaKknJKLtnuSg7KmKQsrH+1nqbmLWY6w/tBGy/8xrruR5SM99LLIjfT/4ZbNZnQEPssIVb21rKTGRIPDagNoLdFMKgcuLc/TF6Bulk6c7ovg4TU+XvS6FNw1tDfVqH9MOPmBDui0hcK6wz744FlDjNe0m3aVldJYagtI6YbF+3ZGPsQHlN1vbeh8lJofqJ+uo9Zi4wXZxKFiXKGxbHT7pNq71oNg4Qi6MviE0FpRVqjGXILYoJ4tCjdYU1rWeMdPLc/ochj3B9pGNGL4NupGPRlUl35KMVxFLNO6ZnxYlBsUPqoMkbUqAb6VhMVKQ7MVT1dYdrL8hzEAcjpmvjHKphgaFb0ZVJZw7dwVD9q5fkgPTRbBxnzmGfgRLQsMCkG+moQdcp6GzzZsL2MGyllvBNGWM9RqMCk26kI7aBK526csVShZTfzid6FEzeiNAGP92jpCPQEbrW7EW5MbZxAz/fN9lg0IbQaaxrQ83/VoKPb/HqJx67Hw+43CDQBPsX0gm6ufXNvH4vP9rZapzx7+Nn+oxZAjfo2caZ3n350c5W6FSEdQ86sNarj3c/jRV+H42AXsdGRBfPPIlnb/mUtxzWXfALn/PmRze2Gud6E/xsXwYtnlsWN8Tc5/oyxjn/jvyJrlY82xLUfWuPr/TqxzuXQZkIP9M7CXiyuP4B4WmsTnNhzinjrD+WO9bRhmdZWLXe4EKRtV5tpN3Hx3s2G+d79/MJf4qff0LnE72kfFEs4ITQvWLMab8C131dP9n9Je1Yx000Nz2jAf+UJwCBchc3NvGR1Qx71XXY2Ww1Jvx7YalzAPkX9rp5E5Z+pv+ja8bE43uN491b9dHO9Xx4lUxziLn21Nai/wXWM6t9vkvtrwAAAABJRU5ErkJggg==";
		}
		get chains() {
			return SUI_CHAINS;
		}
		get accounts() {
			return [account];
		}
		get features() {
			return {
				"standard:connect": {
					version: "1.0.0",
					connect: __privateGet(this, _connect$1)
				},
				"standard:events": {
					version: "1.0.0",
					on: __privateGet(this, _on$1)
				},
				"sui:signPersonalMessage": {
					version: "1.1.0",
					signPersonalMessage: __privateGet(this, _signPersonalMessage$1)
				},
				"sui:signTransactionBlock": {
					version: "1.0.0",
					signTransactionBlock: __privateGet(this, _signTransactionBlock$1)
				},
				"sui:signAndExecuteTransactionBlock": {
					version: "1.0.0",
					signAndExecuteTransactionBlock: __privateGet(this, _signAndExecuteTransactionBlock)
				},
				"sui:signTransaction": {
					version: "2.0.0",
					signTransaction: __privateGet(this, _signTransaction$1)
				},
				"sui:signAndExecuteTransaction": {
					version: "2.0.0",
					signAndExecuteTransaction: __privateGet(this, _signAndExecuteTransaction$1)
				}
			};
		}
	}
	_on$1 = /* @__PURE__ */ new WeakMap();
	_connect$1 = /* @__PURE__ */ new WeakMap();
	_signPersonalMessage$1 = /* @__PURE__ */ new WeakMap();
	_signTransactionBlock$1 = /* @__PURE__ */ new WeakMap();
	_signTransaction$1 = /* @__PURE__ */ new WeakMap();
	_signAndExecuteTransactionBlock = /* @__PURE__ */ new WeakMap();
	_signAndExecuteTransaction$1 = /* @__PURE__ */ new WeakMap();
	return walletsApi.register(new UnsafeBurnerWallet());
}
function useWalletPropertiesChanged() {
	const { currentWallet } = useCurrentWallet();
	const updateWalletAccounts = useWalletStore((state) => state.updateWalletAccounts);
	(0, import_react.useEffect)(() => {
		return currentWallet?.features["standard:events"].on("change", ({ accounts }) => {
			if (accounts) updateWalletAccounts(accounts);
		});
	}, [currentWallet?.features, updateWalletAccounts]);
}
function useWalletsChanged(preferredWallets, walletFilter) {
	const setWalletRegistered = useWalletStore((state) => state.setWalletRegistered);
	const setWalletUnregistered = useWalletStore((state) => state.setWalletUnregistered);
	(0, import_react.useEffect)(() => {
		const walletsApi = getWallets();
		setWalletRegistered(getRegisteredWallets(preferredWallets, walletFilter));
		const unsubscribeFromRegister = walletsApi.on("register", () => {
			setWalletRegistered(getRegisteredWallets(preferredWallets, walletFilter));
		});
		const unsubscribeFromUnregister = walletsApi.on("unregister", (unregisteredWallet) => {
			setWalletUnregistered(getRegisteredWallets(preferredWallets, walletFilter), unregisteredWallet);
		});
		return () => {
			unsubscribeFromRegister();
			unsubscribeFromUnregister();
		};
	}, [
		preferredWallets,
		walletFilter,
		setWalletRegistered,
		setWalletUnregistered
	]);
}
var lightTheme = {
	blurs: { modalOverlay: "blur(0)" },
	backgroundColors: {
		primaryButton: "#F6F7F9",
		primaryButtonHover: "#F0F2F5",
		outlineButtonHover: "#F4F4F5",
		modalOverlay: "rgba(24 36 53 / 20%)",
		modalPrimary: "white",
		modalSecondary: "#F7F8F8",
		iconButton: "transparent",
		iconButtonHover: "#F0F1F2",
		dropdownMenu: "#FFFFFF",
		dropdownMenuSeparator: "#F3F6F8",
		walletItemSelected: "white",
		walletItemHover: "#3C424226"
	},
	borderColors: { outlineButton: "#E4E4E7" },
	colors: {
		primaryButton: "#373737",
		outlineButton: "#373737",
		iconButton: "#000000",
		body: "#182435",
		bodyMuted: "#767A81",
		bodyDanger: "#FF794B"
	},
	radii: {
		small: "6px",
		medium: "8px",
		large: "12px",
		xlarge: "16px"
	},
	shadows: {
		primaryButton: "0px 4px 12px rgba(0, 0, 0, 0.1)",
		walletItemSelected: "0px 2px 6px rgba(0, 0, 0, 0.05)"
	},
	fontWeights: {
		normal: "400",
		medium: "500",
		bold: "600"
	},
	fontSizes: {
		small: "14px",
		medium: "16px",
		large: "18px",
		xlarge: "20px"
	},
	typography: {
		fontFamily: "ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial, \"Noto Sans\", sans-serif, \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\", \"Noto Color Emoji\"",
		fontStyle: "normal",
		lineHeight: "1.3",
		letterSpacing: "1"
	}
};
function createWalletStore({ wallets: wallets$1, storage, storageKey, autoConnectEnabled }) {
	return createStore()(persist((set, get$2) => ({
		autoConnectEnabled,
		wallets: wallets$1,
		accounts: [],
		currentWallet: null,
		currentAccount: null,
		lastConnectedAccountAddress: null,
		lastConnectedWalletName: null,
		connectionStatus: "disconnected",
		supportedIntents: [],
		setConnectionStatus(connectionStatus2) {
			set(() => ({ connectionStatus: connectionStatus2 }));
		},
		setWalletConnected(wallet, connectedAccounts, selectedAccount, supportedIntents = []) {
			set(() => ({
				accounts: connectedAccounts,
				currentWallet: wallet,
				currentAccount: selectedAccount,
				lastConnectedWalletName: getWalletUniqueIdentifier(wallet),
				lastConnectedAccountAddress: selectedAccount?.address,
				connectionStatus: "connected",
				supportedIntents
			}));
		},
		setWalletDisconnected() {
			set(() => ({
				accounts: [],
				currentWallet: null,
				currentAccount: null,
				lastConnectedWalletName: null,
				lastConnectedAccountAddress: null,
				connectionStatus: "disconnected",
				supportedIntents: []
			}));
		},
		setAccountSwitched(selectedAccount) {
			set(() => ({
				currentAccount: selectedAccount,
				lastConnectedAccountAddress: selectedAccount.address
			}));
		},
		setWalletRegistered(updatedWallets) {
			set(() => ({ wallets: updatedWallets }));
		},
		setWalletUnregistered(updatedWallets, unregisteredWallet) {
			if (unregisteredWallet === get$2().currentWallet) set(() => ({
				wallets: updatedWallets,
				accounts: [],
				currentWallet: null,
				currentAccount: null,
				lastConnectedWalletName: null,
				lastConnectedAccountAddress: null,
				connectionStatus: "disconnected",
				supportedIntents: []
			}));
			else set(() => ({ wallets: updatedWallets }));
		},
		updateWalletAccounts(accounts) {
			const currentAccount = get$2().currentAccount;
			set(() => ({
				accounts,
				currentAccount: currentAccount && accounts.find(({ address }) => address === currentAccount.address) || accounts[0]
			}));
		}
	}), {
		name: storageKey,
		storage: createJSONStorage(() => storage),
		partialize: ({ lastConnectedWalletName, lastConnectedAccountAddress }) => ({
			lastConnectedWalletName,
			lastConnectedAccountAddress
		})
	}));
}
var themeVars = createGlobalThemeContract({
	blurs: { modalOverlay: "" },
	backgroundColors: {
		primaryButton: "",
		primaryButtonHover: "",
		outlineButtonHover: "",
		walletItemHover: "",
		walletItemSelected: "",
		modalOverlay: "",
		modalPrimary: "",
		modalSecondary: "",
		iconButton: "",
		iconButtonHover: "",
		dropdownMenu: "",
		dropdownMenuSeparator: ""
	},
	borderColors: { outlineButton: "" },
	colors: {
		primaryButton: "",
		outlineButton: "",
		body: "",
		bodyMuted: "",
		bodyDanger: "",
		iconButton: ""
	},
	radii: {
		small: "",
		medium: "",
		large: "",
		xlarge: ""
	},
	shadows: {
		primaryButton: "",
		walletItemSelected: ""
	},
	fontWeights: {
		normal: "",
		medium: "",
		bold: ""
	},
	fontSizes: {
		small: "",
		medium: "",
		large: "",
		xlarge: ""
	},
	typography: {
		fontFamily: "",
		fontStyle: "",
		lineHeight: "",
		letterSpacing: ""
	}
}, (_, path) => `dapp-kit-${path.join("-")}`);
function InjectedThemeStyles({ theme }) {
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)("style", {
		precedence: "default",
		href: "mysten-dapp-kit-theme",
		dangerouslySetInnerHTML: { __html: Array.isArray(theme) ? getDynamicThemeStyles(theme) : getStaticThemeStyles(theme) }
	});
}
function getDynamicThemeStyles(themes) {
	return themes.map(({ mediaQuery, selector, variables }) => {
		const themeStyles = getStaticThemeStyles(variables);
		const themeStylesWithSelectorPrefix = selector ? `${selector} ${themeStyles}` : themeStyles;
		return mediaQuery ? `@media ${mediaQuery}{${themeStylesWithSelectorPrefix}}` : themeStylesWithSelectorPrefix;
	}).join(" ");
}
function getStaticThemeStyles(theme) {
	return `${styleDataAttributeSelector} {${cssStringFromTheme(theme)}}`;
}
function cssStringFromTheme(theme) {
	return Object.entries(assignInlineVars(themeVars, theme)).map(([key, value]) => `${key}:${value};`).join("");
}
function WalletProvider({ preferredWallets = DEFAULT_PREFERRED_WALLETS, walletFilter = DEFAULT_WALLET_FILTER, storage = DEFAULT_STORAGE, storageKey = DEFAULT_STORAGE_KEY, enableUnsafeBurner = false, autoConnect = false, slushWallet, theme = lightTheme, children }) {
	const storeRef = (0, import_react.useRef)(createWalletStore({
		autoConnectEnabled: autoConnect,
		wallets: getRegisteredWallets(preferredWallets, walletFilter),
		storage: storage || createInMemoryStore(),
		storageKey
	}));
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(WalletContext.Provider, {
		value: storeRef.current,
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(WalletConnectionManager, {
			preferredWallets,
			walletFilter,
			enableUnsafeBurner,
			slushWallet,
			children: [theme ? /* @__PURE__ */ (0, import_jsx_runtime.jsx)(InjectedThemeStyles, { theme }) : null, children]
		})
	});
}
function WalletConnectionManager({ preferredWallets = DEFAULT_PREFERRED_WALLETS, walletFilter = DEFAULT_WALLET_FILTER, enableUnsafeBurner = false, slushWallet, children }) {
	useWalletsChanged(preferredWallets, walletFilter);
	useWalletPropertiesChanged();
	useSlushWallet(slushWallet);
	useUnsafeBurnerWallet(enableUnsafeBurner);
	useAutoConnectWallet();
	return children;
}
function createNetworkConfig(networkConfig) {
	function useNetworkConfig() {
		const { config } = useSuiClientContext();
		if (!config) throw new Error("No network config found");
		return config;
	}
	function useNetworkVariables() {
		const { variables } = useNetworkConfig();
		return variables ?? {};
	}
	function useNetworkVariable(name) {
		return useNetworkVariables()[name];
	}
	return {
		networkConfig,
		useNetworkConfig,
		useNetworkVariables,
		useNetworkVariable
	};
}
function useSuiClientInfiniteQuery(method, params, { queryKey = [], enabled = !!params, ...options } = {}) {
	const suiContext = useSuiClientContext();
	return useInfiniteQuery({
		...options,
		initialPageParam: null,
		queryKey: [
			suiContext.network,
			method,
			params,
			...queryKey
		],
		enabled,
		queryFn: ({ pageParam }) => suiContext.client[method]({
			...params ?? {},
			cursor: pageParam
		}),
		getNextPageParam: (lastPage) => lastPage.hasNextPage ? lastPage.nextCursor ?? null : null
	});
}
function useSuiClientMutation(method, options = {}) {
	const suiContext = useSuiClientContext();
	return useMutation({
		...options,
		mutationFn: async (params) => {
			return await suiContext.client[method](params);
		}
	});
}
function useSuiClientQueries({ queries, combine }) {
	const suiContext = useSuiClientContext();
	return useQueries({
		combine,
		queries: queries.map((query) => {
			const { method, params, options: { queryKey = [], ...restOptions } = {} } = query;
			return {
				...restOptions,
				queryKey: [
					suiContext.network,
					method,
					params,
					...queryKey
				],
				queryFn: async () => {
					return await suiContext.client[method](params);
				}
			};
		})
	});
}
function useReportTransactionEffects({ mutationKey, ...mutationOptions } = {}) {
	const { currentWallet } = useCurrentWallet();
	const currentAccount = useCurrentAccount();
	return useMutation({
		mutationKey: walletMutationKeys.reportTransactionEffects(mutationKey),
		mutationFn: async ({ effects, chain = currentWallet?.chains[0], account = currentAccount }) => {
			if (!currentWallet) throw new WalletNotConnectedError("No wallet is connected.");
			if (!account) throw new WalletNoAccountSelectedError("No wallet account is selected to report transaction effects for");
			const reportTransactionEffectsFeature = currentWallet.features["sui:reportTransactionEffects"];
			if (reportTransactionEffectsFeature) return await reportTransactionEffectsFeature.reportTransactionEffects({
				effects: Array.isArray(effects) ? toBase64(new Uint8Array(effects)) : effects,
				account,
				chain: chain ?? currentWallet?.chains[0]
			});
		},
		...mutationOptions
	});
}
function useSignAndExecuteTransaction({ mutationKey, execute, ...mutationOptions } = {}) {
	const { currentWallet, supportedIntents } = useCurrentWallet();
	const currentAccount = useCurrentAccount();
	const { client, network } = useSuiClientContext();
	const { mutate: reportTransactionEffects } = useReportTransactionEffects();
	const executeTransaction = execute ?? (async ({ bytes, signature }) => {
		const { digest, rawEffects } = await client.executeTransactionBlock({
			transactionBlock: bytes,
			signature,
			options: { showRawEffects: true }
		});
		return {
			digest,
			rawEffects,
			effects: toBase64(new Uint8Array(rawEffects)),
			bytes,
			signature
		};
	});
	return useMutation({
		mutationKey: walletMutationKeys.signAndExecuteTransaction(mutationKey),
		mutationFn: async ({ transaction, ...signTransactionArgs }) => {
			if (!currentWallet) throw new WalletNotConnectedError("No wallet is connected.");
			const signerAccount = signTransactionArgs.account ?? currentAccount;
			if (!signerAccount) throw new WalletNoAccountSelectedError("No wallet account is selected to sign the transaction with.");
			if (!currentWallet.features["sui:signTransaction"] && !currentWallet.features["sui:signTransactionBlock"]) throw new WalletFeatureNotSupportedError("This wallet doesn't support the `signTransaction` feature.");
			if (typeof transaction !== "string" && "setSenderIfNotSet" in transaction) transaction.setSenderIfNotSet(signerAccount.address);
			const chain = signTransactionArgs.chain ?? `sui:${network}`;
			const { signature, bytes } = await signTransaction(currentWallet, {
				...signTransactionArgs,
				transaction: { async toJSON() {
					return typeof transaction === "string" ? transaction : await transaction.toJSON({
						supportedIntents,
						client
					});
				} },
				account: signerAccount,
				chain
			});
			const result = await executeTransaction({
				bytes,
				signature
			});
			let effects;
			if ("effects" in result && result.effects?.bcs) effects = result.effects.bcs;
			else if ("rawEffects" in result) effects = toBase64(new Uint8Array(result.rawEffects));
			else throw new Error("Could not parse effects from transaction result.");
			reportTransactionEffects({
				effects,
				account: signerAccount,
				chain
			});
			return result;
		},
		...mutationOptions
	});
}
function useSignPersonalMessage({ mutationKey, ...mutationOptions } = {}) {
	const { currentWallet } = useCurrentWallet();
	const currentAccount = useCurrentAccount();
	const { network } = useSuiClientContext();
	return useMutation({
		mutationKey: walletMutationKeys.signPersonalMessage(mutationKey),
		mutationFn: async (signPersonalMessageArgs) => {
			if (!currentWallet) throw new WalletNotConnectedError("No wallet is connected.");
			const signerAccount = signPersonalMessageArgs.account ?? currentAccount;
			if (!signerAccount) throw new WalletNoAccountSelectedError("No wallet account is selected to sign the personal message with.");
			const signPersonalMessageFeature = currentWallet.features["sui:signPersonalMessage"];
			if (signPersonalMessageFeature) return await signPersonalMessageFeature.signPersonalMessage({
				...signPersonalMessageArgs,
				account: signerAccount,
				chain: signPersonalMessageArgs.chain ?? `sui:${network}`
			});
			const signMessageFeature = currentWallet.features["sui:signMessage"];
			if (signMessageFeature) {
				console.warn("This wallet doesn't support the `signPersonalMessage` feature... falling back to `signMessage`.");
				const { messageBytes, signature } = await signMessageFeature.signMessage({
					...signPersonalMessageArgs,
					account: signerAccount
				});
				return {
					bytes: messageBytes,
					signature
				};
			}
			throw new WalletFeatureNotSupportedError("This wallet doesn't support the `signPersonalMessage` feature.");
		},
		...mutationOptions
	});
}
function useSignTransaction({ mutationKey, ...mutationOptions } = {}) {
	const { currentWallet } = useCurrentWallet();
	const currentAccount = useCurrentAccount();
	const { client, network } = useSuiClientContext();
	const { mutate: reportTransactionEffects } = useReportTransactionEffects();
	return useMutation({
		mutationKey: walletMutationKeys.signTransaction(mutationKey),
		mutationFn: async ({ transaction, ...signTransactionArgs }) => {
			if (!currentWallet) throw new WalletNotConnectedError("No wallet is connected.");
			const signerAccount = signTransactionArgs.account ?? currentAccount;
			if (!signerAccount) throw new WalletNoAccountSelectedError("No wallet account is selected to sign the transaction with.");
			if (!currentWallet.features["sui:signTransaction"] && !currentWallet.features["sui:signTransactionBlock"]) throw new WalletFeatureNotSupportedError("This wallet doesn't support the `signTransaction` feature.");
			if (typeof transaction !== "string" && "setSenderIfNotSet" in transaction) transaction.setSenderIfNotSet(signerAccount.address);
			const chain = signTransactionArgs.chain ?? `sui:${network}`;
			const { bytes, signature } = await signTransaction(currentWallet, {
				...signTransactionArgs,
				transaction: { toJSON: async () => {
					return typeof transaction === "string" ? transaction : await transaction.toJSON({
						supportedIntents: [],
						client
					});
				} },
				account: signerAccount,
				chain
			});
			return {
				bytes,
				signature,
				reportTransactionEffects: (effects) => {
					reportTransactionEffects({
						effects,
						account: signerAccount,
						chain
					});
				}
			};
		},
		...mutationOptions
	});
}

//#endregion
export { ConnectButton, ConnectModal, SuiClientContext, SuiClientProvider, WalletProvider, createNetworkConfig, getSuiClientQuery, lightTheme, useAccounts, useAutoConnectWallet, useConnectWallet, useCurrentAccount, useCurrentWallet, useDisconnectWallet, useReportTransactionEffects, useResolveSuiNSName, useSignAndExecuteTransaction, useSignPersonalMessage, useSignTransaction, useSuiClient, useSuiClientContext, useSuiClientInfiniteQuery, useSuiClientMutation, useSuiClientQueries, useSuiClientQuery, useSuiClientSuspenseQuery, useSwitchAccount, useWallets };
//# sourceMappingURL=@mysten_dapp-kit.js.map