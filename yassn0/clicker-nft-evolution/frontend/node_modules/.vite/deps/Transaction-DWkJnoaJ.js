//#region node_modules/.pnpm/@scure+base@1.2.6/node_modules/@scure/base/lib/esm/index.js
function isBytes$1(a) {
	return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array";
}
/** Asserts something is Uint8Array. */
function abytes$1(b, ...lengths) {
	if (!isBytes$1(b)) throw new Error("Uint8Array expected");
	if (lengths.length > 0 && !lengths.includes(b.length)) throw new Error("Uint8Array expected of length " + lengths + ", got length=" + b.length);
}
function isArrayOf(isString, arr) {
	if (!Array.isArray(arr)) return false;
	if (arr.length === 0) return true;
	if (isString) return arr.every((item) => typeof item === "string");
	else return arr.every((item) => Number.isSafeInteger(item));
}
function afn(input) {
	if (typeof input !== "function") throw new Error("function expected");
	return true;
}
function astr(label, input) {
	if (typeof input !== "string") throw new Error(`${label}: string expected`);
	return true;
}
function anumber$1(n) {
	if (!Number.isSafeInteger(n)) throw new Error(`invalid integer: ${n}`);
}
function aArr(input) {
	if (!Array.isArray(input)) throw new Error("array expected");
}
function astrArr(label, input) {
	if (!isArrayOf(true, input)) throw new Error(`${label}: array of strings expected`);
}
function anumArr(label, input) {
	if (!isArrayOf(false, input)) throw new Error(`${label}: array of numbers expected`);
}
/**
* @__NO_SIDE_EFFECTS__
*/
function chain(...args) {
	const id = (a) => a;
	const wrap = (a, b) => (c) => a(b(c));
	return {
		encode: args.map((x) => x.encode).reduceRight(wrap, id),
		decode: args.map((x) => x.decode).reduce(wrap, id)
	};
}
/**
* Encodes integer radix representation to array of strings using alphabet and back.
* Could also be array of strings.
* @__NO_SIDE_EFFECTS__
*/
function alphabet(letters) {
	const lettersA = typeof letters === "string" ? letters.split("") : letters;
	const len = lettersA.length;
	astrArr("alphabet", lettersA);
	const indexes = new Map(lettersA.map((l, i) => [l, i]));
	return {
		encode: (digits) => {
			aArr(digits);
			return digits.map((i) => {
				if (!Number.isSafeInteger(i) || i < 0 || i >= len) throw new Error(`alphabet.encode: digit index outside alphabet "${i}". Allowed: ${letters}`);
				return lettersA[i];
			});
		},
		decode: (input) => {
			aArr(input);
			return input.map((letter) => {
				astr("alphabet.decode", letter);
				const i = indexes.get(letter);
				if (i === void 0) throw new Error(`Unknown letter: "${letter}". Allowed: ${letters}`);
				return i;
			});
		}
	};
}
/**
* @__NO_SIDE_EFFECTS__
*/
function join(separator = "") {
	astr("join", separator);
	return {
		encode: (from) => {
			astrArr("join.decode", from);
			return from.join(separator);
		},
		decode: (to) => {
			astr("join.decode", to);
			return to.split(separator);
		}
	};
}
/**
* Pad strings array so it has integer number of bits
* @__NO_SIDE_EFFECTS__
*/
function padding(bits, chr = "=") {
	anumber$1(bits);
	astr("padding", chr);
	return {
		encode(data) {
			astrArr("padding.encode", data);
			while (data.length * bits % 8) data.push(chr);
			return data;
		},
		decode(input) {
			astrArr("padding.decode", input);
			let end = input.length;
			if (end * bits % 8) throw new Error("padding: invalid, string should have whole number of bytes");
			for (; end > 0 && input[end - 1] === chr; end--) if ((end - 1) * bits % 8 === 0) throw new Error("padding: invalid, string has too much padding");
			return input.slice(0, end);
		}
	};
}
/**
* @__NO_SIDE_EFFECTS__
*/
function normalize(fn) {
	afn(fn);
	return {
		encode: (from) => from,
		decode: (to) => fn(to)
	};
}
/**
* Slow: O(n^2) time complexity
*/
function convertRadix(data, from, to) {
	if (from < 2) throw new Error(`convertRadix: invalid from=${from}, base cannot be less than 2`);
	if (to < 2) throw new Error(`convertRadix: invalid to=${to}, base cannot be less than 2`);
	aArr(data);
	if (!data.length) return [];
	let pos = 0;
	const res = [];
	const digits = Array.from(data, (d) => {
		anumber$1(d);
		if (d < 0 || d >= from) throw new Error(`invalid integer: ${d}`);
		return d;
	});
	const dlen = digits.length;
	while (true) {
		let carry = 0;
		let done = true;
		for (let i = pos; i < dlen; i++) {
			const digit = digits[i];
			const fromCarry = from * carry;
			const digitBase = fromCarry + digit;
			if (!Number.isSafeInteger(digitBase) || fromCarry / from !== carry || digitBase - digit !== fromCarry) throw new Error("convertRadix: carry overflow");
			const div = digitBase / to;
			carry = digitBase % to;
			const rounded = Math.floor(div);
			digits[i] = rounded;
			if (!Number.isSafeInteger(rounded) || rounded * to + carry !== digitBase) throw new Error("convertRadix: carry overflow");
			if (!done) continue;
			else if (!rounded) pos = i;
			else done = false;
		}
		res.push(carry);
		if (done) break;
	}
	for (let i = 0; i < data.length - 1 && data[i] === 0; i++) res.push(0);
	return res.reverse();
}
var gcd = (a, b) => b === 0 ? a : gcd(b, a % b);
var radix2carry = /* @__NO_SIDE_EFFECTS__ */ (from, to) => from + (to - gcd(from, to));
var powers = /* @__PURE__ */ (() => {
	let res = [];
	for (let i = 0; i < 40; i++) res.push(2 ** i);
	return res;
})();
/**
* Implemented with numbers, because BigInt is 5x slower
*/
function convertRadix2(data, from, to, padding$1) {
	aArr(data);
	if (from <= 0 || from > 32) throw new Error(`convertRadix2: wrong from=${from}`);
	if (to <= 0 || to > 32) throw new Error(`convertRadix2: wrong to=${to}`);
	if (/* @__PURE__ */ radix2carry(from, to) > 32) throw new Error(`convertRadix2: carry overflow from=${from} to=${to} carryBits=${/* @__PURE__ */ radix2carry(from, to)}`);
	let carry = 0;
	let pos = 0;
	const max = powers[from];
	const mask = powers[to] - 1;
	const res = [];
	for (const n of data) {
		anumber$1(n);
		if (n >= max) throw new Error(`convertRadix2: invalid data word=${n} from=${from}`);
		carry = carry << from | n;
		if (pos + from > 32) throw new Error(`convertRadix2: carry overflow pos=${pos} from=${from}`);
		pos += from;
		for (; pos >= to; pos -= to) res.push((carry >> pos - to & mask) >>> 0);
		const pow = powers[pos];
		if (pow === void 0) throw new Error("invalid carry");
		carry &= pow - 1;
	}
	carry = carry << to - pos & mask;
	if (!padding$1 && pos >= from) throw new Error("Excess padding");
	if (!padding$1 && carry > 0) throw new Error(`Non-zero padding: ${carry}`);
	if (padding$1 && pos > 0) res.push(carry >>> 0);
	return res;
}
/**
* @__NO_SIDE_EFFECTS__
*/
function radix(num) {
	anumber$1(num);
	const _256 = 2 ** 8;
	return {
		encode: (bytes) => {
			if (!isBytes$1(bytes)) throw new Error("radix.encode input should be Uint8Array");
			return convertRadix(Array.from(bytes), _256, num);
		},
		decode: (digits) => {
			anumArr("radix.decode", digits);
			return Uint8Array.from(convertRadix(digits, num, _256));
		}
	};
}
/**
* If both bases are power of same number (like `2**8 <-> 2**64`),
* there is a linear algorithm. For now we have implementation for power-of-two bases only.
* @__NO_SIDE_EFFECTS__
*/
function radix2(bits, revPadding = false) {
	anumber$1(bits);
	if (bits <= 0 || bits > 32) throw new Error("radix2: bits should be in (0..32]");
	if (/* @__PURE__ */ radix2carry(8, bits) > 32 || /* @__PURE__ */ radix2carry(bits, 8) > 32) throw new Error("radix2: carry overflow");
	return {
		encode: (bytes) => {
			if (!isBytes$1(bytes)) throw new Error("radix2.encode input should be Uint8Array");
			return convertRadix2(Array.from(bytes), 8, bits, !revPadding);
		},
		decode: (digits) => {
			anumArr("radix2.decode", digits);
			return Uint8Array.from(convertRadix2(digits, bits, 8, revPadding));
		}
	};
}
function unsafeWrapper(fn) {
	afn(fn);
	return function(...args) {
		try {
			return fn.apply(null, args);
		} catch (e) {}
	};
}
/**
* base16 encoding from RFC 4648.
* @example
* ```js
* base16.encode(Uint8Array.from([0x12, 0xab]));
* // => '12AB'
* ```
*/
const base16 = chain(radix2(4), alphabet("0123456789ABCDEF"), join(""));
/**
* base32 encoding from RFC 4648. Has padding.
* Use `base32nopad` for unpadded version.
* Also check out `base32hex`, `base32hexnopad`, `base32crockford`.
* @example
* ```js
* base32.encode(Uint8Array.from([0x12, 0xab]));
* // => 'CKVQ===='
* base32.decode('CKVQ====');
* // => Uint8Array.from([0x12, 0xab])
* ```
*/
const base32 = chain(radix2(5), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"), padding(5), join(""));
/**
* base32 encoding from RFC 4648. No padding.
* Use `base32` for padded version.
* Also check out `base32hex`, `base32hexnopad`, `base32crockford`.
* @example
* ```js
* base32nopad.encode(Uint8Array.from([0x12, 0xab]));
* // => 'CKVQ'
* base32nopad.decode('CKVQ');
* // => Uint8Array.from([0x12, 0xab])
* ```
*/
const base32nopad = chain(radix2(5), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"), join(""));
/**
* base32 encoding from RFC 4648. Padded. Compared to ordinary `base32`, slightly different alphabet.
* Use `base32hexnopad` for unpadded version.
* @example
* ```js
* base32hex.encode(Uint8Array.from([0x12, 0xab]));
* // => '2ALG===='
* base32hex.decode('2ALG====');
* // => Uint8Array.from([0x12, 0xab])
* ```
*/
const base32hex = chain(radix2(5), alphabet("0123456789ABCDEFGHIJKLMNOPQRSTUV"), padding(5), join(""));
/**
* base32 encoding from RFC 4648. No padding. Compared to ordinary `base32`, slightly different alphabet.
* Use `base32hex` for padded version.
* @example
* ```js
* base32hexnopad.encode(Uint8Array.from([0x12, 0xab]));
* // => '2ALG'
* base32hexnopad.decode('2ALG');
* // => Uint8Array.from([0x12, 0xab])
* ```
*/
const base32hexnopad = chain(radix2(5), alphabet("0123456789ABCDEFGHIJKLMNOPQRSTUV"), join(""));
/**
* base32 encoding from RFC 4648. Doug Crockford's version.
* https://www.crockford.com/base32.html
* @example
* ```js
* base32crockford.encode(Uint8Array.from([0x12, 0xab]));
* // => '2ANG'
* base32crockford.decode('2ANG');
* // => Uint8Array.from([0x12, 0xab])
* ```
*/
const base32crockford = chain(radix2(5), alphabet("0123456789ABCDEFGHJKMNPQRSTVWXYZ"), join(""), normalize((s) => s.toUpperCase().replace(/O/g, "0").replace(/[IL]/g, "1")));
var hasBase64Builtin = /* @__PURE__ */ (() => typeof Uint8Array.from([]).toBase64 === "function" && typeof Uint8Array.fromBase64 === "function")();
var decodeBase64Builtin = (s, isUrl) => {
	astr("base64", s);
	const re = isUrl ? /^[A-Za-z0-9=_-]+$/ : /^[A-Za-z0-9=+/]+$/;
	const alphabet$1 = isUrl ? "base64url" : "base64";
	if (s.length > 0 && !re.test(s)) throw new Error("invalid base64");
	return Uint8Array.fromBase64(s, {
		alphabet: alphabet$1,
		lastChunkHandling: "strict"
	});
};
/**
* base64 from RFC 4648. Padded.
* Use `base64nopad` for unpadded version.
* Also check out `base64url`, `base64urlnopad`.
* Falls back to built-in function, when available.
* @example
* ```js
* base64.encode(Uint8Array.from([0x12, 0xab]));
* // => 'Eqs='
* base64.decode('Eqs=');
* // => Uint8Array.from([0x12, 0xab])
* ```
*/
const base64 = hasBase64Builtin ? {
	encode(b) {
		abytes$1(b);
		return b.toBase64();
	},
	decode(s) {
		return decodeBase64Builtin(s, false);
	}
} : chain(radix2(6), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"), padding(6), join(""));
/**
* base64 from RFC 4648. No padding.
* Use `base64` for padded version.
* @example
* ```js
* base64nopad.encode(Uint8Array.from([0x12, 0xab]));
* // => 'Eqs'
* base64nopad.decode('Eqs');
* // => Uint8Array.from([0x12, 0xab])
* ```
*/
const base64nopad = chain(radix2(6), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"), join(""));
/**
* base64 from RFC 4648, using URL-safe alphabet. Padded.
* Use `base64urlnopad` for unpadded version.
* Falls back to built-in function, when available.
* @example
* ```js
* base64url.encode(Uint8Array.from([0x12, 0xab]));
* // => 'Eqs='
* base64url.decode('Eqs=');
* // => Uint8Array.from([0x12, 0xab])
* ```
*/
const base64url = hasBase64Builtin ? {
	encode(b) {
		abytes$1(b);
		return b.toBase64({ alphabet: "base64url" });
	},
	decode(s) {
		return decodeBase64Builtin(s, true);
	}
} : chain(radix2(6), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"), padding(6), join(""));
/**
* base64 from RFC 4648, using URL-safe alphabet. No padding.
* Use `base64url` for padded version.
* @example
* ```js
* base64urlnopad.encode(Uint8Array.from([0x12, 0xab]));
* // => 'Eqs'
* base64urlnopad.decode('Eqs');
* // => Uint8Array.from([0x12, 0xab])
* ```
*/
const base64urlnopad = chain(radix2(6), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"), join(""));
var genBase58 = /* @__NO_SIDE_EFFECTS__ */ (abc) => chain(radix(58), alphabet(abc), join(""));
/**
* base58: base64 without ambigous characters +, /, 0, O, I, l.
* Quadratic (O(n^2)) - so, can't be used on large inputs.
* @example
* ```js
* base58.decode('01abcdef');
* // => '3UhJW'
* ```
*/
const base58 = /* @__PURE__ */ genBase58("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");
var BECH_ALPHABET = chain(alphabet("qpzry9x8gf2tvdw0s3jn54khce6mua7l"), join(""));
var POLYMOD_GENERATORS = [
	996825010,
	642813549,
	513874426,
	1027748829,
	705979059
];
function bech32Polymod(pre) {
	const b = pre >> 25;
	let chk = (pre & 33554431) << 5;
	for (let i = 0; i < POLYMOD_GENERATORS.length; i++) if ((b >> i & 1) === 1) chk ^= POLYMOD_GENERATORS[i];
	return chk;
}
function bechChecksum(prefix, words, encodingConst = 1) {
	const len = prefix.length;
	let chk = 1;
	for (let i = 0; i < len; i++) {
		const c = prefix.charCodeAt(i);
		if (c < 33 || c > 126) throw new Error(`Invalid prefix (${prefix})`);
		chk = bech32Polymod(chk) ^ c >> 5;
	}
	chk = bech32Polymod(chk);
	for (let i = 0; i < len; i++) chk = bech32Polymod(chk) ^ prefix.charCodeAt(i) & 31;
	for (let v of words) chk = bech32Polymod(chk) ^ v;
	for (let i = 0; i < 6; i++) chk = bech32Polymod(chk);
	chk ^= encodingConst;
	return BECH_ALPHABET.encode(convertRadix2([chk % powers[30]], 30, 5, false));
}
/**
* @__NO_SIDE_EFFECTS__
*/
function genBech32(encoding) {
	const ENCODING_CONST = encoding === "bech32" ? 1 : 734539939;
	const _words = radix2(5);
	const fromWords = _words.decode;
	const toWords = _words.encode;
	const fromWordsUnsafe = unsafeWrapper(fromWords);
	function encode(prefix, words, limit = 90) {
		astr("bech32.encode prefix", prefix);
		if (isBytes$1(words)) words = Array.from(words);
		anumArr("bech32.encode", words);
		const plen = prefix.length;
		if (plen === 0) throw new TypeError(`Invalid prefix length ${plen}`);
		const actualLength = plen + 7 + words.length;
		if (limit !== false && actualLength > limit) throw new TypeError(`Length ${actualLength} exceeds limit ${limit}`);
		const lowered = prefix.toLowerCase();
		const sum = bechChecksum(lowered, words, ENCODING_CONST);
		return `${lowered}1${BECH_ALPHABET.encode(words)}${sum}`;
	}
	function decode(str, limit = 90) {
		astr("bech32.decode input", str);
		const slen = str.length;
		if (slen < 8 || limit !== false && slen > limit) throw new TypeError(`invalid string length: ${slen} (${str}). Expected (8..${limit})`);
		const lowered = str.toLowerCase();
		if (str !== lowered && str !== str.toUpperCase()) throw new Error(`String must be lowercase or uppercase`);
		const sepIndex = lowered.lastIndexOf("1");
		if (sepIndex === 0 || sepIndex === -1) throw new Error(`Letter "1" must be present between prefix and data only`);
		const prefix = lowered.slice(0, sepIndex);
		const data = lowered.slice(sepIndex + 1);
		if (data.length < 6) throw new Error("Data must be at least 6 characters long");
		const words = BECH_ALPHABET.decode(data).slice(0, -6);
		const sum = bechChecksum(prefix, words, ENCODING_CONST);
		if (!data.endsWith(sum)) throw new Error(`Invalid checksum in ${str}: expected "${sum}"`);
		return {
			prefix,
			words
		};
	}
	const decodeUnsafe = unsafeWrapper(decode);
	function decodeToBytes(str) {
		const { prefix, words } = decode(str, false);
		return {
			prefix,
			words,
			bytes: fromWords(words)
		};
	}
	function encodeFromBytes(prefix, bytes) {
		return encode(prefix, toWords(bytes));
	}
	return {
		encode,
		decode,
		encodeFromBytes,
		decodeToBytes,
		decodeUnsafe,
		fromWords,
		fromWordsUnsafe,
		toWords
	};
}
/**
* bech32 from BIP 173. Operates on words.
* For high-level, check out scure-btc-signer:
* https://github.com/paulmillr/scure-btc-signer.
*/
const bech32 = genBech32("bech32");
/**
* bech32m from BIP 350. Operates on words.
* It was to mitigate `bech32` weaknesses.
* For high-level, check out scure-btc-signer:
* https://github.com/paulmillr/scure-btc-signer.
*/
const bech32m = genBech32("bech32m");
var hasHexBuiltin$1 = /* @__PURE__ */ (() => typeof Uint8Array.from([]).toHex === "function" && typeof Uint8Array.fromHex === "function")();
var hexBuiltin = {
	encode(data) {
		abytes$1(data);
		return data.toHex();
	},
	decode(s) {
		astr("hex", s);
		return Uint8Array.fromHex(s);
	}
};
/**
* hex string decoder. Uses built-in function, when available.
* @example
* ```js
* const b = hex.decode("0102ff"); // => new Uint8Array([ 1, 2, 255 ])
* const str = hex.encode(b); // "0102ff"
* ```
*/
const hex = hasHexBuiltin$1 ? hexBuiltin : chain(radix2(4), alphabet("0123456789abcdef"), join(""), normalize((s) => {
	if (typeof s !== "string" || s.length % 2 !== 0) throw new TypeError(`hex.decode: expected string, got ${typeof s} with length ${s.length}`);
	return s.toLowerCase();
}));

//#endregion
//#region node_modules/.pnpm/@mysten+utils@0.2.0/node_modules/@mysten/utils/dist/esm/b58.js
var toBase58 = (buffer) => base58.encode(buffer);
var fromBase58 = (str) => base58.decode(str);

//#endregion
//#region node_modules/.pnpm/@mysten+utils@0.2.0/node_modules/@mysten/utils/dist/esm/b64.js
function fromBase64(base64String$1) {
	return Uint8Array.from(atob(base64String$1), (char) => char.charCodeAt(0));
}
var CHUNK_SIZE = 8192;
function toBase64(bytes) {
	if (bytes.length < CHUNK_SIZE) return btoa(String.fromCharCode(...bytes));
	let output = "";
	for (var i = 0; i < bytes.length; i += CHUNK_SIZE) {
		const chunk$1 = bytes.slice(i, i + CHUNK_SIZE);
		output += String.fromCharCode(...chunk$1);
	}
	return btoa(output);
}

//#endregion
//#region node_modules/.pnpm/@mysten+utils@0.2.0/node_modules/@mysten/utils/dist/esm/hex.js
function fromHex(hexStr) {
	const normalized = hexStr.startsWith("0x") ? hexStr.slice(2) : hexStr;
	const padded = normalized.length % 2 === 0 ? normalized : `0${normalized}`;
	const intArr = padded.match(/[0-9a-fA-F]{2}/g)?.map((byte) => parseInt(byte, 16)) ?? [];
	if (intArr.length !== padded.length / 2) throw new Error(`Invalid hex string ${hexStr}`);
	return Uint8Array.from(intArr);
}
function toHex(bytes) {
	return bytes.reduce((str, byte) => str + byte.toString(16).padStart(2, "0"), "");
}

//#endregion
//#region node_modules/.pnpm/@mysten+utils@0.2.0/node_modules/@mysten/utils/dist/esm/chunk.js
function chunk(array$1, size) {
	return Array.from({ length: Math.ceil(array$1.length / size) }, (_, i) => {
		return array$1.slice(i * size, (i + 1) * size);
	});
}

//#endregion
//#region node_modules/.pnpm/@mysten+utils@0.2.0/node_modules/@mysten/utils/dist/esm/dataloader.js
var DataLoader = class {
	constructor(batchLoadFn, options) {
		if (typeof batchLoadFn !== "function") throw new TypeError(`DataLoader must be constructed with a function which accepts Array<key> and returns Promise<Array<value>>, but got: ${batchLoadFn}.`);
		this._batchLoadFn = batchLoadFn;
		this._maxBatchSize = getValidMaxBatchSize(options);
		this._batchScheduleFn = getValidBatchScheduleFn(options);
		this._cacheKeyFn = getValidCacheKeyFn(options);
		this._cacheMap = getValidCacheMap(options);
		this._batch = null;
		this.name = getValidName(options);
	}
	/**
	* Loads a key, returning a `Promise` for the value represented by that key.
	*/
	load(key) {
		if (key === null || key === void 0) throw new TypeError(`The loader.load() function must be called with a value, but got: ${String(key)}.`);
		const batch = getCurrentBatch(this);
		const cacheMap$1 = this._cacheMap;
		let cacheKey;
		if (cacheMap$1) {
			cacheKey = this._cacheKeyFn(key);
			const cachedPromise = cacheMap$1.get(cacheKey);
			if (cachedPromise) {
				const cacheHits = batch.cacheHits || (batch.cacheHits = []);
				return new Promise((resolve) => {
					cacheHits.push(() => {
						resolve(cachedPromise);
					});
				});
			}
		}
		batch.keys.push(key);
		const promise = new Promise((resolve, reject) => {
			batch.callbacks.push({
				resolve,
				reject
			});
		});
		if (cacheMap$1) cacheMap$1.set(cacheKey, promise);
		return promise;
	}
	/**
	* Loads multiple keys, promising an array of values:
	*
	*     var [ a, b ] = await myLoader.loadMany([ 'a', 'b' ]);
	*
	* This is similar to the more verbose:
	*
	*     var [ a, b ] = await Promise.all([
	*       myLoader.load('a'),
	*       myLoader.load('b')
	*     ]);
	*
	* However it is different in the case where any load fails. Where
	* Promise.all() would reject, loadMany() always resolves, however each result
	* is either a value or an Error instance.
	*
	*     var [ a, b, c ] = await myLoader.loadMany([ 'a', 'b', 'badkey' ]);
	*     // c instanceof Error
	*
	*/
	loadMany(keys) {
		if (!isArrayLike(keys)) throw new TypeError(`The loader.loadMany() function must be called with Array<key>, but got: ${keys}.`);
		const loadPromises = [];
		for (let i = 0; i < keys.length; i++) loadPromises.push(this.load(keys[i]).catch((error) => error));
		return Promise.all(loadPromises);
	}
	/**
	* Clears the value at `key` from the cache, if it exists. Returns itself for
	* method chaining.
	*/
	clear(key) {
		const cacheMap$1 = this._cacheMap;
		if (cacheMap$1) {
			const cacheKey = this._cacheKeyFn(key);
			cacheMap$1.delete(cacheKey);
		}
		return this;
	}
	/**
	* Clears the entire cache. To be used when some event results in unknown
	* invalidations across this particular `DataLoader`. Returns itself for
	* method chaining.
	*/
	clearAll() {
		const cacheMap$1 = this._cacheMap;
		if (cacheMap$1) cacheMap$1.clear();
		return this;
	}
	/**
	* Adds the provided key and value to the cache. If the key already
	* exists, no change is made. Returns itself for method chaining.
	*
	* To prime the cache with an error at a key, provide an Error instance.
	*/
	prime(key, value) {
		const cacheMap$1 = this._cacheMap;
		if (cacheMap$1) {
			const cacheKey = this._cacheKeyFn(key);
			if (cacheMap$1.get(cacheKey) === void 0) {
				let promise;
				if (value instanceof Error) {
					promise = Promise.reject(value);
					promise.catch(() => {});
				} else promise = Promise.resolve(value);
				cacheMap$1.set(cacheKey, promise);
			}
		}
		return this;
	}
};
var enqueuePostPromiseJob = typeof process === "object" && typeof process.nextTick === "function" ? function(fn) {
	if (!resolvedPromise) resolvedPromise = Promise.resolve();
	resolvedPromise.then(() => {
		process.nextTick(fn);
	});
} : typeof setImmediate === "function" ? function(fn) {
	setImmediate(fn);
} : function(fn) {
	setTimeout(fn);
};
var resolvedPromise;
function getCurrentBatch(loader) {
	const existingBatch = loader._batch;
	if (existingBatch !== null && !existingBatch.hasDispatched && existingBatch.keys.length < loader._maxBatchSize) return existingBatch;
	const newBatch = {
		hasDispatched: false,
		keys: [],
		callbacks: []
	};
	loader._batch = newBatch;
	loader._batchScheduleFn(() => {
		dispatchBatch(loader, newBatch);
	});
	return newBatch;
}
function dispatchBatch(loader, batch) {
	batch.hasDispatched = true;
	if (batch.keys.length === 0) {
		resolveCacheHits(batch);
		return;
	}
	let batchPromise;
	try {
		batchPromise = loader._batchLoadFn(batch.keys);
	} catch (e) {
		return failedDispatch(loader, batch, /* @__PURE__ */ new TypeError(`DataLoader must be constructed with a function which accepts Array<key> and returns Promise<Array<value>>, but the function errored synchronously: ${String(e)}.`));
	}
	if (!batchPromise || typeof batchPromise.then !== "function") return failedDispatch(loader, batch, /* @__PURE__ */ new TypeError(`DataLoader must be constructed with a function which accepts Array<key> and returns Promise<Array<value>>, but the function did not return a Promise: ${String(batchPromise)}.`));
	Promise.resolve(batchPromise).then((values) => {
		if (!isArrayLike(values)) throw new TypeError(`DataLoader must be constructed with a function which accepts Array<key> and returns Promise<Array<value>>, but the function did not return a Promise of an Array: ${String(values)}.`);
		if (values.length !== batch.keys.length) throw new TypeError(`DataLoader must be constructed with a function which accepts Array<key> and returns Promise<Array<value>>, but the function did not return a Promise of an Array of the same length as the Array of keys.

Keys:
${String(batch.keys)}

Values:
${String(values)}`);
		resolveCacheHits(batch);
		for (let i = 0; i < batch.callbacks.length; i++) {
			const value = values[i];
			if (value instanceof Error) batch.callbacks[i].reject(value);
			else batch.callbacks[i].resolve(value);
		}
	}).catch((error) => {
		failedDispatch(loader, batch, error);
	});
}
function failedDispatch(loader, batch, error) {
	resolveCacheHits(batch);
	for (let i = 0; i < batch.keys.length; i++) {
		loader.clear(batch.keys[i]);
		batch.callbacks[i].reject(error);
	}
}
function resolveCacheHits(batch) {
	if (batch.cacheHits) for (let i = 0; i < batch.cacheHits.length; i++) batch.cacheHits[i]();
}
function getValidMaxBatchSize(options) {
	if (!(!options || options.batch !== false)) return 1;
	const maxBatchSize = options && options.maxBatchSize;
	if (maxBatchSize === void 0) return Infinity;
	if (typeof maxBatchSize !== "number" || maxBatchSize < 1) throw new TypeError(`maxBatchSize must be a positive number: ${maxBatchSize}`);
	return maxBatchSize;
}
function getValidBatchScheduleFn(options) {
	const batchScheduleFn = options && options.batchScheduleFn;
	if (batchScheduleFn === void 0) return enqueuePostPromiseJob;
	if (typeof batchScheduleFn !== "function") throw new TypeError(`batchScheduleFn must be a function: ${batchScheduleFn}`);
	return batchScheduleFn;
}
function getValidCacheKeyFn(options) {
	const cacheKeyFn = options && options.cacheKeyFn;
	if (cacheKeyFn === void 0) return (key) => key;
	if (typeof cacheKeyFn !== "function") throw new TypeError(`cacheKeyFn must be a function: ${cacheKeyFn}`);
	return cacheKeyFn;
}
function getValidCacheMap(options) {
	if (!(!options || options.cache !== false)) return null;
	const cacheMap$1 = options && options.cacheMap;
	if (cacheMap$1 === void 0) return /* @__PURE__ */ new Map();
	if (cacheMap$1 !== null) {
		const missingFunctions = [
			"get",
			"set",
			"delete",
			"clear"
		].filter((fnName) => cacheMap$1 && typeof cacheMap$1[fnName] !== "function");
		if (missingFunctions.length !== 0) throw new TypeError("Custom cacheMap missing methods: " + missingFunctions.join(", "));
	}
	return cacheMap$1;
}
function getValidName(options) {
	if (options && options.name) return options.name;
	return null;
}
function isArrayLike(x) {
	return typeof x === "object" && x !== null && "length" in x && typeof x.length === "number" && (x.length === 0 || x.length > 0 && Object.prototype.hasOwnProperty.call(x, x.length - 1));
}

//#endregion
//#region node_modules/.pnpm/@mysten+bcs@1.9.2/node_modules/@mysten/bcs/dist/esm/uleb.js
function ulebEncode(num) {
	let bigNum = BigInt(num);
	const arr = [];
	let len = 0;
	if (bigNum === 0n) return [0];
	while (bigNum > 0) {
		arr[len] = Number(bigNum & 127n);
		bigNum >>= 7n;
		if (bigNum > 0n) arr[len] |= 128;
		len += 1;
	}
	return arr;
}
function ulebDecode(arr) {
	let total = 0n;
	let shift = 0n;
	let len = 0;
	while (true) {
		if (len >= arr.length) throw new Error("ULEB decode error: buffer overflow");
		const byte = arr[len];
		len += 1;
		total += BigInt(byte & 127) << shift;
		if ((byte & 128) === 0) break;
		shift += 7n;
	}
	if (total > BigInt(Number.MAX_SAFE_INTEGER)) throw new Error("ULEB decode error: value exceeds MAX_SAFE_INTEGER");
	return {
		value: Number(total),
		length: len
	};
}

//#endregion
//#region node_modules/.pnpm/@mysten+bcs@1.9.2/node_modules/@mysten/bcs/dist/esm/reader.js
var BcsReader = class {
	/**
	* @param {Uint8Array} data Data to use as a buffer.
	*/
	constructor(data) {
		this.bytePosition = 0;
		this.dataView = new DataView(data.buffer, data.byteOffset, data.byteLength);
	}
	/**
	* Shift current cursor position by `bytes`.
	*
	* @param {Number} bytes Number of bytes to
	* @returns {this} Self for possible chaining.
	*/
	shift(bytes) {
		this.bytePosition += bytes;
		return this;
	}
	/**
	* Read U8 value from the buffer and shift cursor by 1.
	* @returns
	*/
	read8() {
		const value = this.dataView.getUint8(this.bytePosition);
		this.shift(1);
		return value;
	}
	/**
	* Read U16 value from the buffer and shift cursor by 2.
	* @returns
	*/
	read16() {
		const value = this.dataView.getUint16(this.bytePosition, true);
		this.shift(2);
		return value;
	}
	/**
	* Read U32 value from the buffer and shift cursor by 4.
	* @returns
	*/
	read32() {
		const value = this.dataView.getUint32(this.bytePosition, true);
		this.shift(4);
		return value;
	}
	/**
	* Read U64 value from the buffer and shift cursor by 8.
	* @returns
	*/
	read64() {
		const value1 = this.read32();
		const result = this.read32().toString(16) + value1.toString(16).padStart(8, "0");
		return BigInt("0x" + result).toString(10);
	}
	/**
	* Read U128 value from the buffer and shift cursor by 16.
	*/
	read128() {
		const value1 = BigInt(this.read64());
		const result = BigInt(this.read64()).toString(16) + value1.toString(16).padStart(16, "0");
		return BigInt("0x" + result).toString(10);
	}
	/**
	* Read U128 value from the buffer and shift cursor by 32.
	* @returns
	*/
	read256() {
		const value1 = BigInt(this.read128());
		const result = BigInt(this.read128()).toString(16) + value1.toString(16).padStart(32, "0");
		return BigInt("0x" + result).toString(10);
	}
	/**
	* Read `num` number of bytes from the buffer and shift cursor by `num`.
	* @param num Number of bytes to read.
	*/
	readBytes(num) {
		const start = this.bytePosition + this.dataView.byteOffset;
		const value = new Uint8Array(this.dataView.buffer, start, num);
		this.shift(num);
		return value;
	}
	/**
	* Read ULEB value - an integer of varying size. Used for enum indexes and
	* vector lengths.
	* @returns {Number} The ULEB value.
	*/
	readULEB() {
		const start = this.bytePosition + this.dataView.byteOffset;
		const { value, length } = ulebDecode(new Uint8Array(this.dataView.buffer, start));
		this.shift(length);
		return value;
	}
	/**
	* Read a BCS vector: read a length and then apply function `cb` X times
	* where X is the length of the vector, defined as ULEB in BCS bytes.
	* @param cb Callback to process elements of vector.
	* @returns {Array<Any>} Array of the resulting values, returned by callback.
	*/
	readVec(cb) {
		const length = this.readULEB();
		const result = [];
		for (let i = 0; i < length; i++) result.push(cb(this, i, length));
		return result;
	}
};

//#endregion
//#region node_modules/.pnpm/@mysten+bcs@1.9.2/node_modules/@mysten/bcs/dist/esm/utils.js
function encodeStr(data, encoding) {
	switch (encoding) {
		case "base58": return toBase58(data);
		case "base64": return toBase64(data);
		case "hex": return toHex(data);
		default: throw new Error("Unsupported encoding, supported values are: base64, hex");
	}
}
function splitGenericParameters(str, genericSeparators = ["<", ">"]) {
	const [left, right] = genericSeparators;
	const tok = [];
	let word = "";
	let nestedAngleBrackets = 0;
	for (let i = 0; i < str.length; i++) {
		const char = str[i];
		if (char === left) nestedAngleBrackets++;
		if (char === right) nestedAngleBrackets--;
		if (nestedAngleBrackets === 0 && char === ",") {
			tok.push(word.trim());
			word = "";
			continue;
		}
		word += char;
	}
	tok.push(word.trim());
	return tok;
}

//#endregion
//#region node_modules/.pnpm/@mysten+bcs@1.9.2/node_modules/@mysten/bcs/dist/esm/writer.js
var BcsWriter = class {
	constructor({ initialSize = 1024, maxSize = Infinity, allocateSize = 1024 } = {}) {
		this.bytePosition = 0;
		this.size = initialSize;
		this.maxSize = maxSize;
		this.allocateSize = allocateSize;
		this.dataView = new DataView(new ArrayBuffer(initialSize));
	}
	ensureSizeOrGrow(bytes) {
		const requiredSize = this.bytePosition + bytes;
		if (requiredSize > this.size) {
			const nextSize = Math.min(this.maxSize, Math.max(this.size + requiredSize, this.size + this.allocateSize));
			if (requiredSize > nextSize) throw new Error(`Attempting to serialize to BCS, but buffer does not have enough size. Allocated size: ${this.size}, Max size: ${this.maxSize}, Required size: ${requiredSize}`);
			this.size = nextSize;
			const nextBuffer = new ArrayBuffer(this.size);
			new Uint8Array(nextBuffer).set(new Uint8Array(this.dataView.buffer));
			this.dataView = new DataView(nextBuffer);
		}
	}
	/**
	* Shift current cursor position by `bytes`.
	*
	* @param {Number} bytes Number of bytes to
	* @returns {this} Self for possible chaining.
	*/
	shift(bytes) {
		this.bytePosition += bytes;
		return this;
	}
	/**
	* Write a U8 value into a buffer and shift cursor position by 1.
	* @param {Number} value Value to write.
	* @returns {this}
	*/
	write8(value) {
		this.ensureSizeOrGrow(1);
		this.dataView.setUint8(this.bytePosition, Number(value));
		return this.shift(1);
	}
	/**
	* Write a U8 value into a buffer and shift cursor position by 1.
	* @param {Number} value Value to write.
	* @returns {this}
	*/
	writeBytes(bytes) {
		this.ensureSizeOrGrow(bytes.length);
		for (let i = 0; i < bytes.length; i++) this.dataView.setUint8(this.bytePosition + i, bytes[i]);
		return this.shift(bytes.length);
	}
	/**
	* Write a U16 value into a buffer and shift cursor position by 2.
	* @param {Number} value Value to write.
	* @returns {this}
	*/
	write16(value) {
		this.ensureSizeOrGrow(2);
		this.dataView.setUint16(this.bytePosition, Number(value), true);
		return this.shift(2);
	}
	/**
	* Write a U32 value into a buffer and shift cursor position by 4.
	* @param {Number} value Value to write.
	* @returns {this}
	*/
	write32(value) {
		this.ensureSizeOrGrow(4);
		this.dataView.setUint32(this.bytePosition, Number(value), true);
		return this.shift(4);
	}
	/**
	* Write a U64 value into a buffer and shift cursor position by 8.
	* @param {bigint} value Value to write.
	* @returns {this}
	*/
	write64(value) {
		toLittleEndian(BigInt(value), 8).forEach((el) => this.write8(el));
		return this;
	}
	/**
	* Write a U128 value into a buffer and shift cursor position by 16.
	*
	* @param {bigint} value Value to write.
	* @returns {this}
	*/
	write128(value) {
		toLittleEndian(BigInt(value), 16).forEach((el) => this.write8(el));
		return this;
	}
	/**
	* Write a U256 value into a buffer and shift cursor position by 16.
	*
	* @param {bigint} value Value to write.
	* @returns {this}
	*/
	write256(value) {
		toLittleEndian(BigInt(value), 32).forEach((el) => this.write8(el));
		return this;
	}
	/**
	* Write a ULEB value into a buffer and shift cursor position by number of bytes
	* written.
	* @param {Number} value Value to write.
	* @returns {this}
	*/
	writeULEB(value) {
		ulebEncode(value).forEach((el) => this.write8(el));
		return this;
	}
	/**
	* Write a vector into a buffer by first writing the vector length and then calling
	* a callback on each passed value.
	*
	* @param {Array<Any>} vector Array of elements to write.
	* @param {WriteVecCb} cb Callback to call on each element of the vector.
	* @returns {this}
	*/
	writeVec(vector$1, cb) {
		this.writeULEB(vector$1.length);
		Array.from(vector$1).forEach((el, i) => cb(this, el, i, vector$1.length));
		return this;
	}
	/**
	* Adds support for iterations over the object.
	* @returns {Uint8Array}
	*/
	*[Symbol.iterator]() {
		for (let i = 0; i < this.bytePosition; i++) yield this.dataView.getUint8(i);
		return this.toBytes();
	}
	/**
	* Get underlying buffer taking only value bytes (in case initial buffer size was bigger).
	* @returns {Uint8Array} Resulting bcs.
	*/
	toBytes() {
		return new Uint8Array(this.dataView.buffer.slice(0, this.bytePosition));
	}
	/**
	* Represent data as 'hex' or 'base64'
	* @param encoding Encoding to use: 'base64' or 'hex'
	*/
	toString(encoding) {
		return encodeStr(this.toBytes(), encoding);
	}
};
function toLittleEndian(bigint$1, size) {
	const result = new Uint8Array(size);
	let i = 0;
	while (bigint$1 > 0) {
		result[i] = Number(bigint$1 % BigInt(256));
		bigint$1 = bigint$1 / BigInt(256);
		i += 1;
	}
	return result;
}

//#endregion
//#region node_modules/.pnpm/@mysten+bcs@1.9.2/node_modules/@mysten/bcs/dist/esm/bcs-type.js
var __typeError$3 = (msg) => {
	throw TypeError(msg);
};
var __accessCheck$3 = (obj, member, msg) => member.has(obj) || __typeError$3("Cannot " + msg);
var __privateGet$3 = (obj, member, getter) => (__accessCheck$3(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd$3 = (obj, member, value) => member.has(obj) ? __typeError$3("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet$3 = (obj, member, value, setter) => (__accessCheck$3(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var _write, _serialize, _schema, _bytes;
var _BcsType = class _BcsType$1 {
	constructor(options) {
		__privateAdd$3(this, _write);
		__privateAdd$3(this, _serialize);
		this.name = options.name;
		this.read = options.read;
		this.serializedSize = options.serializedSize ?? (() => null);
		__privateSet$3(this, _write, options.write);
		__privateSet$3(this, _serialize, options.serialize ?? ((value, options2) => {
			const writer = new BcsWriter({
				initialSize: this.serializedSize(value) ?? void 0,
				...options2
			});
			__privateGet$3(this, _write).call(this, value, writer);
			return writer.toBytes();
		}));
		this.validate = options.validate ?? (() => {});
	}
	write(value, writer) {
		this.validate(value);
		__privateGet$3(this, _write).call(this, value, writer);
	}
	serialize(value, options) {
		this.validate(value);
		return new SerializedBcs(this, __privateGet$3(this, _serialize).call(this, value, options));
	}
	parse(bytes) {
		const reader = new BcsReader(bytes);
		return this.read(reader);
	}
	fromHex(hex$1) {
		return this.parse(fromHex(hex$1));
	}
	fromBase58(b64) {
		return this.parse(fromBase58(b64));
	}
	fromBase64(b64) {
		return this.parse(fromBase64(b64));
	}
	transform({ name, input, output, validate: validate$1 }) {
		return new _BcsType$1({
			name: name ?? this.name,
			read: (reader) => output ? output(this.read(reader)) : this.read(reader),
			write: (value, writer) => __privateGet$3(this, _write).call(this, input ? input(value) : value, writer),
			serializedSize: (value) => this.serializedSize(input ? input(value) : value),
			serialize: (value, options) => __privateGet$3(this, _serialize).call(this, input ? input(value) : value, options),
			validate: (value) => {
				validate$1?.(value);
				this.validate(input ? input(value) : value);
			}
		});
	}
};
_write = /* @__PURE__ */ new WeakMap();
_serialize = /* @__PURE__ */ new WeakMap();
var BcsType = _BcsType;
var SERIALIZED_BCS_BRAND = Symbol.for("@mysten/serialized-bcs");
function isSerializedBcs(obj) {
	return !!obj && typeof obj === "object" && obj[SERIALIZED_BCS_BRAND] === true;
}
var SerializedBcs = class {
	constructor(schema, bytes) {
		__privateAdd$3(this, _schema);
		__privateAdd$3(this, _bytes);
		__privateSet$3(this, _schema, schema);
		__privateSet$3(this, _bytes, bytes);
	}
	get [SERIALIZED_BCS_BRAND]() {
		return true;
	}
	toBytes() {
		return __privateGet$3(this, _bytes);
	}
	toHex() {
		return toHex(__privateGet$3(this, _bytes));
	}
	toBase64() {
		return toBase64(__privateGet$3(this, _bytes));
	}
	toBase58() {
		return toBase58(__privateGet$3(this, _bytes));
	}
	parse() {
		return __privateGet$3(this, _schema).parse(__privateGet$3(this, _bytes));
	}
};
_schema = /* @__PURE__ */ new WeakMap();
_bytes = /* @__PURE__ */ new WeakMap();
function fixedSizeBcsType({ size, ...options }) {
	return new BcsType({
		...options,
		serializedSize: () => size
	});
}
function uIntBcsType({ readMethod, writeMethod, ...options }) {
	return fixedSizeBcsType({
		...options,
		read: (reader) => reader[readMethod](),
		write: (value, writer) => writer[writeMethod](value),
		validate: (value) => {
			if (value < 0 || value > options.maxValue) throw new TypeError(`Invalid ${options.name} value: ${value}. Expected value in range 0-${options.maxValue}`);
			options.validate?.(value);
		}
	});
}
function bigUIntBcsType({ readMethod, writeMethod, ...options }) {
	return fixedSizeBcsType({
		...options,
		read: (reader) => reader[readMethod](),
		write: (value, writer) => writer[writeMethod](BigInt(value)),
		validate: (val) => {
			const value = BigInt(val);
			if (value < 0 || value > options.maxValue) throw new TypeError(`Invalid ${options.name} value: ${value}. Expected value in range 0-${options.maxValue}`);
			options.validate?.(value);
		}
	});
}
function dynamicSizeBcsType({ serialize, ...options }) {
	const type = new BcsType({
		...options,
		serialize,
		write: (value, writer) => {
			for (const byte of type.serialize(value).toBytes()) writer.write8(byte);
		}
	});
	return type;
}
function stringLikeBcsType({ toBytes: toBytes$1, fromBytes, ...options }) {
	return new BcsType({
		...options,
		read: (reader) => {
			const length = reader.readULEB();
			return fromBytes(reader.readBytes(length));
		},
		write: (hex$1, writer) => {
			const bytes = toBytes$1(hex$1);
			writer.writeULEB(bytes.length);
			for (let i = 0; i < bytes.length; i++) writer.write8(bytes[i]);
		},
		serialize: (value) => {
			const bytes = toBytes$1(value);
			const size = ulebEncode(bytes.length);
			const result = new Uint8Array(size.length + bytes.length);
			result.set(size, 0);
			result.set(bytes, size.length);
			return result;
		},
		validate: (value) => {
			if (typeof value !== "string") throw new TypeError(`Invalid ${options.name} value: ${value}. Expected string`);
			options.validate?.(value);
		}
	});
}
function lazyBcsType(cb) {
	let lazyType = null;
	function getType() {
		if (!lazyType) lazyType = cb();
		return lazyType;
	}
	return new BcsType({
		name: "lazy",
		read: (data) => getType().read(data),
		serializedSize: (value) => getType().serializedSize(value),
		write: (value, writer) => getType().write(value, writer),
		serialize: (value, options) => getType().serialize(value, options).toBytes()
	});
}
var BcsStruct = class extends BcsType {
	constructor({ name, fields, ...options }) {
		const canonicalOrder = Object.entries(fields);
		super({
			name,
			serializedSize: (values) => {
				let total = 0;
				for (const [field, type] of canonicalOrder) {
					const size = type.serializedSize(values[field]);
					if (size == null) return null;
					total += size;
				}
				return total;
			},
			read: (reader) => {
				const result = {};
				for (const [field, type] of canonicalOrder) result[field] = type.read(reader);
				return result;
			},
			write: (value, writer) => {
				for (const [field, type] of canonicalOrder) type.write(value[field], writer);
			},
			...options,
			validate: (value) => {
				options?.validate?.(value);
				if (typeof value !== "object" || value == null) throw new TypeError(`Expected object, found ${typeof value}`);
			}
		});
	}
};
var BcsEnum = class extends BcsType {
	constructor({ fields, ...options }) {
		const canonicalOrder = Object.entries(fields);
		super({
			read: (reader) => {
				const index = reader.readULEB();
				const enumEntry = canonicalOrder[index];
				if (!enumEntry) throw new TypeError(`Unknown value ${index} for enum ${options.name}`);
				const [kind, type] = enumEntry;
				return {
					[kind]: type?.read(reader) ?? true,
					$kind: kind
				};
			},
			write: (value, writer) => {
				const [name, val] = Object.entries(value).filter(([name2]) => Object.hasOwn(fields, name2))[0];
				for (let i = 0; i < canonicalOrder.length; i++) {
					const [optionName, optionType] = canonicalOrder[i];
					if (optionName === name) {
						writer.writeULEB(i);
						optionType?.write(val, writer);
						return;
					}
				}
			},
			...options,
			validate: (value) => {
				options?.validate?.(value);
				if (typeof value !== "object" || value == null) throw new TypeError(`Expected object, found ${typeof value}`);
				const keys = Object.keys(value).filter((k) => value[k] !== void 0 && Object.hasOwn(fields, k));
				if (keys.length !== 1) throw new TypeError(`Expected object with one key, but found ${keys.length} for type ${options.name}}`);
				const [variant$1] = keys;
				if (!Object.hasOwn(fields, variant$1)) throw new TypeError(`Invalid enum variant ${variant$1}`);
			}
		});
	}
};
var BcsTuple = class extends BcsType {
	constructor({ fields, name, ...options }) {
		super({
			name: name ?? `(${fields.map((t) => t.name).join(", ")})`,
			serializedSize: (values) => {
				let total = 0;
				for (let i = 0; i < fields.length; i++) {
					const size = fields[i].serializedSize(values[i]);
					if (size == null) return null;
					total += size;
				}
				return total;
			},
			read: (reader) => {
				const result = [];
				for (const field of fields) result.push(field.read(reader));
				return result;
			},
			write: (value, writer) => {
				for (let i = 0; i < fields.length; i++) fields[i].write(value[i], writer);
			},
			...options,
			validate: (value) => {
				options?.validate?.(value);
				if (!Array.isArray(value)) throw new TypeError(`Expected array, found ${typeof value}`);
				if (value.length !== fields.length) throw new TypeError(`Expected array of length ${fields.length}, found ${value.length}`);
			}
		});
	}
};

//#endregion
//#region node_modules/.pnpm/@mysten+bcs@1.9.2/node_modules/@mysten/bcs/dist/esm/bcs.js
function fixedArray(size, type, options) {
	return new BcsType({
		read: (reader) => {
			const result = new Array(size);
			for (let i = 0; i < size; i++) result[i] = type.read(reader);
			return result;
		},
		write: (value, writer) => {
			for (const item of value) type.write(item, writer);
		},
		...options,
		name: options?.name ?? `${type.name}[${size}]`,
		validate: (value) => {
			options?.validate?.(value);
			if (!value || typeof value !== "object" || !("length" in value)) throw new TypeError(`Expected array, found ${typeof value}`);
			if (value.length !== size) throw new TypeError(`Expected array of length ${size}, found ${value.length}`);
		}
	});
}
function option(type) {
	return bcs.enum(`Option<${type.name}>`, {
		None: null,
		Some: type
	}).transform({
		input: (value) => {
			if (value == null) return { None: true };
			return { Some: value };
		},
		output: (value) => {
			if (value.$kind === "Some") return value.Some;
			return null;
		}
	});
}
function vector(type, options) {
	return new BcsType({
		read: (reader) => {
			const length = reader.readULEB();
			const result = new Array(length);
			for (let i = 0; i < length; i++) result[i] = type.read(reader);
			return result;
		},
		write: (value, writer) => {
			writer.writeULEB(value.length);
			for (const item of value) type.write(item, writer);
		},
		...options,
		name: options?.name ?? `vector<${type.name}>`,
		validate: (value) => {
			options?.validate?.(value);
			if (!value || typeof value !== "object" || !("length" in value)) throw new TypeError(`Expected array, found ${typeof value}`);
		}
	});
}
function map(keyType, valueType) {
	return bcs.vector(bcs.tuple([keyType, valueType])).transform({
		name: `Map<${keyType.name}, ${valueType.name}>`,
		input: (value) => {
			return [...value.entries()];
		},
		output: (value) => {
			const result = /* @__PURE__ */ new Map();
			for (const [key, val] of value) result.set(key, val);
			return result;
		}
	});
}
var bcs = {
	u8(options) {
		return uIntBcsType({
			readMethod: "read8",
			writeMethod: "write8",
			size: 1,
			maxValue: 2 ** 8 - 1,
			...options,
			name: options?.name ?? "u8"
		});
	},
	u16(options) {
		return uIntBcsType({
			readMethod: "read16",
			writeMethod: "write16",
			size: 2,
			maxValue: 2 ** 16 - 1,
			...options,
			name: options?.name ?? "u16"
		});
	},
	u32(options) {
		return uIntBcsType({
			readMethod: "read32",
			writeMethod: "write32",
			size: 4,
			maxValue: 2 ** 32 - 1,
			...options,
			name: options?.name ?? "u32"
		});
	},
	u64(options) {
		return bigUIntBcsType({
			readMethod: "read64",
			writeMethod: "write64",
			size: 8,
			maxValue: 2n ** 64n - 1n,
			...options,
			name: options?.name ?? "u64"
		});
	},
	u128(options) {
		return bigUIntBcsType({
			readMethod: "read128",
			writeMethod: "write128",
			size: 16,
			maxValue: 2n ** 128n - 1n,
			...options,
			name: options?.name ?? "u128"
		});
	},
	u256(options) {
		return bigUIntBcsType({
			readMethod: "read256",
			writeMethod: "write256",
			size: 32,
			maxValue: 2n ** 256n - 1n,
			...options,
			name: options?.name ?? "u256"
		});
	},
	bool(options) {
		return fixedSizeBcsType({
			size: 1,
			read: (reader) => reader.read8() === 1,
			write: (value, writer) => writer.write8(value ? 1 : 0),
			...options,
			name: options?.name ?? "bool",
			validate: (value) => {
				options?.validate?.(value);
				if (typeof value !== "boolean") throw new TypeError(`Expected boolean, found ${typeof value}`);
			}
		});
	},
	uleb128(options) {
		return dynamicSizeBcsType({
			read: (reader) => reader.readULEB(),
			serialize: (value) => {
				return Uint8Array.from(ulebEncode(value));
			},
			...options,
			name: options?.name ?? "uleb128"
		});
	},
	bytes(size, options) {
		return fixedSizeBcsType({
			size,
			read: (reader) => reader.readBytes(size),
			write: (value, writer) => {
				writer.writeBytes(new Uint8Array(value));
			},
			...options,
			name: options?.name ?? `bytes[${size}]`,
			validate: (value) => {
				options?.validate?.(value);
				if (!value || typeof value !== "object" || !("length" in value)) throw new TypeError(`Expected array, found ${typeof value}`);
				if (value.length !== size) throw new TypeError(`Expected array of length ${size}, found ${value.length}`);
			}
		});
	},
	byteVector(options) {
		return new BcsType({
			read: (reader) => {
				const length = reader.readULEB();
				return reader.readBytes(length);
			},
			write: (value, writer) => {
				const array$1 = new Uint8Array(value);
				writer.writeULEB(array$1.length);
				writer.writeBytes(array$1);
			},
			...options,
			name: options?.name ?? "vector<u8>",
			serializedSize: (value) => {
				const length = "length" in value ? value.length : null;
				return length == null ? null : ulebEncode(length).length + length;
			},
			validate: (value) => {
				options?.validate?.(value);
				if (!value || typeof value !== "object" || !("length" in value)) throw new TypeError(`Expected array, found ${typeof value}`);
			}
		});
	},
	string(options) {
		return stringLikeBcsType({
			toBytes: (value) => new TextEncoder().encode(value),
			fromBytes: (bytes) => new TextDecoder().decode(bytes),
			...options,
			name: options?.name ?? "string"
		});
	},
	fixedArray,
	option,
	vector,
	tuple(fields, options) {
		return new BcsTuple({
			fields,
			...options
		});
	},
	struct(name, fields, options) {
		return new BcsStruct({
			name,
			fields,
			...options
		});
	},
	enum(name, fields, options) {
		return new BcsEnum({
			name,
			fields,
			...options
		});
	},
	map,
	lazy(cb) {
		return lazyBcsType(cb);
	}
};

//#endregion
//#region node_modules/.pnpm/@mysten+sui@1.45.2_typescript@5.9.3/node_modules/@mysten/sui/dist/esm/utils/suins.js
var SUI_NS_NAME_REGEX = /^(?!.*(^(?!@)|[-.@])($|[-.@]))(?:[a-z0-9-]{0,63}(?:\.[a-z0-9-]{0,63})*)?@[a-z0-9-]{0,63}$/i;
var SUI_NS_DOMAIN_REGEX = /^(?!.*(^|[-.])($|[-.]))(?:[a-z0-9-]{0,63}\.)+sui$/i;
var MAX_SUI_NS_NAME_LENGTH = 235;
function isValidSuiNSName(name) {
	if (name.length > MAX_SUI_NS_NAME_LENGTH) return false;
	if (name.includes("@")) return SUI_NS_NAME_REGEX.test(name);
	return SUI_NS_DOMAIN_REGEX.test(name);
}
function normalizeSuiNSName(name, format = "at") {
	const lowerCase = name.toLowerCase();
	let parts;
	if (lowerCase.includes("@")) {
		if (!SUI_NS_NAME_REGEX.test(lowerCase)) throw new Error(`Invalid SuiNS name ${name}`);
		const [labels, domain] = lowerCase.split("@");
		parts = [...labels ? labels.split(".") : [], domain];
	} else {
		if (!SUI_NS_DOMAIN_REGEX.test(lowerCase)) throw new Error(`Invalid SuiNS name ${name}`);
		parts = lowerCase.split(".").slice(0, -1);
	}
	if (format === "dot") return `${parts.join(".")}.sui`;
	return `${parts.slice(0, -1).join(".")}@${parts[parts.length - 1]}`;
}

//#endregion
//#region node_modules/.pnpm/@mysten+sui@1.45.2_typescript@5.9.3/node_modules/@mysten/sui/dist/esm/utils/move-registry.js
var NAME_PATTERN = /^([a-z0-9]+(?:-[a-z0-9]+)*)$/;
var VERSION_REGEX = /^\d+$/;
var MAX_APP_SIZE = 64;
var NAME_SEPARATOR$1 = "/";
var isValidNamedPackage = (name) => {
	const parts = name.split(NAME_SEPARATOR$1);
	if (parts.length < 2 || parts.length > 3) return false;
	const [org, app, version] = parts;
	if (version !== void 0 && !VERSION_REGEX.test(version)) return false;
	if (!isValidSuiNSName(org)) return false;
	return NAME_PATTERN.test(app) && app.length < MAX_APP_SIZE;
};
var isValidNamedType = (type) => {
	const splitType = type.split(/::|<|>|,/);
	for (const t of splitType) if (t.includes(NAME_SEPARATOR$1) && !isValidNamedPackage(t)) return false;
	return true;
};

//#endregion
//#region node_modules/.pnpm/@mysten+sui@1.45.2_typescript@5.9.3/node_modules/@mysten/sui/dist/esm/utils/sui-types.js
var TX_DIGEST_LENGTH = 32;
function isValidTransactionDigest(value) {
	try {
		return fromBase58(value).length === TX_DIGEST_LENGTH;
	} catch {
		return false;
	}
}
var SUI_ADDRESS_LENGTH = 32;
function isValidSuiAddress(value) {
	return isHex(value) && getHexByteLength(value) === SUI_ADDRESS_LENGTH;
}
function isValidSuiObjectId(value) {
	return isValidSuiAddress(value);
}
function parseTypeTag(type) {
	if (!type.includes("::")) return type;
	return parseStructTag(type);
}
function parseStructTag(type) {
	const [address, module] = type.split("::");
	const isMvrPackage = isValidNamedPackage(address);
	const rest = type.slice(address.length + module.length + 4);
	const name = rest.includes("<") ? rest.slice(0, rest.indexOf("<")) : rest;
	const typeParams = rest.includes("<") ? splitGenericParameters(rest.slice(rest.indexOf("<") + 1, rest.lastIndexOf(">"))).map((typeParam) => parseTypeTag(typeParam.trim())) : [];
	return {
		address: isMvrPackage ? address : normalizeSuiAddress(address),
		module,
		name,
		typeParams
	};
}
function normalizeStructTag(type) {
	const { address, module, name, typeParams } = typeof type === "string" ? parseStructTag(type) : type;
	return `${address}::${module}::${name}${typeParams?.length > 0 ? `<${typeParams.map((typeParam) => typeof typeParam === "string" ? typeParam : normalizeStructTag(typeParam)).join(",")}>` : ""}`;
}
function normalizeSuiAddress(value, forceAdd0x = false) {
	let address = value.toLowerCase();
	if (!forceAdd0x && address.startsWith("0x")) address = address.slice(2);
	return `0x${address.padStart(SUI_ADDRESS_LENGTH * 2, "0")}`;
}
function normalizeSuiObjectId(value, forceAdd0x = false) {
	return normalizeSuiAddress(value, forceAdd0x);
}
function isHex(value) {
	return /^(0x|0X)?[a-fA-F0-9]+$/.test(value) && value.length % 2 === 0;
}
function getHexByteLength(value) {
	return /^(0x|0X)/.test(value) ? (value.length - 2) / 2 : value.length / 2;
}

//#endregion
//#region node_modules/.pnpm/@mysten+sui@1.45.2_typescript@5.9.3/node_modules/@mysten/sui/dist/esm/utils/constants.js
var MOVE_STDLIB_ADDRESS = "0x1";
var SUI_FRAMEWORK_ADDRESS = "0x2";
var SUI_CLOCK_OBJECT_ID = normalizeSuiObjectId("0x6");
var SUI_TYPE_ARG = `${SUI_FRAMEWORK_ADDRESS}::sui::SUI`;
var SUI_SYSTEM_STATE_OBJECT_ID = normalizeSuiObjectId("0x5");
var SUI_RANDOM_OBJECT_ID = normalizeSuiObjectId("0x8");

//#endregion
//#region node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/esm/crypto.js
const crypto = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;

//#endregion
//#region node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/esm/utils.js
/**
* Utilities for hex, bytes, CSPRNG.
* @module
*/
/** Checks if something is Uint8Array. Be careful: nodejs Buffer will return true. */
function isBytes(a) {
	return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array";
}
/** Asserts something is positive integer. */
function anumber(n) {
	if (!Number.isSafeInteger(n) || n < 0) throw new Error("positive integer expected, got " + n);
}
/** Asserts something is Uint8Array. */
function abytes(b, ...lengths) {
	if (!isBytes(b)) throw new Error("Uint8Array expected");
	if (lengths.length > 0 && !lengths.includes(b.length)) throw new Error("Uint8Array expected of length " + lengths + ", got length=" + b.length);
}
/** Asserts something is hash */
function ahash(h) {
	if (typeof h !== "function" || typeof h.create !== "function") throw new Error("Hash should be wrapped by utils.createHasher");
	anumber(h.outputLen);
	anumber(h.blockLen);
}
/** Asserts a hash instance has not been destroyed / finished */
function aexists(instance, checkFinished = true) {
	if (instance.destroyed) throw new Error("Hash instance has been destroyed");
	if (checkFinished && instance.finished) throw new Error("Hash#digest() has already been called");
}
/** Asserts output is properly-sized byte array */
function aoutput(out, instance) {
	abytes(out);
	const min = instance.outputLen;
	if (out.length < min) throw new Error("digestInto() expects output buffer of length at least " + min);
}
/** Cast u8 / u16 / u32 to u32. */
function u32(arr) {
	return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
}
/** Zeroize a byte array. Warning: JS provides no guarantees. */
function clean(...arrays) {
	for (let i = 0; i < arrays.length; i++) arrays[i].fill(0);
}
/** Create DataView of an array for easy byte-level manipulation. */
function createView(arr) {
	return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
}
/** Is current platform little-endian? Most are. Big-Endian platform: IBM */
const isLE = /* @__PURE__ */ (() => new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68)();
/** The byte swap operation for uint32 */
function byteSwap(word) {
	return word << 24 & 4278190080 | word << 8 & 16711680 | word >>> 8 & 65280 | word >>> 24 & 255;
}
/** Conditionally byte swap if on a big-endian platform */
const swap8IfBE = isLE ? (n) => n : (n) => byteSwap(n);
/** In place byte swap for Uint32Array */
function byteSwap32(arr) {
	for (let i = 0; i < arr.length; i++) arr[i] = byteSwap(arr[i]);
	return arr;
}
const swap32IfBE = isLE ? (u) => u : byteSwap32;
var hasHexBuiltin = /* @__PURE__ */ (() => typeof Uint8Array.from([]).toHex === "function" && typeof Uint8Array.fromHex === "function")();
var hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
/**
* Convert byte array to hex string. Uses built-in function, when available.
* @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'
*/
function bytesToHex(bytes) {
	abytes(bytes);
	if (hasHexBuiltin) return bytes.toHex();
	let hex$1 = "";
	for (let i = 0; i < bytes.length; i++) hex$1 += hexes[bytes[i]];
	return hex$1;
}
var asciis = {
	_0: 48,
	_9: 57,
	A: 65,
	F: 70,
	a: 97,
	f: 102
};
function asciiToBase16(ch) {
	if (ch >= asciis._0 && ch <= asciis._9) return ch - asciis._0;
	if (ch >= asciis.A && ch <= asciis.F) return ch - (asciis.A - 10);
	if (ch >= asciis.a && ch <= asciis.f) return ch - (asciis.a - 10);
}
/**
* Convert hex string to byte array. Uses built-in function, when available.
* @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])
*/
function hexToBytes(hex$1) {
	if (typeof hex$1 !== "string") throw new Error("hex string expected, got " + typeof hex$1);
	if (hasHexBuiltin) return Uint8Array.fromHex(hex$1);
	const hl = hex$1.length;
	const al = hl / 2;
	if (hl % 2) throw new Error("hex string expected, got unpadded hex of length " + hl);
	const array$1 = new Uint8Array(al);
	for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
		const n1 = asciiToBase16(hex$1.charCodeAt(hi));
		const n2 = asciiToBase16(hex$1.charCodeAt(hi + 1));
		if (n1 === void 0 || n2 === void 0) {
			const char = hex$1[hi] + hex$1[hi + 1];
			throw new Error("hex string expected, got non-hex character \"" + char + "\" at index " + hi);
		}
		array$1[ai] = n1 * 16 + n2;
	}
	return array$1;
}
/**
* Converts string to bytes using UTF8 encoding.
* @example utf8ToBytes('abc') // Uint8Array.from([97, 98, 99])
*/
function utf8ToBytes(str) {
	if (typeof str !== "string") throw new Error("string expected");
	return new Uint8Array(new TextEncoder().encode(str));
}
/**
* Normalizes (non-hex) string or Uint8Array to Uint8Array.
* Warning: when Uint8Array is passed, it would NOT get copied.
* Keep in mind for future mutable operations.
*/
function toBytes(data) {
	if (typeof data === "string") data = utf8ToBytes(data);
	abytes(data);
	return data;
}
/**
* Helper for KDFs: consumes uint8array or string.
* When string is passed, does utf8 decoding, using TextDecoder.
*/
function kdfInputToBytes(data) {
	if (typeof data === "string") data = utf8ToBytes(data);
	abytes(data);
	return data;
}
/** Copies several Uint8Arrays into one. */
function concatBytes(...arrays) {
	let sum = 0;
	for (let i = 0; i < arrays.length; i++) {
		const a = arrays[i];
		abytes(a);
		sum += a.length;
	}
	const res = new Uint8Array(sum);
	for (let i = 0, pad = 0; i < arrays.length; i++) {
		const a = arrays[i];
		res.set(a, pad);
		pad += a.length;
	}
	return res;
}
function checkOpts(defaults, opts) {
	if (opts !== void 0 && {}.toString.call(opts) !== "[object Object]") throw new Error("options should be object or undefined");
	return Object.assign(defaults, opts);
}
/** For runtime check if class implements interface */
var Hash = class {};
/** Wraps hash function, creating an interface on top of it */
function createHasher(hashCons) {
	const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
	const tmp = hashCons();
	hashC.outputLen = tmp.outputLen;
	hashC.blockLen = tmp.blockLen;
	hashC.create = () => hashCons();
	return hashC;
}
function createOptHasher(hashCons) {
	const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
	const tmp = hashCons({});
	hashC.outputLen = tmp.outputLen;
	hashC.blockLen = tmp.blockLen;
	hashC.create = (opts) => hashCons(opts);
	return hashC;
}
/** Cryptographically secure PRNG. Uses internal OS-level `crypto.getRandomValues`. */
function randomBytes(bytesLength = 32) {
	if (crypto && typeof crypto.getRandomValues === "function") return crypto.getRandomValues(new Uint8Array(bytesLength));
	if (crypto && typeof crypto.randomBytes === "function") return Uint8Array.from(crypto.randomBytes(bytesLength));
	throw new Error("crypto.getRandomValues must be defined");
}

//#endregion
//#region node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/esm/_blake.js
/**
* Internal blake variable.
* For BLAKE2b, the two extra permutations for rounds 10 and 11 are SIGMA[10..11] = SIGMA[0..1].
*/
const BSIGMA = /* @__PURE__ */ Uint8Array.from([
	0,
	1,
	2,
	3,
	4,
	5,
	6,
	7,
	8,
	9,
	10,
	11,
	12,
	13,
	14,
	15,
	14,
	10,
	4,
	8,
	9,
	15,
	13,
	6,
	1,
	12,
	0,
	2,
	11,
	7,
	5,
	3,
	11,
	8,
	12,
	0,
	5,
	2,
	15,
	13,
	10,
	14,
	3,
	6,
	7,
	1,
	9,
	4,
	7,
	9,
	3,
	1,
	13,
	12,
	11,
	14,
	2,
	6,
	5,
	10,
	4,
	0,
	15,
	8,
	9,
	0,
	5,
	7,
	2,
	4,
	10,
	15,
	14,
	1,
	11,
	12,
	6,
	8,
	3,
	13,
	2,
	12,
	6,
	10,
	0,
	11,
	8,
	3,
	4,
	13,
	7,
	5,
	15,
	14,
	1,
	9,
	12,
	5,
	1,
	15,
	14,
	13,
	4,
	10,
	0,
	7,
	6,
	3,
	9,
	2,
	8,
	11,
	13,
	11,
	7,
	14,
	12,
	1,
	3,
	9,
	5,
	0,
	15,
	4,
	8,
	6,
	2,
	10,
	6,
	15,
	14,
	9,
	11,
	3,
	0,
	8,
	12,
	2,
	13,
	7,
	1,
	4,
	10,
	5,
	10,
	2,
	8,
	4,
	7,
	6,
	1,
	5,
	15,
	11,
	9,
	14,
	3,
	12,
	13,
	0,
	0,
	1,
	2,
	3,
	4,
	5,
	6,
	7,
	8,
	9,
	10,
	11,
	12,
	13,
	14,
	15,
	14,
	10,
	4,
	8,
	9,
	15,
	13,
	6,
	1,
	12,
	0,
	2,
	11,
	7,
	5,
	3,
	11,
	8,
	12,
	0,
	5,
	2,
	15,
	13,
	10,
	14,
	3,
	6,
	7,
	1,
	9,
	4,
	7,
	9,
	3,
	1,
	13,
	12,
	11,
	14,
	2,
	6,
	5,
	10,
	4,
	0,
	15,
	8,
	9,
	0,
	5,
	7,
	2,
	4,
	10,
	15,
	14,
	1,
	11,
	12,
	6,
	8,
	3,
	13,
	2,
	12,
	6,
	10,
	0,
	11,
	8,
	3,
	4,
	13,
	7,
	5,
	15,
	14,
	1,
	9
]);

//#endregion
//#region node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/esm/_md.js
/**
* Internal Merkle-Damgard hash utils.
* @module
*/
/** Polyfill for Safari 14. https://caniuse.com/mdn-javascript_builtins_dataview_setbiguint64 */
function setBigUint64(view, byteOffset, value, isLE$1) {
	if (typeof view.setBigUint64 === "function") return view.setBigUint64(byteOffset, value, isLE$1);
	const _32n$1 = BigInt(32);
	const _u32_max = BigInt(4294967295);
	const wh = Number(value >> _32n$1 & _u32_max);
	const wl = Number(value & _u32_max);
	const h = isLE$1 ? 4 : 0;
	const l = isLE$1 ? 0 : 4;
	view.setUint32(byteOffset + h, wh, isLE$1);
	view.setUint32(byteOffset + l, wl, isLE$1);
}
/**
* Merkle-Damgard hash construction base class.
* Could be used to create MD5, RIPEMD, SHA1, SHA2.
*/
var HashMD = class extends Hash {
	constructor(blockLen, outputLen, padOffset, isLE$1) {
		super();
		this.finished = false;
		this.length = 0;
		this.pos = 0;
		this.destroyed = false;
		this.blockLen = blockLen;
		this.outputLen = outputLen;
		this.padOffset = padOffset;
		this.isLE = isLE$1;
		this.buffer = new Uint8Array(blockLen);
		this.view = createView(this.buffer);
	}
	update(data) {
		aexists(this);
		data = toBytes(data);
		abytes(data);
		const { view, buffer, blockLen } = this;
		const len = data.length;
		for (let pos = 0; pos < len;) {
			const take = Math.min(blockLen - this.pos, len - pos);
			if (take === blockLen) {
				const dataView = createView(data);
				for (; blockLen <= len - pos; pos += blockLen) this.process(dataView, pos);
				continue;
			}
			buffer.set(data.subarray(pos, pos + take), this.pos);
			this.pos += take;
			pos += take;
			if (this.pos === blockLen) {
				this.process(view, 0);
				this.pos = 0;
			}
		}
		this.length += data.length;
		this.roundClean();
		return this;
	}
	digestInto(out) {
		aexists(this);
		aoutput(out, this);
		this.finished = true;
		const { buffer, view, blockLen, isLE: isLE$1 } = this;
		let { pos } = this;
		buffer[pos++] = 128;
		clean(this.buffer.subarray(pos));
		if (this.padOffset > blockLen - pos) {
			this.process(view, 0);
			pos = 0;
		}
		for (let i = pos; i < blockLen; i++) buffer[i] = 0;
		setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE$1);
		this.process(view, 0);
		const oview = createView(out);
		const len = this.outputLen;
		if (len % 4) throw new Error("_sha2: outputLen should be aligned to 32bit");
		const outLen = len / 4;
		const state = this.get();
		if (outLen > state.length) throw new Error("_sha2: outputLen bigger than state");
		for (let i = 0; i < outLen; i++) oview.setUint32(4 * i, state[i], isLE$1);
	}
	digest() {
		const { buffer, outputLen } = this;
		this.digestInto(buffer);
		const res = buffer.slice(0, outputLen);
		this.destroy();
		return res;
	}
	_cloneInto(to) {
		to || (to = new this.constructor());
		to.set(...this.get());
		const { blockLen, buffer, length, finished, destroyed, pos } = this;
		to.destroyed = destroyed;
		to.finished = finished;
		to.length = length;
		to.pos = pos;
		if (length % blockLen) to.buffer.set(buffer);
		return to;
	}
	clone() {
		return this._cloneInto();
	}
};
/** Initial SHA512 state. Bits 0..64 of frac part of sqrt of primes 2..19 */
const SHA512_IV = /* @__PURE__ */ Uint32Array.from([
	1779033703,
	4089235720,
	3144134277,
	2227873595,
	1013904242,
	4271175723,
	2773480762,
	1595750129,
	1359893119,
	2917565137,
	2600822924,
	725511199,
	528734635,
	4215389547,
	1541459225,
	327033209
]);

//#endregion
//#region node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/esm/_u64.js
/**
* Internal helpers for u64. BigUint64Array is too slow as per 2025, so we implement it using Uint32Array.
* @todo re-check https://issues.chromium.org/issues/42212588
* @module
*/
var U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
var _32n = /* @__PURE__ */ BigInt(32);
function fromBig(n, le = false) {
	if (le) return {
		h: Number(n & U32_MASK64),
		l: Number(n >> _32n & U32_MASK64)
	};
	return {
		h: Number(n >> _32n & U32_MASK64) | 0,
		l: Number(n & U32_MASK64) | 0
	};
}
function split(lst, le = false) {
	const len = lst.length;
	let Ah = new Uint32Array(len);
	let Al = new Uint32Array(len);
	for (let i = 0; i < len; i++) {
		const { h, l } = fromBig(lst[i], le);
		[Ah[i], Al[i]] = [h, l];
	}
	return [Ah, Al];
}
var shrSH = (h, _l, s) => h >>> s;
var shrSL = (h, l, s) => h << 32 - s | l >>> s;
var rotrSH = (h, l, s) => h >>> s | l << 32 - s;
var rotrSL = (h, l, s) => h << 32 - s | l >>> s;
var rotrBH = (h, l, s) => h << 64 - s | l >>> s - 32;
var rotrBL = (h, l, s) => h >>> s - 32 | l << 64 - s;
var rotr32H = (_h, l) => l;
var rotr32L = (h, _l) => h;
function add(Ah, Al, Bh, Bl) {
	const l = (Al >>> 0) + (Bl >>> 0);
	return {
		h: Ah + Bh + (l / 2 ** 32 | 0) | 0,
		l: l | 0
	};
}
var add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
var add3H = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
var add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
var add4H = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
var add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
var add5H = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;

//#endregion
//#region node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/esm/blake2.js
/**
* blake2b (64-bit) & blake2s (8 to 32-bit) hash functions.
* b could have been faster, but there is no fast u64 in js, so s is 1.5x faster.
* @module
*/
var B2B_IV = /* @__PURE__ */ Uint32Array.from([
	4089235720,
	1779033703,
	2227873595,
	3144134277,
	4271175723,
	1013904242,
	1595750129,
	2773480762,
	2917565137,
	1359893119,
	725511199,
	2600822924,
	4215389547,
	528734635,
	327033209,
	1541459225
]);
var BBUF = /* @__PURE__ */ new Uint32Array(32);
function G1b(a, b, c, d, msg, x) {
	const Xl = msg[x], Xh = msg[x + 1];
	let Al = BBUF[2 * a], Ah = BBUF[2 * a + 1];
	let Bl = BBUF[2 * b], Bh = BBUF[2 * b + 1];
	let Cl = BBUF[2 * c], Ch = BBUF[2 * c + 1];
	let Dl = BBUF[2 * d], Dh = BBUF[2 * d + 1];
	let ll = add3L(Al, Bl, Xl);
	Ah = add3H(ll, Ah, Bh, Xh);
	Al = ll | 0;
	({Dh, Dl} = {
		Dh: Dh ^ Ah,
		Dl: Dl ^ Al
	});
	({Dh, Dl} = {
		Dh: rotr32H(Dh, Dl),
		Dl: rotr32L(Dh, Dl)
	});
	({h: Ch, l: Cl} = add(Ch, Cl, Dh, Dl));
	({Bh, Bl} = {
		Bh: Bh ^ Ch,
		Bl: Bl ^ Cl
	});
	({Bh, Bl} = {
		Bh: rotrSH(Bh, Bl, 24),
		Bl: rotrSL(Bh, Bl, 24)
	});
	BBUF[2 * a] = Al, BBUF[2 * a + 1] = Ah;
	BBUF[2 * b] = Bl, BBUF[2 * b + 1] = Bh;
	BBUF[2 * c] = Cl, BBUF[2 * c + 1] = Ch;
	BBUF[2 * d] = Dl, BBUF[2 * d + 1] = Dh;
}
function G2b(a, b, c, d, msg, x) {
	const Xl = msg[x], Xh = msg[x + 1];
	let Al = BBUF[2 * a], Ah = BBUF[2 * a + 1];
	let Bl = BBUF[2 * b], Bh = BBUF[2 * b + 1];
	let Cl = BBUF[2 * c], Ch = BBUF[2 * c + 1];
	let Dl = BBUF[2 * d], Dh = BBUF[2 * d + 1];
	let ll = add3L(Al, Bl, Xl);
	Ah = add3H(ll, Ah, Bh, Xh);
	Al = ll | 0;
	({Dh, Dl} = {
		Dh: Dh ^ Ah,
		Dl: Dl ^ Al
	});
	({Dh, Dl} = {
		Dh: rotrSH(Dh, Dl, 16),
		Dl: rotrSL(Dh, Dl, 16)
	});
	({h: Ch, l: Cl} = add(Ch, Cl, Dh, Dl));
	({Bh, Bl} = {
		Bh: Bh ^ Ch,
		Bl: Bl ^ Cl
	});
	({Bh, Bl} = {
		Bh: rotrBH(Bh, Bl, 63),
		Bl: rotrBL(Bh, Bl, 63)
	});
	BBUF[2 * a] = Al, BBUF[2 * a + 1] = Ah;
	BBUF[2 * b] = Bl, BBUF[2 * b + 1] = Bh;
	BBUF[2 * c] = Cl, BBUF[2 * c + 1] = Ch;
	BBUF[2 * d] = Dl, BBUF[2 * d + 1] = Dh;
}
function checkBlake2Opts(outputLen, opts = {}, keyLen, saltLen, persLen) {
	anumber(keyLen);
	if (outputLen < 0 || outputLen > keyLen) throw new Error("outputLen bigger than keyLen");
	const { key, salt, personalization } = opts;
	if (key !== void 0 && (key.length < 1 || key.length > keyLen)) throw new Error("key length must be undefined or 1.." + keyLen);
	if (salt !== void 0 && salt.length !== saltLen) throw new Error("salt must be undefined or " + saltLen);
	if (personalization !== void 0 && personalization.length !== persLen) throw new Error("personalization must be undefined or " + persLen);
}
/** Class, from which others are subclassed. */
var BLAKE2 = class extends Hash {
	constructor(blockLen, outputLen) {
		super();
		this.finished = false;
		this.destroyed = false;
		this.length = 0;
		this.pos = 0;
		anumber(blockLen);
		anumber(outputLen);
		this.blockLen = blockLen;
		this.outputLen = outputLen;
		this.buffer = new Uint8Array(blockLen);
		this.buffer32 = u32(this.buffer);
	}
	update(data) {
		aexists(this);
		data = toBytes(data);
		abytes(data);
		const { blockLen, buffer, buffer32 } = this;
		const len = data.length;
		const offset = data.byteOffset;
		const buf = data.buffer;
		for (let pos = 0; pos < len;) {
			if (this.pos === blockLen) {
				swap32IfBE(buffer32);
				this.compress(buffer32, 0, false);
				swap32IfBE(buffer32);
				this.pos = 0;
			}
			const take = Math.min(blockLen - this.pos, len - pos);
			const dataOffset = offset + pos;
			if (take === blockLen && !(dataOffset % 4) && pos + take < len) {
				const data32 = new Uint32Array(buf, dataOffset, Math.floor((len - pos) / 4));
				swap32IfBE(data32);
				for (let pos32 = 0; pos + blockLen < len; pos32 += buffer32.length, pos += blockLen) {
					this.length += blockLen;
					this.compress(data32, pos32, false);
				}
				swap32IfBE(data32);
				continue;
			}
			buffer.set(data.subarray(pos, pos + take), this.pos);
			this.pos += take;
			this.length += take;
			pos += take;
		}
		return this;
	}
	digestInto(out) {
		aexists(this);
		aoutput(out, this);
		const { pos, buffer32 } = this;
		this.finished = true;
		clean(this.buffer.subarray(pos));
		swap32IfBE(buffer32);
		this.compress(buffer32, 0, true);
		swap32IfBE(buffer32);
		const out32 = u32(out);
		this.get().forEach((v, i) => out32[i] = swap8IfBE(v));
	}
	digest() {
		const { buffer, outputLen } = this;
		this.digestInto(buffer);
		const res = buffer.slice(0, outputLen);
		this.destroy();
		return res;
	}
	_cloneInto(to) {
		const { buffer, length, finished, destroyed, outputLen, pos } = this;
		to || (to = new this.constructor({ dkLen: outputLen }));
		to.set(...this.get());
		to.buffer.set(buffer);
		to.destroyed = destroyed;
		to.finished = finished;
		to.length = length;
		to.pos = pos;
		to.outputLen = outputLen;
		return to;
	}
	clone() {
		return this._cloneInto();
	}
};
var BLAKE2b = class extends BLAKE2 {
	constructor(opts = {}) {
		const olen = opts.dkLen === void 0 ? 64 : opts.dkLen;
		super(128, olen);
		this.v0l = B2B_IV[0] | 0;
		this.v0h = B2B_IV[1] | 0;
		this.v1l = B2B_IV[2] | 0;
		this.v1h = B2B_IV[3] | 0;
		this.v2l = B2B_IV[4] | 0;
		this.v2h = B2B_IV[5] | 0;
		this.v3l = B2B_IV[6] | 0;
		this.v3h = B2B_IV[7] | 0;
		this.v4l = B2B_IV[8] | 0;
		this.v4h = B2B_IV[9] | 0;
		this.v5l = B2B_IV[10] | 0;
		this.v5h = B2B_IV[11] | 0;
		this.v6l = B2B_IV[12] | 0;
		this.v6h = B2B_IV[13] | 0;
		this.v7l = B2B_IV[14] | 0;
		this.v7h = B2B_IV[15] | 0;
		checkBlake2Opts(olen, opts, 64, 16, 16);
		let { key, personalization, salt } = opts;
		let keyLength = 0;
		if (key !== void 0) {
			key = toBytes(key);
			keyLength = key.length;
		}
		this.v0l ^= this.outputLen | keyLength << 8 | 16842752;
		if (salt !== void 0) {
			salt = toBytes(salt);
			const slt = u32(salt);
			this.v4l ^= swap8IfBE(slt[0]);
			this.v4h ^= swap8IfBE(slt[1]);
			this.v5l ^= swap8IfBE(slt[2]);
			this.v5h ^= swap8IfBE(slt[3]);
		}
		if (personalization !== void 0) {
			personalization = toBytes(personalization);
			const pers = u32(personalization);
			this.v6l ^= swap8IfBE(pers[0]);
			this.v6h ^= swap8IfBE(pers[1]);
			this.v7l ^= swap8IfBE(pers[2]);
			this.v7h ^= swap8IfBE(pers[3]);
		}
		if (key !== void 0) {
			const tmp = new Uint8Array(this.blockLen);
			tmp.set(key);
			this.update(tmp);
		}
	}
	get() {
		let { v0l, v0h, v1l, v1h, v2l, v2h, v3l, v3h, v4l, v4h, v5l, v5h, v6l, v6h, v7l, v7h } = this;
		return [
			v0l,
			v0h,
			v1l,
			v1h,
			v2l,
			v2h,
			v3l,
			v3h,
			v4l,
			v4h,
			v5l,
			v5h,
			v6l,
			v6h,
			v7l,
			v7h
		];
	}
	set(v0l, v0h, v1l, v1h, v2l, v2h, v3l, v3h, v4l, v4h, v5l, v5h, v6l, v6h, v7l, v7h) {
		this.v0l = v0l | 0;
		this.v0h = v0h | 0;
		this.v1l = v1l | 0;
		this.v1h = v1h | 0;
		this.v2l = v2l | 0;
		this.v2h = v2h | 0;
		this.v3l = v3l | 0;
		this.v3h = v3h | 0;
		this.v4l = v4l | 0;
		this.v4h = v4h | 0;
		this.v5l = v5l | 0;
		this.v5h = v5h | 0;
		this.v6l = v6l | 0;
		this.v6h = v6h | 0;
		this.v7l = v7l | 0;
		this.v7h = v7h | 0;
	}
	compress(msg, offset, isLast) {
		this.get().forEach((v, i) => BBUF[i] = v);
		BBUF.set(B2B_IV, 16);
		let { h, l } = fromBig(BigInt(this.length));
		BBUF[24] = B2B_IV[8] ^ l;
		BBUF[25] = B2B_IV[9] ^ h;
		if (isLast) {
			BBUF[28] = ~BBUF[28];
			BBUF[29] = ~BBUF[29];
		}
		let j = 0;
		const s = BSIGMA;
		for (let i = 0; i < 12; i++) {
			G1b(0, 4, 8, 12, msg, offset + 2 * s[j++]);
			G2b(0, 4, 8, 12, msg, offset + 2 * s[j++]);
			G1b(1, 5, 9, 13, msg, offset + 2 * s[j++]);
			G2b(1, 5, 9, 13, msg, offset + 2 * s[j++]);
			G1b(2, 6, 10, 14, msg, offset + 2 * s[j++]);
			G2b(2, 6, 10, 14, msg, offset + 2 * s[j++]);
			G1b(3, 7, 11, 15, msg, offset + 2 * s[j++]);
			G2b(3, 7, 11, 15, msg, offset + 2 * s[j++]);
			G1b(0, 5, 10, 15, msg, offset + 2 * s[j++]);
			G2b(0, 5, 10, 15, msg, offset + 2 * s[j++]);
			G1b(1, 6, 11, 12, msg, offset + 2 * s[j++]);
			G2b(1, 6, 11, 12, msg, offset + 2 * s[j++]);
			G1b(2, 7, 8, 13, msg, offset + 2 * s[j++]);
			G2b(2, 7, 8, 13, msg, offset + 2 * s[j++]);
			G1b(3, 4, 9, 14, msg, offset + 2 * s[j++]);
			G2b(3, 4, 9, 14, msg, offset + 2 * s[j++]);
		}
		this.v0l ^= BBUF[0] ^ BBUF[16];
		this.v0h ^= BBUF[1] ^ BBUF[17];
		this.v1l ^= BBUF[2] ^ BBUF[18];
		this.v1h ^= BBUF[3] ^ BBUF[19];
		this.v2l ^= BBUF[4] ^ BBUF[20];
		this.v2h ^= BBUF[5] ^ BBUF[21];
		this.v3l ^= BBUF[6] ^ BBUF[22];
		this.v3h ^= BBUF[7] ^ BBUF[23];
		this.v4l ^= BBUF[8] ^ BBUF[24];
		this.v4h ^= BBUF[9] ^ BBUF[25];
		this.v5l ^= BBUF[10] ^ BBUF[26];
		this.v5h ^= BBUF[11] ^ BBUF[27];
		this.v6l ^= BBUF[12] ^ BBUF[28];
		this.v6h ^= BBUF[13] ^ BBUF[29];
		this.v7l ^= BBUF[14] ^ BBUF[30];
		this.v7h ^= BBUF[15] ^ BBUF[31];
		clean(BBUF);
	}
	destroy() {
		this.destroyed = true;
		clean(this.buffer32);
		this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
	}
};
/**
* Blake2b hash function. 64-bit. 1.5x slower than blake2s in JS.
* @param msg - message that would be hashed
* @param opts - dkLen output length, key for MAC mode, salt, personalization
*/
const blake2b$1 = /* @__PURE__ */ createOptHasher((opts) => new BLAKE2b(opts));

//#endregion
//#region node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/esm/blake2b.js
/**
* Blake2b hash function. Focuses on 64-bit platforms, but in JS speed different from Blake2s is negligible.
* @module
* @deprecated
*/
/** @deprecated Use import from `noble/hashes/blake2` module */
const blake2b = blake2b$1;

//#endregion
//#region node_modules/.pnpm/@mysten+sui@1.45.2_typescript@5.9.3/node_modules/@mysten/sui/dist/esm/bcs/type-tag-serializer.js
var VECTOR_REGEX = /^vector<(.+)>$/;
var STRUCT_REGEX = /^([^:]+)::([^:]+)::([^<]+)(<(.+)>)?/;
var TypeTagSerializer = class TypeTagSerializer {
	static parseFromStr(str, normalizeAddress = false) {
		if (str === "address") return { address: null };
		else if (str === "bool") return { bool: null };
		else if (str === "u8") return { u8: null };
		else if (str === "u16") return { u16: null };
		else if (str === "u32") return { u32: null };
		else if (str === "u64") return { u64: null };
		else if (str === "u128") return { u128: null };
		else if (str === "u256") return { u256: null };
		else if (str === "signer") return { signer: null };
		const vectorMatch = str.match(VECTOR_REGEX);
		if (vectorMatch) return { vector: TypeTagSerializer.parseFromStr(vectorMatch[1], normalizeAddress) };
		const structMatch = str.match(STRUCT_REGEX);
		if (structMatch) return { struct: {
			address: normalizeAddress ? normalizeSuiAddress(structMatch[1]) : structMatch[1],
			module: structMatch[2],
			name: structMatch[3],
			typeParams: structMatch[5] === void 0 ? [] : TypeTagSerializer.parseStructTypeArgs(structMatch[5], normalizeAddress)
		} };
		throw new Error(`Encountered unexpected token when parsing type args for ${str}`);
	}
	static parseStructTypeArgs(str, normalizeAddress = false) {
		return splitGenericParameters(str).map((tok) => TypeTagSerializer.parseFromStr(tok, normalizeAddress));
	}
	static tagToString(tag) {
		if ("bool" in tag) return "bool";
		if ("u8" in tag) return "u8";
		if ("u16" in tag) return "u16";
		if ("u32" in tag) return "u32";
		if ("u64" in tag) return "u64";
		if ("u128" in tag) return "u128";
		if ("u256" in tag) return "u256";
		if ("address" in tag) return "address";
		if ("signer" in tag) return "signer";
		if ("vector" in tag) return `vector<${TypeTagSerializer.tagToString(tag.vector)}>`;
		if ("struct" in tag) {
			const struct = tag.struct;
			const typeParams = struct.typeParams.map(TypeTagSerializer.tagToString).join(", ");
			return `${struct.address}::${struct.module}::${struct.name}${typeParams ? `<${typeParams}>` : ""}`;
		}
		throw new Error("Invalid TypeTag");
	}
};

//#endregion
//#region node_modules/.pnpm/@mysten+sui@1.45.2_typescript@5.9.3/node_modules/@mysten/sui/dist/esm/bcs/bcs.js
function unsafe_u64(options) {
	return bcs.u64({
		name: "unsafe_u64",
		...options
	}).transform({
		input: (val) => val,
		output: (val) => Number(val)
	});
}
function optionEnum(type) {
	return bcs.enum("Option", {
		None: null,
		Some: type
	});
}
var Address = bcs.bytes(SUI_ADDRESS_LENGTH).transform({
	validate: (val) => {
		const address = typeof val === "string" ? val : toHex(val);
		if (!address || !isValidSuiAddress(normalizeSuiAddress(address))) throw new Error(`Invalid Sui address ${address}`);
	},
	input: (val) => typeof val === "string" ? fromHex(normalizeSuiAddress(val)) : val,
	output: (val) => normalizeSuiAddress(toHex(val))
});
var ObjectDigest = bcs.byteVector().transform({
	name: "ObjectDigest",
	input: (value) => fromBase58(value),
	output: (value) => toBase58(new Uint8Array(value)),
	validate: (value) => {
		if (fromBase58(value).length !== 32) throw new Error("ObjectDigest must be 32 bytes");
	}
});
var SuiObjectRef = bcs.struct("SuiObjectRef", {
	objectId: Address,
	version: bcs.u64(),
	digest: ObjectDigest
});
var SharedObjectRef = bcs.struct("SharedObjectRef", {
	objectId: Address,
	initialSharedVersion: bcs.u64(),
	mutable: bcs.bool()
});
var ObjectArg = bcs.enum("ObjectArg", {
	ImmOrOwnedObject: SuiObjectRef,
	SharedObject: SharedObjectRef,
	Receiving: SuiObjectRef
});
var Owner = bcs.enum("Owner", {
	AddressOwner: Address,
	ObjectOwner: Address,
	Shared: bcs.struct("Shared", { initialSharedVersion: bcs.u64() }),
	Immutable: null,
	ConsensusAddressOwner: bcs.struct("ConsensusAddressOwner", {
		owner: Address,
		startVersion: bcs.u64()
	})
});
var CallArg$1 = bcs.enum("CallArg", {
	Pure: bcs.struct("Pure", { bytes: bcs.byteVector().transform({
		input: (val) => typeof val === "string" ? fromBase64(val) : val,
		output: (val) => toBase64(new Uint8Array(val))
	}) }),
	Object: ObjectArg
});
var InnerTypeTag = bcs.enum("TypeTag", {
	bool: null,
	u8: null,
	u64: null,
	u128: null,
	address: null,
	signer: null,
	vector: bcs.lazy(() => InnerTypeTag),
	struct: bcs.lazy(() => StructTag$1),
	u16: null,
	u32: null,
	u256: null
});
var TypeTag$1 = InnerTypeTag.transform({
	input: (typeTag) => typeof typeTag === "string" ? TypeTagSerializer.parseFromStr(typeTag, true) : typeTag,
	output: (typeTag) => TypeTagSerializer.tagToString(typeTag)
});
var Argument$1 = bcs.enum("Argument", {
	GasCoin: null,
	Input: bcs.u16(),
	Result: bcs.u16(),
	NestedResult: bcs.tuple([bcs.u16(), bcs.u16()])
});
var ProgrammableMoveCall$1 = bcs.struct("ProgrammableMoveCall", {
	package: Address,
	module: bcs.string(),
	function: bcs.string(),
	typeArguments: bcs.vector(TypeTag$1),
	arguments: bcs.vector(Argument$1)
});
var Command$1 = bcs.enum("Command", {
	MoveCall: ProgrammableMoveCall$1,
	TransferObjects: bcs.struct("TransferObjects", {
		objects: bcs.vector(Argument$1),
		address: Argument$1
	}),
	SplitCoins: bcs.struct("SplitCoins", {
		coin: Argument$1,
		amounts: bcs.vector(Argument$1)
	}),
	MergeCoins: bcs.struct("MergeCoins", {
		destination: Argument$1,
		sources: bcs.vector(Argument$1)
	}),
	Publish: bcs.struct("Publish", {
		modules: bcs.vector(bcs.byteVector().transform({
			input: (val) => typeof val === "string" ? fromBase64(val) : val,
			output: (val) => toBase64(new Uint8Array(val))
		})),
		dependencies: bcs.vector(Address)
	}),
	MakeMoveVec: bcs.struct("MakeMoveVec", {
		type: optionEnum(TypeTag$1).transform({
			input: (val) => val === null ? { None: true } : { Some: val },
			output: (val) => val.Some ?? null
		}),
		elements: bcs.vector(Argument$1)
	}),
	Upgrade: bcs.struct("Upgrade", {
		modules: bcs.vector(bcs.byteVector().transform({
			input: (val) => typeof val === "string" ? fromBase64(val) : val,
			output: (val) => toBase64(new Uint8Array(val))
		})),
		dependencies: bcs.vector(Address),
		package: Address,
		ticket: Argument$1
	})
});
var ProgrammableTransaction = bcs.struct("ProgrammableTransaction", {
	inputs: bcs.vector(CallArg$1),
	commands: bcs.vector(Command$1)
});
var TransactionKind = bcs.enum("TransactionKind", {
	ProgrammableTransaction,
	ChangeEpoch: null,
	Genesis: null,
	ConsensusCommitPrologue: null
});
var TransactionExpiration$3 = bcs.enum("TransactionExpiration", {
	None: null,
	Epoch: unsafe_u64()
});
var StructTag$1 = bcs.struct("StructTag", {
	address: Address,
	module: bcs.string(),
	name: bcs.string(),
	typeParams: bcs.vector(InnerTypeTag)
});
var GasData$1 = bcs.struct("GasData", {
	payment: bcs.vector(SuiObjectRef),
	owner: Address,
	price: bcs.u64(),
	budget: bcs.u64()
});
var TransactionDataV1 = bcs.struct("TransactionDataV1", {
	kind: TransactionKind,
	sender: Address,
	gasData: GasData$1,
	expiration: TransactionExpiration$3
});
var TransactionData = bcs.enum("TransactionData", { V1: TransactionDataV1 });
var IntentScope = bcs.enum("IntentScope", {
	TransactionData: null,
	TransactionEffects: null,
	CheckpointSummary: null,
	PersonalMessage: null
});
var IntentVersion = bcs.enum("IntentVersion", { V0: null });
var AppId = bcs.enum("AppId", { Sui: null });
var Intent = bcs.struct("Intent", {
	scope: IntentScope,
	version: IntentVersion,
	appId: AppId
});
function IntentMessage(T) {
	return bcs.struct(`IntentMessage<${T.name}>`, {
		intent: Intent,
		value: T
	});
}
var CompressedSignature = bcs.enum("CompressedSignature", {
	ED25519: bcs.bytes(64),
	Secp256k1: bcs.bytes(64),
	Secp256r1: bcs.bytes(64),
	ZkLogin: bcs.byteVector(),
	Passkey: bcs.byteVector()
});
var PublicKey = bcs.enum("PublicKey", {
	ED25519: bcs.bytes(32),
	Secp256k1: bcs.bytes(33),
	Secp256r1: bcs.bytes(33),
	ZkLogin: bcs.byteVector(),
	Passkey: bcs.bytes(33)
});
var MultiSigPkMap = bcs.struct("MultiSigPkMap", {
	pubKey: PublicKey,
	weight: bcs.u8()
});
var MultiSigPublicKey = bcs.struct("MultiSigPublicKey", {
	pk_map: bcs.vector(MultiSigPkMap),
	threshold: bcs.u16()
});
var MultiSig = bcs.struct("MultiSig", {
	sigs: bcs.vector(CompressedSignature),
	bitmap: bcs.u16(),
	multisig_pk: MultiSigPublicKey
});
var base64String = bcs.byteVector().transform({
	input: (val) => typeof val === "string" ? fromBase64(val) : val,
	output: (val) => toBase64(new Uint8Array(val))
});
var SenderSignedTransaction = bcs.struct("SenderSignedTransaction", {
	intentMessage: IntentMessage(TransactionData),
	txSignatures: bcs.vector(base64String)
});
var SenderSignedData = bcs.vector(SenderSignedTransaction, { name: "SenderSignedData" });
var PasskeyAuthenticator = bcs.struct("PasskeyAuthenticator", {
	authenticatorData: bcs.byteVector(),
	clientDataJson: bcs.string(),
	userSignature: bcs.byteVector()
});

//#endregion
//#region node_modules/.pnpm/@mysten+sui@1.45.2_typescript@5.9.3/node_modules/@mysten/sui/dist/esm/bcs/effects.js
var PackageUpgradeError = bcs.enum("PackageUpgradeError", {
	UnableToFetchPackage: bcs.struct("UnableToFetchPackage", { packageId: Address }),
	NotAPackage: bcs.struct("NotAPackage", { objectId: Address }),
	IncompatibleUpgrade: null,
	DigestDoesNotMatch: bcs.struct("DigestDoesNotMatch", { digest: bcs.byteVector() }),
	UnknownUpgradePolicy: bcs.struct("UnknownUpgradePolicy", { policy: bcs.u8() }),
	PackageIDDoesNotMatch: bcs.struct("PackageIDDoesNotMatch", {
		packageId: Address,
		ticketId: Address
	})
});
var ModuleId = bcs.struct("ModuleId", {
	address: Address,
	name: bcs.string()
});
var MoveLocation = bcs.struct("MoveLocation", {
	module: ModuleId,
	function: bcs.u16(),
	instruction: bcs.u16(),
	functionName: bcs.option(bcs.string())
});
var CommandArgumentError = bcs.enum("CommandArgumentError", {
	TypeMismatch: null,
	InvalidBCSBytes: null,
	InvalidUsageOfPureArg: null,
	InvalidArgumentToPrivateEntryFunction: null,
	IndexOutOfBounds: bcs.struct("IndexOutOfBounds", { idx: bcs.u16() }),
	SecondaryIndexOutOfBounds: bcs.struct("SecondaryIndexOutOfBounds", {
		resultIdx: bcs.u16(),
		secondaryIdx: bcs.u16()
	}),
	InvalidResultArity: bcs.struct("InvalidResultArity", { resultIdx: bcs.u16() }),
	InvalidGasCoinUsage: null,
	InvalidValueUsage: null,
	InvalidObjectByValue: null,
	InvalidObjectByMutRef: null,
	SharedObjectOperationNotAllowed: null
});
var TypeArgumentError = bcs.enum("TypeArgumentError", {
	TypeNotFound: null,
	ConstraintNotSatisfied: null
});
var ExecutionFailureStatus = bcs.enum("ExecutionFailureStatus", {
	InsufficientGas: null,
	InvalidGasObject: null,
	InvariantViolation: null,
	FeatureNotYetSupported: null,
	MoveObjectTooBig: bcs.struct("MoveObjectTooBig", {
		objectSize: bcs.u64(),
		maxObjectSize: bcs.u64()
	}),
	MovePackageTooBig: bcs.struct("MovePackageTooBig", {
		objectSize: bcs.u64(),
		maxObjectSize: bcs.u64()
	}),
	CircularObjectOwnership: bcs.struct("CircularObjectOwnership", { object: Address }),
	InsufficientCoinBalance: null,
	CoinBalanceOverflow: null,
	PublishErrorNonZeroAddress: null,
	SuiMoveVerificationError: null,
	MovePrimitiveRuntimeError: bcs.option(MoveLocation),
	MoveAbort: bcs.tuple([MoveLocation, bcs.u64()]),
	VMVerificationOrDeserializationError: null,
	VMInvariantViolation: null,
	FunctionNotFound: null,
	ArityMismatch: null,
	TypeArityMismatch: null,
	NonEntryFunctionInvoked: null,
	CommandArgumentError: bcs.struct("CommandArgumentError", {
		argIdx: bcs.u16(),
		kind: CommandArgumentError
	}),
	TypeArgumentError: bcs.struct("TypeArgumentError", {
		argumentIdx: bcs.u16(),
		kind: TypeArgumentError
	}),
	UnusedValueWithoutDrop: bcs.struct("UnusedValueWithoutDrop", {
		resultIdx: bcs.u16(),
		secondaryIdx: bcs.u16()
	}),
	InvalidPublicFunctionReturnType: bcs.struct("InvalidPublicFunctionReturnType", { idx: bcs.u16() }),
	InvalidTransferObject: null,
	EffectsTooLarge: bcs.struct("EffectsTooLarge", {
		currentSize: bcs.u64(),
		maxSize: bcs.u64()
	}),
	PublishUpgradeMissingDependency: null,
	PublishUpgradeDependencyDowngrade: null,
	PackageUpgradeError: bcs.struct("PackageUpgradeError", { upgradeError: PackageUpgradeError }),
	WrittenObjectsTooLarge: bcs.struct("WrittenObjectsTooLarge", {
		currentSize: bcs.u64(),
		maxSize: bcs.u64()
	}),
	CertificateDenied: null,
	SuiMoveVerificationTimedout: null,
	SharedObjectOperationNotAllowed: null,
	InputObjectDeleted: null,
	ExecutionCancelledDueToSharedObjectCongestion: bcs.struct("ExecutionCancelledDueToSharedObjectCongestion", { congestedObjects: bcs.vector(Address) }),
	AddressDeniedForCoin: bcs.struct("AddressDeniedForCoin", {
		address: Address,
		coinType: bcs.string()
	}),
	CoinTypeGlobalPause: bcs.struct("CoinTypeGlobalPause", { coinType: bcs.string() }),
	ExecutionCancelledDueToRandomnessUnavailable: null
});
var ExecutionStatus = bcs.enum("ExecutionStatus", {
	Success: null,
	Failed: bcs.struct("ExecutionFailed", {
		error: ExecutionFailureStatus,
		command: bcs.option(bcs.u64())
	})
});
var GasCostSummary = bcs.struct("GasCostSummary", {
	computationCost: bcs.u64(),
	storageCost: bcs.u64(),
	storageRebate: bcs.u64(),
	nonRefundableStorageFee: bcs.u64()
});
var TransactionEffectsV1 = bcs.struct("TransactionEffectsV1", {
	status: ExecutionStatus,
	executedEpoch: bcs.u64(),
	gasUsed: GasCostSummary,
	modifiedAtVersions: bcs.vector(bcs.tuple([Address, bcs.u64()])),
	sharedObjects: bcs.vector(SuiObjectRef),
	transactionDigest: ObjectDigest,
	created: bcs.vector(bcs.tuple([SuiObjectRef, Owner])),
	mutated: bcs.vector(bcs.tuple([SuiObjectRef, Owner])),
	unwrapped: bcs.vector(bcs.tuple([SuiObjectRef, Owner])),
	deleted: bcs.vector(SuiObjectRef),
	unwrappedThenDeleted: bcs.vector(SuiObjectRef),
	wrapped: bcs.vector(SuiObjectRef),
	gasObject: bcs.tuple([SuiObjectRef, Owner]),
	eventsDigest: bcs.option(ObjectDigest),
	dependencies: bcs.vector(ObjectDigest)
});
var VersionDigest = bcs.tuple([bcs.u64(), ObjectDigest]);
var ObjectIn = bcs.enum("ObjectIn", {
	NotExist: null,
	Exist: bcs.tuple([VersionDigest, Owner])
});
var ObjectOut = bcs.enum("ObjectOut", {
	NotExist: null,
	ObjectWrite: bcs.tuple([ObjectDigest, Owner]),
	PackageWrite: VersionDigest
});
var IDOperation = bcs.enum("IDOperation", {
	None: null,
	Created: null,
	Deleted: null
});
var EffectsObjectChange = bcs.struct("EffectsObjectChange", {
	inputState: ObjectIn,
	outputState: ObjectOut,
	idOperation: IDOperation
});
var UnchangedSharedKind = bcs.enum("UnchangedSharedKind", {
	ReadOnlyRoot: VersionDigest,
	MutateDeleted: bcs.u64(),
	ReadDeleted: bcs.u64(),
	Cancelled: bcs.u64(),
	PerEpochConfig: null
});
var TransactionEffectsV2 = bcs.struct("TransactionEffectsV2", {
	status: ExecutionStatus,
	executedEpoch: bcs.u64(),
	gasUsed: GasCostSummary,
	transactionDigest: ObjectDigest,
	gasObjectIndex: bcs.option(bcs.u32()),
	eventsDigest: bcs.option(ObjectDigest),
	dependencies: bcs.vector(ObjectDigest),
	lamportVersion: bcs.u64(),
	changedObjects: bcs.vector(bcs.tuple([Address, EffectsObjectChange])),
	unchangedSharedObjects: bcs.vector(bcs.tuple([Address, UnchangedSharedKind])),
	auxDataDigest: bcs.option(ObjectDigest)
});
var TransactionEffects = bcs.enum("TransactionEffects", {
	V1: TransactionEffectsV1,
	V2: TransactionEffectsV2
});

//#endregion
//#region node_modules/.pnpm/@mysten+sui@1.45.2_typescript@5.9.3/node_modules/@mysten/sui/dist/esm/bcs/pure.js
function pureBcsSchemaFromTypeName(name) {
	switch (name) {
		case "u8": return bcs.u8();
		case "u16": return bcs.u16();
		case "u32": return bcs.u32();
		case "u64": return bcs.u64();
		case "u128": return bcs.u128();
		case "u256": return bcs.u256();
		case "bool": return bcs.bool();
		case "string": return bcs.string();
		case "id":
		case "address": return Address;
	}
	const generic = name.match(/^(vector|option)<(.+)>$/);
	if (generic) {
		const [kind, inner] = generic.slice(1);
		if (kind === "vector") return bcs.vector(pureBcsSchemaFromTypeName(inner));
		else return bcs.option(pureBcsSchemaFromTypeName(inner));
	}
	throw new Error(`Invalid Pure type name: ${name}`);
}

//#endregion
//#region node_modules/.pnpm/@mysten+sui@1.45.2_typescript@5.9.3/node_modules/@mysten/sui/dist/esm/bcs/index.js
var suiBcs = {
	...bcs,
	U8: bcs.u8(),
	U16: bcs.u16(),
	U32: bcs.u32(),
	U64: bcs.u64(),
	U128: bcs.u128(),
	U256: bcs.u256(),
	ULEB128: bcs.uleb128(),
	Bool: bcs.bool(),
	String: bcs.string(),
	Address,
	AppId,
	Argument: Argument$1,
	CallArg: CallArg$1,
	Command: Command$1,
	CompressedSignature,
	GasData: GasData$1,
	Intent,
	IntentMessage,
	IntentScope,
	IntentVersion,
	MultiSig,
	MultiSigPkMap,
	MultiSigPublicKey,
	ObjectArg,
	ObjectDigest,
	Owner,
	PasskeyAuthenticator,
	ProgrammableMoveCall: ProgrammableMoveCall$1,
	ProgrammableTransaction,
	PublicKey,
	SenderSignedData,
	SenderSignedTransaction,
	SharedObjectRef,
	StructTag: StructTag$1,
	SuiObjectRef,
	TransactionData,
	TransactionDataV1,
	TransactionEffects,
	TransactionExpiration: TransactionExpiration$3,
	TransactionKind,
	TypeTag: TypeTag$1
};

//#endregion
//#region node_modules/.pnpm/@mysten+sui@1.45.2_typescript@5.9.3/node_modules/@mysten/sui/dist/esm/transactions/serializer.js
var OBJECT_MODULE_NAME = "object";
var ID_STRUCT_NAME = "ID";
var STD_ASCII_MODULE_NAME = "ascii";
var STD_ASCII_STRUCT_NAME = "String";
var STD_UTF8_MODULE_NAME = "string";
var STD_UTF8_STRUCT_NAME = "String";
var STD_OPTION_MODULE_NAME = "option";
var STD_OPTION_STRUCT_NAME = "Option";
function isTxContext(param) {
	const struct = typeof param.body === "object" && "datatype" in param.body ? param.body.datatype : null;
	return !!struct && normalizeSuiAddress(struct.package) === normalizeSuiAddress("0x2") && struct.module === "tx_context" && struct.type === "TxContext";
}
function getPureBcsSchema(typeSignature) {
	if (typeof typeSignature === "string") switch (typeSignature) {
		case "address": return suiBcs.Address;
		case "bool": return suiBcs.Bool;
		case "u8": return suiBcs.U8;
		case "u16": return suiBcs.U16;
		case "u32": return suiBcs.U32;
		case "u64": return suiBcs.U64;
		case "u128": return suiBcs.U128;
		case "u256": return suiBcs.U256;
		default: throw new Error(`Unknown type signature ${typeSignature}`);
	}
	if ("vector" in typeSignature) {
		if (typeSignature.vector === "u8") return suiBcs.byteVector().transform({
			input: (val) => typeof val === "string" ? new TextEncoder().encode(val) : val,
			output: (val) => val
		});
		const type = getPureBcsSchema(typeSignature.vector);
		return type ? suiBcs.vector(type) : null;
	}
	if ("datatype" in typeSignature) {
		const pkg = normalizeSuiAddress(typeSignature.datatype.package);
		if (pkg === normalizeSuiAddress(MOVE_STDLIB_ADDRESS)) {
			if (typeSignature.datatype.module === STD_ASCII_MODULE_NAME && typeSignature.datatype.type === STD_ASCII_STRUCT_NAME) return suiBcs.String;
			if (typeSignature.datatype.module === STD_UTF8_MODULE_NAME && typeSignature.datatype.type === STD_UTF8_STRUCT_NAME) return suiBcs.String;
			if (typeSignature.datatype.module === STD_OPTION_MODULE_NAME && typeSignature.datatype.type === STD_OPTION_STRUCT_NAME) {
				const type = getPureBcsSchema(typeSignature.datatype.typeParameters[0]);
				return type ? suiBcs.vector(type) : null;
			}
		}
		if (pkg === normalizeSuiAddress(SUI_FRAMEWORK_ADDRESS) && typeSignature.datatype.module === OBJECT_MODULE_NAME && typeSignature.datatype.type === ID_STRUCT_NAME) return suiBcs.Address;
	}
	return null;
}
function normalizedTypeToMoveTypeSignature(type) {
	if (typeof type === "object" && "Reference" in type) return {
		ref: "&",
		body: normalizedTypeToMoveTypeSignatureBody(type.Reference)
	};
	if (typeof type === "object" && "MutableReference" in type) return {
		ref: "&mut",
		body: normalizedTypeToMoveTypeSignatureBody(type.MutableReference)
	};
	return {
		ref: null,
		body: normalizedTypeToMoveTypeSignatureBody(type)
	};
}
function normalizedTypeToMoveTypeSignatureBody(type) {
	if (typeof type === "string") switch (type) {
		case "Address": return "address";
		case "Bool": return "bool";
		case "U8": return "u8";
		case "U16": return "u16";
		case "U32": return "u32";
		case "U64": return "u64";
		case "U128": return "u128";
		case "U256": return "u256";
		default: throw new Error(`Unexpected type ${type}`);
	}
	if ("Vector" in type) return { vector: normalizedTypeToMoveTypeSignatureBody(type.Vector) };
	if ("Struct" in type) return { datatype: {
		package: type.Struct.address,
		module: type.Struct.module,
		type: type.Struct.name,
		typeParameters: type.Struct.typeArguments.map(normalizedTypeToMoveTypeSignatureBody)
	} };
	if ("TypeParameter" in type) return { typeParameter: type.TypeParameter };
	throw new Error(`Unexpected type ${JSON.stringify(type)}`);
}

//#endregion
//#region node_modules/.pnpm/@mysten+sui@1.45.2_typescript@5.9.3/node_modules/@mysten/sui/dist/esm/transactions/Inputs.js
function Pure(data) {
	return {
		$kind: "Pure",
		Pure: { bytes: data instanceof Uint8Array ? toBase64(data) : data.toBase64() }
	};
}
var Inputs = {
	Pure,
	ObjectRef({ objectId, digest, version }) {
		return {
			$kind: "Object",
			Object: {
				$kind: "ImmOrOwnedObject",
				ImmOrOwnedObject: {
					digest,
					version,
					objectId: normalizeSuiAddress(objectId)
				}
			}
		};
	},
	SharedObjectRef({ objectId, mutable, initialSharedVersion }) {
		return {
			$kind: "Object",
			Object: {
				$kind: "SharedObject",
				SharedObject: {
					mutable,
					initialSharedVersion,
					objectId: normalizeSuiAddress(objectId)
				}
			}
		};
	},
	ReceivingRef({ objectId, digest, version }) {
		return {
			$kind: "Object",
			Object: {
				$kind: "Receiving",
				Receiving: {
					digest,
					version,
					objectId: normalizeSuiAddress(objectId)
				}
			}
		};
	}
};

//#endregion
//#region node_modules/.pnpm/valibot@1.2.0_typescript@5.9.3/node_modules/valibot/dist/index.mjs
var store$4;
/**
* Returns the global configuration.
*
* @param config The config to merge.
*
* @returns The configuration.
*/
/* @__NO_SIDE_EFFECTS__ */
function getGlobalConfig(config$1) {
	return {
		lang: config$1?.lang ?? store$4?.lang,
		message: config$1?.message,
		abortEarly: config$1?.abortEarly ?? store$4?.abortEarly,
		abortPipeEarly: config$1?.abortPipeEarly ?? store$4?.abortPipeEarly
	};
}
var store$3;
/**
* Returns a global error message.
*
* @param lang The language of the message.
*
* @returns The error message.
*/
/* @__NO_SIDE_EFFECTS__ */
function getGlobalMessage(lang) {
	return store$3?.get(lang);
}
var store$2;
/**
* Returns a schema error message.
*
* @param lang The language of the message.
*
* @returns The error message.
*/
/* @__NO_SIDE_EFFECTS__ */
function getSchemaMessage(lang) {
	return store$2?.get(lang);
}
var store$1;
/**
* Returns a specific error message.
*
* @param reference The identifier reference.
* @param lang The language of the message.
*
* @returns The error message.
*/
/* @__NO_SIDE_EFFECTS__ */
function getSpecificMessage(reference, lang) {
	return store$1?.get(reference)?.get(lang);
}
/**
* Stringifies an unknown input to a literal or type string.
*
* @param input The unknown input.
*
* @returns A literal or type string.
*
* @internal
*/
/* @__NO_SIDE_EFFECTS__ */
function _stringify(input) {
	const type = typeof input;
	if (type === "string") return `"${input}"`;
	if (type === "number" || type === "bigint" || type === "boolean") return `${input}`;
	if (type === "object" || type === "function") return (input && Object.getPrototypeOf(input)?.constructor?.name) ?? "null";
	return type;
}
/**
* Adds an issue to the dataset.
*
* @param context The issue context.
* @param label The issue label.
* @param dataset The input dataset.
* @param config The configuration.
* @param other The optional props.
*
* @internal
*/
function _addIssue(context, label, dataset, config$1, other) {
	const input = other && "input" in other ? other.input : dataset.value;
	const expected = other?.expected ?? context.expects ?? null;
	const received = other?.received ?? /* @__PURE__ */ _stringify(input);
	const issue = {
		kind: context.kind,
		type: context.type,
		input,
		expected,
		received,
		message: `Invalid ${label}: ${expected ? `Expected ${expected} but r` : "R"}eceived ${received}`,
		requirement: context.requirement,
		path: other?.path,
		issues: other?.issues,
		lang: config$1.lang,
		abortEarly: config$1.abortEarly,
		abortPipeEarly: config$1.abortPipeEarly
	};
	const isSchema = context.kind === "schema";
	const message$1 = other?.message ?? context.message ?? /* @__PURE__ */ getSpecificMessage(context.reference, issue.lang) ?? (isSchema ? /* @__PURE__ */ getSchemaMessage(issue.lang) : null) ?? config$1.message ?? /* @__PURE__ */ getGlobalMessage(issue.lang);
	if (message$1 !== void 0) issue.message = typeof message$1 === "function" ? message$1(issue) : message$1;
	if (isSchema) dataset.typed = false;
	if (dataset.issues) dataset.issues.push(issue);
	else dataset.issues = [issue];
}
/**
* Returns the Standard Schema properties.
*
* @param context The schema context.
*
* @returns The Standard Schema properties.
*/
/* @__NO_SIDE_EFFECTS__ */
function _getStandardProps(context) {
	return {
		version: 1,
		vendor: "valibot",
		validate(value$1) {
			return context["~run"]({ value: value$1 }, /* @__PURE__ */ getGlobalConfig());
		}
	};
}
/**
* Disallows inherited object properties and prevents object prototype
* pollution by disallowing certain keys.
*
* @param object The object to check.
* @param key The key to check.
*
* @returns Whether the key is allowed.
*
* @internal
*/
/* @__NO_SIDE_EFFECTS__ */
function _isValidObjectKey(object$1, key) {
	return Object.hasOwn(object$1, key) && key !== "__proto__" && key !== "prototype" && key !== "constructor";
}
/**
* Joins multiple `expects` values with the given separator.
*
* @param values The `expects` values.
* @param separator The separator.
*
* @returns The joined `expects` property.
*
* @internal
*/
/* @__NO_SIDE_EFFECTS__ */
function _joinExpects(values$1, separator) {
	const list = [...new Set(values$1)];
	if (list.length > 1) return `(${list.join(` ${separator} `)})`;
	return list[0] ?? "never";
}
/**
* A Valibot error with useful information.
*/
var ValiError = class extends Error {
	/**
	* Creates a Valibot error with useful information.
	*
	* @param issues The error issues.
	*/
	constructor(issues) {
		super(issues[0].message);
		this.name = "ValiError";
		this.issues = issues;
	}
};
/**
* [UUID](https://en.wikipedia.org/wiki/Universally_unique_identifier) regex.
*/
var UUID_REGEX = /^[\da-f]{8}(?:-[\da-f]{4}){3}-[\da-f]{12}$/iu;
/* @__NO_SIDE_EFFECTS__ */
function check(requirement, message$1) {
	return {
		kind: "validation",
		type: "check",
		reference: check,
		async: false,
		expects: null,
		requirement,
		message: message$1,
		"~run"(dataset, config$1) {
			if (dataset.typed && !this.requirement(dataset.value)) _addIssue(this, "input", dataset, config$1);
			return dataset;
		}
	};
}
/* @__NO_SIDE_EFFECTS__ */
function integer(message$1) {
	return {
		kind: "validation",
		type: "integer",
		reference: integer,
		async: false,
		expects: null,
		requirement: Number.isInteger,
		message: message$1,
		"~run"(dataset, config$1) {
			if (dataset.typed && !this.requirement(dataset.value)) _addIssue(this, "integer", dataset, config$1);
			return dataset;
		}
	};
}
/**
* Creates a custom transformation action.
*
* @param operation The transformation operation.
*
* @returns A transform action.
*/
/* @__NO_SIDE_EFFECTS__ */
function transform(operation) {
	return {
		kind: "transformation",
		type: "transform",
		reference: transform,
		async: false,
		operation,
		"~run"(dataset) {
			dataset.value = this.operation(dataset.value);
			return dataset;
		}
	};
}
/* @__NO_SIDE_EFFECTS__ */
function uuid(message$1) {
	return {
		kind: "validation",
		type: "uuid",
		reference: uuid,
		async: false,
		expects: null,
		requirement: UUID_REGEX,
		message: message$1,
		"~run"(dataset, config$1) {
			if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, "UUID", dataset, config$1);
			return dataset;
		}
	};
}
/**
* Returns the fallback value of the schema.
*
* @param schema The schema to get it from.
* @param dataset The output dataset if available.
* @param config The config if available.
*
* @returns The fallback value.
*/
/* @__NO_SIDE_EFFECTS__ */
function getFallback(schema, dataset, config$1) {
	return typeof schema.fallback === "function" ? schema.fallback(dataset, config$1) : schema.fallback;
}
/**
* Returns the default value of the schema.
*
* @param schema The schema to get it from.
* @param dataset The input dataset if available.
* @param config The config if available.
*
* @returns The default value.
*/
/* @__NO_SIDE_EFFECTS__ */
function getDefault(schema, dataset, config$1) {
	return typeof schema.default === "function" ? schema.default(dataset, config$1) : schema.default;
}
/**
* Checks if the input matches the schema. By using a type predicate, this
* function can be used as a type guard.
*
* @param schema The schema to be used.
* @param input The input to be tested.
*
* @returns Whether the input matches the schema.
*/
/* @__NO_SIDE_EFFECTS__ */
function is(schema, input) {
	return !schema["~run"]({ value: input }, { abortEarly: true }).issues;
}
/* @__NO_SIDE_EFFECTS__ */
function array(item, message$1) {
	return {
		kind: "schema",
		type: "array",
		reference: array,
		expects: "Array",
		async: false,
		item,
		message: message$1,
		get "~standard"() {
			return /* @__PURE__ */ _getStandardProps(this);
		},
		"~run"(dataset, config$1) {
			const input = dataset.value;
			if (Array.isArray(input)) {
				dataset.typed = true;
				dataset.value = [];
				for (let key = 0; key < input.length; key++) {
					const value$1 = input[key];
					const itemDataset = this.item["~run"]({ value: value$1 }, config$1);
					if (itemDataset.issues) {
						const pathItem = {
							type: "array",
							origin: "value",
							input,
							key,
							value: value$1
						};
						for (const issue of itemDataset.issues) {
							if (issue.path) issue.path.unshift(pathItem);
							else issue.path = [pathItem];
							dataset.issues?.push(issue);
						}
						if (!dataset.issues) dataset.issues = itemDataset.issues;
						if (config$1.abortEarly) {
							dataset.typed = false;
							break;
						}
					}
					if (!itemDataset.typed) dataset.typed = false;
					dataset.value.push(itemDataset.value);
				}
			} else _addIssue(this, "type", dataset, config$1);
			return dataset;
		}
	};
}
/* @__NO_SIDE_EFFECTS__ */
function bigint(message$1) {
	return {
		kind: "schema",
		type: "bigint",
		reference: bigint,
		expects: "bigint",
		async: false,
		message: message$1,
		get "~standard"() {
			return /* @__PURE__ */ _getStandardProps(this);
		},
		"~run"(dataset, config$1) {
			if (typeof dataset.value === "bigint") dataset.typed = true;
			else _addIssue(this, "type", dataset, config$1);
			return dataset;
		}
	};
}
/* @__NO_SIDE_EFFECTS__ */
function boolean(message$1) {
	return {
		kind: "schema",
		type: "boolean",
		reference: boolean,
		expects: "boolean",
		async: false,
		message: message$1,
		get "~standard"() {
			return /* @__PURE__ */ _getStandardProps(this);
		},
		"~run"(dataset, config$1) {
			if (typeof dataset.value === "boolean") dataset.typed = true;
			else _addIssue(this, "type", dataset, config$1);
			return dataset;
		}
	};
}
/**
* Creates a lazy schema.
*
* @param getter The schema getter.
*
* @returns A lazy schema.
*/
/* @__NO_SIDE_EFFECTS__ */
function lazy(getter) {
	return {
		kind: "schema",
		type: "lazy",
		reference: lazy,
		expects: "unknown",
		async: false,
		getter,
		get "~standard"() {
			return /* @__PURE__ */ _getStandardProps(this);
		},
		"~run"(dataset, config$1) {
			return this.getter(dataset.value)["~run"](dataset, config$1);
		}
	};
}
/* @__NO_SIDE_EFFECTS__ */
function literal(literal_, message$1) {
	return {
		kind: "schema",
		type: "literal",
		reference: literal,
		expects: /* @__PURE__ */ _stringify(literal_),
		async: false,
		literal: literal_,
		message: message$1,
		get "~standard"() {
			return /* @__PURE__ */ _getStandardProps(this);
		},
		"~run"(dataset, config$1) {
			if (dataset.value === this.literal) dataset.typed = true;
			else _addIssue(this, "type", dataset, config$1);
			return dataset;
		}
	};
}
/* @__NO_SIDE_EFFECTS__ */
function nullable(wrapped, default_) {
	return {
		kind: "schema",
		type: "nullable",
		reference: nullable,
		expects: `(${wrapped.expects} | null)`,
		async: false,
		wrapped,
		default: default_,
		get "~standard"() {
			return /* @__PURE__ */ _getStandardProps(this);
		},
		"~run"(dataset, config$1) {
			if (dataset.value === null) {
				if (this.default !== void 0) dataset.value = /* @__PURE__ */ getDefault(this, dataset, config$1);
				if (dataset.value === null) {
					dataset.typed = true;
					return dataset;
				}
			}
			return this.wrapped["~run"](dataset, config$1);
		}
	};
}
/* @__NO_SIDE_EFFECTS__ */
function nullish(wrapped, default_) {
	return {
		kind: "schema",
		type: "nullish",
		reference: nullish,
		expects: `(${wrapped.expects} | null | undefined)`,
		async: false,
		wrapped,
		default: default_,
		get "~standard"() {
			return /* @__PURE__ */ _getStandardProps(this);
		},
		"~run"(dataset, config$1) {
			if (dataset.value === null || dataset.value === void 0) {
				if (this.default !== void 0) dataset.value = /* @__PURE__ */ getDefault(this, dataset, config$1);
				if (dataset.value === null || dataset.value === void 0) {
					dataset.typed = true;
					return dataset;
				}
			}
			return this.wrapped["~run"](dataset, config$1);
		}
	};
}
/* @__NO_SIDE_EFFECTS__ */
function number(message$1) {
	return {
		kind: "schema",
		type: "number",
		reference: number,
		expects: "number",
		async: false,
		message: message$1,
		get "~standard"() {
			return /* @__PURE__ */ _getStandardProps(this);
		},
		"~run"(dataset, config$1) {
			if (typeof dataset.value === "number" && !isNaN(dataset.value)) dataset.typed = true;
			else _addIssue(this, "type", dataset, config$1);
			return dataset;
		}
	};
}
/* @__NO_SIDE_EFFECTS__ */
function object(entries$1, message$1) {
	return {
		kind: "schema",
		type: "object",
		reference: object,
		expects: "Object",
		async: false,
		entries: entries$1,
		message: message$1,
		get "~standard"() {
			return /* @__PURE__ */ _getStandardProps(this);
		},
		"~run"(dataset, config$1) {
			const input = dataset.value;
			if (input && typeof input === "object") {
				dataset.typed = true;
				dataset.value = {};
				for (const key in this.entries) {
					const valueSchema = this.entries[key];
					if (key in input || (valueSchema.type === "exact_optional" || valueSchema.type === "optional" || valueSchema.type === "nullish") && valueSchema.default !== void 0) {
						const value$1 = key in input ? input[key] : /* @__PURE__ */ getDefault(valueSchema);
						const valueDataset = valueSchema["~run"]({ value: value$1 }, config$1);
						if (valueDataset.issues) {
							const pathItem = {
								type: "object",
								origin: "value",
								input,
								key,
								value: value$1
							};
							for (const issue of valueDataset.issues) {
								if (issue.path) issue.path.unshift(pathItem);
								else issue.path = [pathItem];
								dataset.issues?.push(issue);
							}
							if (!dataset.issues) dataset.issues = valueDataset.issues;
							if (config$1.abortEarly) {
								dataset.typed = false;
								break;
							}
						}
						if (!valueDataset.typed) dataset.typed = false;
						dataset.value[key] = valueDataset.value;
					} else if (valueSchema.fallback !== void 0) dataset.value[key] = /* @__PURE__ */ getFallback(valueSchema);
					else if (valueSchema.type !== "exact_optional" && valueSchema.type !== "optional" && valueSchema.type !== "nullish") {
						_addIssue(this, "key", dataset, config$1, {
							input: void 0,
							expected: `"${key}"`,
							path: [{
								type: "object",
								origin: "key",
								input,
								key,
								value: input[key]
							}]
						});
						if (config$1.abortEarly) break;
					}
				}
			} else _addIssue(this, "type", dataset, config$1);
			return dataset;
		}
	};
}
/* @__NO_SIDE_EFFECTS__ */
function optional(wrapped, default_) {
	return {
		kind: "schema",
		type: "optional",
		reference: optional,
		expects: `(${wrapped.expects} | undefined)`,
		async: false,
		wrapped,
		default: default_,
		get "~standard"() {
			return /* @__PURE__ */ _getStandardProps(this);
		},
		"~run"(dataset, config$1) {
			if (dataset.value === void 0) {
				if (this.default !== void 0) dataset.value = /* @__PURE__ */ getDefault(this, dataset, config$1);
				if (dataset.value === void 0) {
					dataset.typed = true;
					return dataset;
				}
			}
			return this.wrapped["~run"](dataset, config$1);
		}
	};
}
/* @__NO_SIDE_EFFECTS__ */
function record(key, value$1, message$1) {
	return {
		kind: "schema",
		type: "record",
		reference: record,
		expects: "Object",
		async: false,
		key,
		value: value$1,
		message: message$1,
		get "~standard"() {
			return /* @__PURE__ */ _getStandardProps(this);
		},
		"~run"(dataset, config$1) {
			const input = dataset.value;
			if (input && typeof input === "object") {
				dataset.typed = true;
				dataset.value = {};
				for (const entryKey in input) if (/* @__PURE__ */ _isValidObjectKey(input, entryKey)) {
					const entryValue = input[entryKey];
					const keyDataset = this.key["~run"]({ value: entryKey }, config$1);
					if (keyDataset.issues) {
						const pathItem = {
							type: "object",
							origin: "key",
							input,
							key: entryKey,
							value: entryValue
						};
						for (const issue of keyDataset.issues) {
							issue.path = [pathItem];
							dataset.issues?.push(issue);
						}
						if (!dataset.issues) dataset.issues = keyDataset.issues;
						if (config$1.abortEarly) {
							dataset.typed = false;
							break;
						}
					}
					const valueDataset = this.value["~run"]({ value: entryValue }, config$1);
					if (valueDataset.issues) {
						const pathItem = {
							type: "object",
							origin: "value",
							input,
							key: entryKey,
							value: entryValue
						};
						for (const issue of valueDataset.issues) {
							if (issue.path) issue.path.unshift(pathItem);
							else issue.path = [pathItem];
							dataset.issues?.push(issue);
						}
						if (!dataset.issues) dataset.issues = valueDataset.issues;
						if (config$1.abortEarly) {
							dataset.typed = false;
							break;
						}
					}
					if (!keyDataset.typed || !valueDataset.typed) dataset.typed = false;
					if (keyDataset.typed) dataset.value[keyDataset.value] = valueDataset.value;
				}
			} else _addIssue(this, "type", dataset, config$1);
			return dataset;
		}
	};
}
/* @__NO_SIDE_EFFECTS__ */
function string(message$1) {
	return {
		kind: "schema",
		type: "string",
		reference: string,
		expects: "string",
		async: false,
		message: message$1,
		get "~standard"() {
			return /* @__PURE__ */ _getStandardProps(this);
		},
		"~run"(dataset, config$1) {
			if (typeof dataset.value === "string") dataset.typed = true;
			else _addIssue(this, "type", dataset, config$1);
			return dataset;
		}
	};
}
/* @__NO_SIDE_EFFECTS__ */
function tuple(items, message$1) {
	return {
		kind: "schema",
		type: "tuple",
		reference: tuple,
		expects: "Array",
		async: false,
		items,
		message: message$1,
		get "~standard"() {
			return /* @__PURE__ */ _getStandardProps(this);
		},
		"~run"(dataset, config$1) {
			const input = dataset.value;
			if (Array.isArray(input)) {
				dataset.typed = true;
				dataset.value = [];
				for (let key = 0; key < this.items.length; key++) {
					const value$1 = input[key];
					const itemDataset = this.items[key]["~run"]({ value: value$1 }, config$1);
					if (itemDataset.issues) {
						const pathItem = {
							type: "array",
							origin: "value",
							input,
							key,
							value: value$1
						};
						for (const issue of itemDataset.issues) {
							if (issue.path) issue.path.unshift(pathItem);
							else issue.path = [pathItem];
							dataset.issues?.push(issue);
						}
						if (!dataset.issues) dataset.issues = itemDataset.issues;
						if (config$1.abortEarly) {
							dataset.typed = false;
							break;
						}
					}
					if (!itemDataset.typed) dataset.typed = false;
					dataset.value.push(itemDataset.value);
				}
			} else _addIssue(this, "type", dataset, config$1);
			return dataset;
		}
	};
}
/**
* Returns the sub issues of the provided datasets for the union issue.
*
* @param datasets The datasets.
*
* @returns The sub issues.
*
* @internal
*/
/* @__NO_SIDE_EFFECTS__ */
function _subIssues(datasets) {
	let issues;
	if (datasets) for (const dataset of datasets) if (issues) issues.push(...dataset.issues);
	else issues = dataset.issues;
	return issues;
}
/* @__NO_SIDE_EFFECTS__ */
function union(options, message$1) {
	return {
		kind: "schema",
		type: "union",
		reference: union,
		expects: /* @__PURE__ */ _joinExpects(options.map((option$1) => option$1.expects), "|"),
		async: false,
		options,
		message: message$1,
		get "~standard"() {
			return /* @__PURE__ */ _getStandardProps(this);
		},
		"~run"(dataset, config$1) {
			let validDataset;
			let typedDatasets;
			let untypedDatasets;
			for (const schema of this.options) {
				const optionDataset = schema["~run"]({ value: dataset.value }, config$1);
				if (optionDataset.typed) if (optionDataset.issues) if (typedDatasets) typedDatasets.push(optionDataset);
				else typedDatasets = [optionDataset];
				else {
					validDataset = optionDataset;
					break;
				}
				else if (untypedDatasets) untypedDatasets.push(optionDataset);
				else untypedDatasets = [optionDataset];
			}
			if (validDataset) return validDataset;
			if (typedDatasets) {
				if (typedDatasets.length === 1) return typedDatasets[0];
				_addIssue(this, "type", dataset, config$1, { issues: /* @__PURE__ */ _subIssues(typedDatasets) });
				dataset.typed = true;
			} else if (untypedDatasets?.length === 1) return untypedDatasets[0];
			else _addIssue(this, "type", dataset, config$1, { issues: /* @__PURE__ */ _subIssues(untypedDatasets) });
			return dataset;
		}
	};
}
/**
* Creates a unknown schema.
*
* @returns A unknown schema.
*/
/* @__NO_SIDE_EFFECTS__ */
function unknown() {
	return {
		kind: "schema",
		type: "unknown",
		reference: unknown,
		expects: "unknown",
		async: false,
		get "~standard"() {
			return /* @__PURE__ */ _getStandardProps(this);
		},
		"~run"(dataset) {
			dataset.typed = true;
			return dataset;
		}
	};
}
/* @__NO_SIDE_EFFECTS__ */
function variant(key, options, message$1) {
	return {
		kind: "schema",
		type: "variant",
		reference: variant,
		expects: "Object",
		async: false,
		key,
		options,
		message: message$1,
		get "~standard"() {
			return /* @__PURE__ */ _getStandardProps(this);
		},
		"~run"(dataset, config$1) {
			const input = dataset.value;
			if (input && typeof input === "object") {
				let outputDataset;
				let maxDiscriminatorPriority = 0;
				let invalidDiscriminatorKey = this.key;
				let expectedDiscriminators = [];
				const parseOptions = (variant$1, allKeys) => {
					for (const schema of variant$1.options) {
						if (schema.type === "variant") parseOptions(schema, new Set(allKeys).add(schema.key));
						else {
							let keysAreValid = true;
							let currentPriority = 0;
							for (const currentKey of allKeys) {
								const discriminatorSchema = schema.entries[currentKey];
								if (currentKey in input ? discriminatorSchema["~run"]({
									typed: false,
									value: input[currentKey]
								}, { abortEarly: true }).issues : discriminatorSchema.type !== "exact_optional" && discriminatorSchema.type !== "optional" && discriminatorSchema.type !== "nullish") {
									keysAreValid = false;
									if (invalidDiscriminatorKey !== currentKey && (maxDiscriminatorPriority < currentPriority || maxDiscriminatorPriority === currentPriority && currentKey in input && !(invalidDiscriminatorKey in input))) {
										maxDiscriminatorPriority = currentPriority;
										invalidDiscriminatorKey = currentKey;
										expectedDiscriminators = [];
									}
									if (invalidDiscriminatorKey === currentKey) expectedDiscriminators.push(schema.entries[currentKey].expects);
									break;
								}
								currentPriority++;
							}
							if (keysAreValid) {
								const optionDataset = schema["~run"]({ value: input }, config$1);
								if (!outputDataset || !outputDataset.typed && optionDataset.typed) outputDataset = optionDataset;
							}
						}
						if (outputDataset && !outputDataset.issues) break;
					}
				};
				parseOptions(this, new Set([this.key]));
				if (outputDataset) return outputDataset;
				_addIssue(this, "type", dataset, config$1, {
					input: input[invalidDiscriminatorKey],
					expected: /* @__PURE__ */ _joinExpects(expectedDiscriminators, "|"),
					path: [{
						type: "object",
						origin: "value",
						input,
						key: invalidDiscriminatorKey,
						value: input[invalidDiscriminatorKey]
					}]
				});
			} else _addIssue(this, "type", dataset, config$1);
			return dataset;
		}
	};
}
/**
* Parses an unknown input based on a schema.
*
* @param schema The schema to be used.
* @param input The input to be parsed.
* @param config The parse configuration.
*
* @returns The parsed input.
*/
function parse(schema, input, config$1) {
	const dataset = schema["~run"]({ value: input }, /* @__PURE__ */ getGlobalConfig(config$1));
	if (dataset.issues) throw new ValiError(dataset.issues);
	return dataset.value;
}
/* @__NO_SIDE_EFFECTS__ */
function pipe(...pipe$1) {
	return {
		...pipe$1[0],
		pipe: pipe$1,
		get "~standard"() {
			return /* @__PURE__ */ _getStandardProps(this);
		},
		"~run"(dataset, config$1) {
			for (const item of pipe$1) if (item.kind !== "metadata") {
				if (dataset.issues && (item.kind === "schema" || item.kind === "transformation")) {
					dataset.typed = false;
					break;
				}
				if (!dataset.issues || !config$1.abortEarly && !config$1.abortPipeEarly) dataset = item["~run"](dataset, config$1);
			}
			return dataset;
		}
	};
}
/**
* Parses an unknown input based on a schema.
*
* @param schema The schema to be used.
* @param input The input to be parsed.
* @param config The parse configuration.
*
* @returns The parse result.
*/
/* @__NO_SIDE_EFFECTS__ */
function safeParse(schema, input, config$1) {
	const dataset = schema["~run"]({ value: input }, /* @__PURE__ */ getGlobalConfig(config$1));
	return {
		typed: dataset.typed,
		success: !dataset.issues,
		output: dataset.value,
		issues: dataset.issues
	};
}

//#endregion
//#region node_modules/.pnpm/@mysten+sui@1.45.2_typescript@5.9.3/node_modules/@mysten/sui/dist/esm/transactions/data/internal.js
function safeEnum(options) {
	return pipe(union(Object.entries(options).map(([key, value]) => object({ [key]: value }))), transform((value) => ({
		...value,
		$kind: Object.keys(value)[0]
	})));
}
var SuiAddress = pipe(string(), transform((value) => normalizeSuiAddress(value)), check(isValidSuiAddress));
var ObjectID = SuiAddress;
var BCSBytes = string();
var JsonU64 = pipe(union([string(), pipe(number(), integer())]), check((val) => {
	try {
		BigInt(val);
		return BigInt(val) >= 0 && BigInt(val) <= 18446744073709551615n;
	} catch {
		return false;
	}
}, "Invalid u64"));
var ObjectRefSchema = object({
	objectId: SuiAddress,
	version: JsonU64,
	digest: string()
});
var ArgumentSchema = pipe(union([
	object({ GasCoin: literal(true) }),
	object({
		Input: pipe(number(), integer()),
		type: optional(literal("pure"))
	}),
	object({
		Input: pipe(number(), integer()),
		type: optional(literal("object"))
	}),
	object({ Result: pipe(number(), integer()) }),
	object({ NestedResult: tuple([pipe(number(), integer()), pipe(number(), integer())]) })
]), transform((value) => ({
	...value,
	$kind: Object.keys(value)[0]
})));
var GasDataSchema = object({
	budget: nullable(JsonU64),
	price: nullable(JsonU64),
	owner: nullable(SuiAddress),
	payment: nullable(array(ObjectRefSchema))
});
var StructTagSchema = object({
	address: string(),
	module: string(),
	name: string(),
	typeParams: array(string())
});
var OpenMoveTypeSignatureBodySchema = union([
	literal("address"),
	literal("bool"),
	literal("u8"),
	literal("u16"),
	literal("u32"),
	literal("u64"),
	literal("u128"),
	literal("u256"),
	object({ vector: lazy(() => OpenMoveTypeSignatureBodySchema) }),
	object({ datatype: object({
		package: string(),
		module: string(),
		type: string(),
		typeParameters: array(lazy(() => OpenMoveTypeSignatureBodySchema))
	}) }),
	object({ typeParameter: pipe(number(), integer()) })
]);
var OpenMoveTypeSignatureSchema = object({
	ref: nullable(union([literal("&"), literal("&mut")])),
	body: OpenMoveTypeSignatureBodySchema
});
var ProgrammableMoveCallSchema = object({
	package: ObjectID,
	module: string(),
	function: string(),
	typeArguments: array(string()),
	arguments: array(ArgumentSchema),
	_argumentTypes: optional(nullable(array(OpenMoveTypeSignatureSchema)))
});
var $Intent$1 = object({
	name: string(),
	inputs: record(string(), union([ArgumentSchema, array(ArgumentSchema)])),
	data: record(string(), unknown())
});
var CommandSchema = safeEnum({
	MoveCall: ProgrammableMoveCallSchema,
	TransferObjects: object({
		objects: array(ArgumentSchema),
		address: ArgumentSchema
	}),
	SplitCoins: object({
		coin: ArgumentSchema,
		amounts: array(ArgumentSchema)
	}),
	MergeCoins: object({
		destination: ArgumentSchema,
		sources: array(ArgumentSchema)
	}),
	Publish: object({
		modules: array(BCSBytes),
		dependencies: array(ObjectID)
	}),
	MakeMoveVec: object({
		type: nullable(string()),
		elements: array(ArgumentSchema)
	}),
	Upgrade: object({
		modules: array(BCSBytes),
		dependencies: array(ObjectID),
		package: ObjectID,
		ticket: ArgumentSchema
	}),
	$Intent: $Intent$1
});
var ObjectArgSchema = safeEnum({
	ImmOrOwnedObject: ObjectRefSchema,
	SharedObject: object({
		objectId: ObjectID,
		initialSharedVersion: JsonU64,
		mutable: boolean()
	}),
	Receiving: ObjectRefSchema
});
var CallArgSchema = safeEnum({
	Object: ObjectArgSchema,
	Pure: object({ bytes: BCSBytes }),
	UnresolvedPure: object({ value: unknown() }),
	UnresolvedObject: object({
		objectId: ObjectID,
		version: optional(nullable(JsonU64)),
		digest: optional(nullable(string())),
		initialSharedVersion: optional(nullable(JsonU64)),
		mutable: optional(nullable(boolean()))
	})
});
var NormalizedCallArg = safeEnum({
	Object: ObjectArgSchema,
	Pure: object({ bytes: BCSBytes })
});
var TransactionExpiration = safeEnum({
	None: literal(true),
	Epoch: JsonU64
});
var TransactionDataSchema = object({
	version: literal(2),
	sender: nullish(SuiAddress),
	expiration: nullish(TransactionExpiration),
	gasData: GasDataSchema,
	inputs: array(CallArgSchema),
	commands: array(CommandSchema)
});

//#endregion
//#region node_modules/.pnpm/@mysten+sui@1.45.2_typescript@5.9.3/node_modules/@mysten/sui/dist/esm/transactions/Commands.js
var UpgradePolicy = /* @__PURE__ */ ((UpgradePolicy2) => {
	UpgradePolicy2[UpgradePolicy2["COMPATIBLE"] = 0] = "COMPATIBLE";
	UpgradePolicy2[UpgradePolicy2["ADDITIVE"] = 128] = "ADDITIVE";
	UpgradePolicy2[UpgradePolicy2["DEP_ONLY"] = 192] = "DEP_ONLY";
	return UpgradePolicy2;
})(UpgradePolicy || {});
var Commands = {
	MoveCall(input) {
		const [pkg, mod = "", fn = ""] = "target" in input ? input.target.split("::") : [
			input.package,
			input.module,
			input.function
		];
		return {
			$kind: "MoveCall",
			MoveCall: {
				package: pkg,
				module: mod,
				function: fn,
				typeArguments: input.typeArguments ?? [],
				arguments: input.arguments ?? []
			}
		};
	},
	TransferObjects(objects, address) {
		return {
			$kind: "TransferObjects",
			TransferObjects: {
				objects: objects.map((o) => parse(ArgumentSchema, o)),
				address: parse(ArgumentSchema, address)
			}
		};
	},
	SplitCoins(coin, amounts) {
		return {
			$kind: "SplitCoins",
			SplitCoins: {
				coin: parse(ArgumentSchema, coin),
				amounts: amounts.map((o) => parse(ArgumentSchema, o))
			}
		};
	},
	MergeCoins(destination, sources) {
		return {
			$kind: "MergeCoins",
			MergeCoins: {
				destination: parse(ArgumentSchema, destination),
				sources: sources.map((o) => parse(ArgumentSchema, o))
			}
		};
	},
	Publish({ modules, dependencies }) {
		return {
			$kind: "Publish",
			Publish: {
				modules: modules.map((module) => typeof module === "string" ? module : toBase64(new Uint8Array(module))),
				dependencies: dependencies.map((dep) => normalizeSuiObjectId(dep))
			}
		};
	},
	Upgrade({ modules, dependencies, package: packageId, ticket }) {
		return {
			$kind: "Upgrade",
			Upgrade: {
				modules: modules.map((module) => typeof module === "string" ? module : toBase64(new Uint8Array(module))),
				dependencies: dependencies.map((dep) => normalizeSuiObjectId(dep)),
				package: packageId,
				ticket: parse(ArgumentSchema, ticket)
			}
		};
	},
	MakeMoveVec({ type, elements }) {
		return {
			$kind: "MakeMoveVec",
			MakeMoveVec: {
				type: type ?? null,
				elements: elements.map((o) => parse(ArgumentSchema, o))
			}
		};
	},
	Intent({ name, inputs = {}, data = {} }) {
		return {
			$kind: "$Intent",
			$Intent: {
				name,
				inputs: Object.fromEntries(Object.entries(inputs).map(([key, value]) => [key, Array.isArray(value) ? value.map((o) => parse(ArgumentSchema, o)) : parse(ArgumentSchema, value)])),
				data
			}
		};
	}
};

//#endregion
//#region node_modules/.pnpm/@mysten+sui@1.45.2_typescript@5.9.3/node_modules/@mysten/sui/dist/esm/transactions/data/v1.js
var ObjectRef = object({
	digest: string(),
	objectId: string(),
	version: union([
		pipe(number(), integer()),
		string(),
		bigint()
	])
});
var NormalizedCallArg$1 = safeEnum({
	Object: safeEnum({
		ImmOrOwned: ObjectRef,
		Shared: object({
			objectId: ObjectID,
			initialSharedVersion: JsonU64,
			mutable: boolean()
		}),
		Receiving: ObjectRef
	}),
	Pure: array(pipe(number(), integer()))
});
var TransactionInput = union([object({
	kind: literal("Input"),
	index: pipe(number(), integer()),
	value: unknown(),
	type: optional(literal("object"))
}), object({
	kind: literal("Input"),
	index: pipe(number(), integer()),
	value: unknown(),
	type: literal("pure")
})]);
var TransactionExpiration$2 = union([object({ Epoch: pipe(number(), integer()) }), object({ None: nullable(literal(true)) })]);
var StringEncodedBigint = pipe(union([
	number(),
	string(),
	bigint()
]), check((val) => {
	if (![
		"string",
		"number",
		"bigint"
	].includes(typeof val)) return false;
	try {
		BigInt(val);
		return true;
	} catch {
		return false;
	}
}));
var TypeTag = union([
	object({ bool: nullable(literal(true)) }),
	object({ u8: nullable(literal(true)) }),
	object({ u64: nullable(literal(true)) }),
	object({ u128: nullable(literal(true)) }),
	object({ address: nullable(literal(true)) }),
	object({ signer: nullable(literal(true)) }),
	object({ vector: lazy(() => TypeTag) }),
	object({ struct: lazy(() => StructTag) }),
	object({ u16: nullable(literal(true)) }),
	object({ u32: nullable(literal(true)) }),
	object({ u256: nullable(literal(true)) })
]);
var StructTag = object({
	address: string(),
	module: string(),
	name: string(),
	typeParams: array(TypeTag)
});
var GasConfig = object({
	budget: optional(StringEncodedBigint),
	price: optional(StringEncodedBigint),
	payment: optional(array(ObjectRef)),
	owner: optional(string())
});
var TransactionArgument = union([...[
	TransactionInput,
	object({ kind: literal("GasCoin") }),
	object({
		kind: literal("Result"),
		index: pipe(number(), integer())
	}),
	object({
		kind: literal("NestedResult"),
		index: pipe(number(), integer()),
		resultIndex: pipe(number(), integer())
	})
]]);
var MoveCallTransaction = object({
	kind: literal("MoveCall"),
	target: pipe(string(), check((target) => target.split("::").length === 3)),
	typeArguments: array(string()),
	arguments: array(TransactionArgument)
});
var TransferObjectsTransaction = object({
	kind: literal("TransferObjects"),
	objects: array(TransactionArgument),
	address: TransactionArgument
});
var SplitCoinsTransaction = object({
	kind: literal("SplitCoins"),
	coin: TransactionArgument,
	amounts: array(TransactionArgument)
});
var MergeCoinsTransaction = object({
	kind: literal("MergeCoins"),
	destination: TransactionArgument,
	sources: array(TransactionArgument)
});
var MakeMoveVecTransaction = object({
	kind: literal("MakeMoveVec"),
	type: union([object({ Some: TypeTag }), object({ None: nullable(literal(true)) })]),
	objects: array(TransactionArgument)
});
var TransactionType = union([...[
	MoveCallTransaction,
	TransferObjectsTransaction,
	SplitCoinsTransaction,
	MergeCoinsTransaction,
	object({
		kind: literal("Publish"),
		modules: array(array(pipe(number(), integer()))),
		dependencies: array(string())
	}),
	object({
		kind: literal("Upgrade"),
		modules: array(array(pipe(number(), integer()))),
		dependencies: array(string()),
		packageId: string(),
		ticket: TransactionArgument
	}),
	MakeMoveVecTransaction
]]);
var SerializedTransactionDataV1 = object({
	version: literal(1),
	sender: optional(string()),
	expiration: nullish(TransactionExpiration$2),
	gasConfig: GasConfig,
	inputs: array(TransactionInput),
	transactions: array(TransactionType)
});
function serializeV1TransactionData(transactionData) {
	const inputs = transactionData.inputs.map((input, index) => {
		if (input.Object) return {
			kind: "Input",
			index,
			value: { Object: input.Object.ImmOrOwnedObject ? { ImmOrOwned: input.Object.ImmOrOwnedObject } : input.Object.Receiving ? { Receiving: {
				digest: input.Object.Receiving.digest,
				version: input.Object.Receiving.version,
				objectId: input.Object.Receiving.objectId
			} } : { Shared: {
				mutable: input.Object.SharedObject.mutable,
				initialSharedVersion: input.Object.SharedObject.initialSharedVersion,
				objectId: input.Object.SharedObject.objectId
			} } },
			type: "object"
		};
		if (input.Pure) return {
			kind: "Input",
			index,
			value: { Pure: Array.from(fromBase64(input.Pure.bytes)) },
			type: "pure"
		};
		if (input.UnresolvedPure) return {
			kind: "Input",
			type: "pure",
			index,
			value: input.UnresolvedPure.value
		};
		if (input.UnresolvedObject) return {
			kind: "Input",
			type: "object",
			index,
			value: input.UnresolvedObject.objectId
		};
		throw new Error("Invalid input");
	});
	return {
		version: 1,
		sender: transactionData.sender ?? void 0,
		expiration: transactionData.expiration?.$kind === "Epoch" ? { Epoch: Number(transactionData.expiration.Epoch) } : transactionData.expiration ? { None: true } : null,
		gasConfig: {
			owner: transactionData.gasData.owner ?? void 0,
			budget: transactionData.gasData.budget ?? void 0,
			price: transactionData.gasData.price ?? void 0,
			payment: transactionData.gasData.payment ?? void 0
		},
		inputs,
		transactions: transactionData.commands.map((command) => {
			if (command.MakeMoveVec) return {
				kind: "MakeMoveVec",
				type: command.MakeMoveVec.type === null ? { None: true } : { Some: TypeTagSerializer.parseFromStr(command.MakeMoveVec.type) },
				objects: command.MakeMoveVec.elements.map((arg) => convertTransactionArgument(arg, inputs))
			};
			if (command.MergeCoins) return {
				kind: "MergeCoins",
				destination: convertTransactionArgument(command.MergeCoins.destination, inputs),
				sources: command.MergeCoins.sources.map((arg) => convertTransactionArgument(arg, inputs))
			};
			if (command.MoveCall) return {
				kind: "MoveCall",
				target: `${command.MoveCall.package}::${command.MoveCall.module}::${command.MoveCall.function}`,
				typeArguments: command.MoveCall.typeArguments,
				arguments: command.MoveCall.arguments.map((arg) => convertTransactionArgument(arg, inputs))
			};
			if (command.Publish) return {
				kind: "Publish",
				modules: command.Publish.modules.map((mod) => Array.from(fromBase64(mod))),
				dependencies: command.Publish.dependencies
			};
			if (command.SplitCoins) return {
				kind: "SplitCoins",
				coin: convertTransactionArgument(command.SplitCoins.coin, inputs),
				amounts: command.SplitCoins.amounts.map((arg) => convertTransactionArgument(arg, inputs))
			};
			if (command.TransferObjects) return {
				kind: "TransferObjects",
				objects: command.TransferObjects.objects.map((arg) => convertTransactionArgument(arg, inputs)),
				address: convertTransactionArgument(command.TransferObjects.address, inputs)
			};
			if (command.Upgrade) return {
				kind: "Upgrade",
				modules: command.Upgrade.modules.map((mod) => Array.from(fromBase64(mod))),
				dependencies: command.Upgrade.dependencies,
				packageId: command.Upgrade.package,
				ticket: convertTransactionArgument(command.Upgrade.ticket, inputs)
			};
			throw new Error(`Unknown transaction ${Object.keys(command)}`);
		})
	};
}
function convertTransactionArgument(arg, inputs) {
	if (arg.$kind === "GasCoin") return { kind: "GasCoin" };
	if (arg.$kind === "Result") return {
		kind: "Result",
		index: arg.Result
	};
	if (arg.$kind === "NestedResult") return {
		kind: "NestedResult",
		index: arg.NestedResult[0],
		resultIndex: arg.NestedResult[1]
	};
	if (arg.$kind === "Input") return inputs[arg.Input];
	throw new Error(`Invalid argument ${Object.keys(arg)}`);
}
function transactionDataFromV1(data) {
	return parse(TransactionDataSchema, {
		version: 2,
		sender: data.sender ?? null,
		expiration: data.expiration ? "Epoch" in data.expiration ? { Epoch: data.expiration.Epoch } : { None: true } : null,
		gasData: {
			owner: data.gasConfig.owner ?? null,
			budget: data.gasConfig.budget?.toString() ?? null,
			price: data.gasConfig.price?.toString() ?? null,
			payment: data.gasConfig.payment?.map((ref) => ({
				digest: ref.digest,
				objectId: ref.objectId,
				version: ref.version.toString()
			})) ?? null
		},
		inputs: data.inputs.map((input) => {
			if (input.kind === "Input") {
				if (is(NormalizedCallArg$1, input.value)) {
					const value = parse(NormalizedCallArg$1, input.value);
					if (value.Object) {
						if (value.Object.ImmOrOwned) return { Object: { ImmOrOwnedObject: {
							objectId: value.Object.ImmOrOwned.objectId,
							version: String(value.Object.ImmOrOwned.version),
							digest: value.Object.ImmOrOwned.digest
						} } };
						if (value.Object.Shared) return { Object: { SharedObject: {
							mutable: value.Object.Shared.mutable ?? null,
							initialSharedVersion: value.Object.Shared.initialSharedVersion,
							objectId: value.Object.Shared.objectId
						} } };
						if (value.Object.Receiving) return { Object: { Receiving: {
							digest: value.Object.Receiving.digest,
							version: String(value.Object.Receiving.version),
							objectId: value.Object.Receiving.objectId
						} } };
						throw new Error("Invalid object input");
					}
					return { Pure: { bytes: toBase64(new Uint8Array(value.Pure)) } };
				}
				if (input.type === "object") return { UnresolvedObject: { objectId: input.value } };
				return { UnresolvedPure: { value: input.value } };
			}
			throw new Error("Invalid input");
		}),
		commands: data.transactions.map((transaction) => {
			switch (transaction.kind) {
				case "MakeMoveVec": return { MakeMoveVec: {
					type: "Some" in transaction.type ? TypeTagSerializer.tagToString(transaction.type.Some) : null,
					elements: transaction.objects.map((arg) => parseV1TransactionArgument(arg))
				} };
				case "MergeCoins": return { MergeCoins: {
					destination: parseV1TransactionArgument(transaction.destination),
					sources: transaction.sources.map((arg) => parseV1TransactionArgument(arg))
				} };
				case "MoveCall": {
					const [pkg, mod, fn] = transaction.target.split("::");
					return { MoveCall: {
						package: pkg,
						module: mod,
						function: fn,
						typeArguments: transaction.typeArguments,
						arguments: transaction.arguments.map((arg) => parseV1TransactionArgument(arg))
					} };
				}
				case "Publish": return { Publish: {
					modules: transaction.modules.map((mod) => toBase64(Uint8Array.from(mod))),
					dependencies: transaction.dependencies
				} };
				case "SplitCoins": return { SplitCoins: {
					coin: parseV1TransactionArgument(transaction.coin),
					amounts: transaction.amounts.map((arg) => parseV1TransactionArgument(arg))
				} };
				case "TransferObjects": return { TransferObjects: {
					objects: transaction.objects.map((arg) => parseV1TransactionArgument(arg)),
					address: parseV1TransactionArgument(transaction.address)
				} };
				case "Upgrade": return { Upgrade: {
					modules: transaction.modules.map((mod) => toBase64(Uint8Array.from(mod))),
					dependencies: transaction.dependencies,
					package: transaction.packageId,
					ticket: parseV1TransactionArgument(transaction.ticket)
				} };
			}
			throw new Error(`Unknown transaction ${Object.keys(transaction)}`);
		})
	});
}
function parseV1TransactionArgument(arg) {
	switch (arg.kind) {
		case "GasCoin": return { GasCoin: true };
		case "Result": return { Result: arg.index };
		case "NestedResult": return { NestedResult: [arg.index, arg.resultIndex] };
		case "Input": return { Input: arg.index };
	}
}

//#endregion
//#region node_modules/.pnpm/@mysten+sui@1.45.2_typescript@5.9.3/node_modules/@mysten/sui/dist/esm/transactions/data/v2.js
function enumUnion(options) {
	return union(Object.entries(options).map(([key, value]) => object({ [key]: value })));
}
var Argument = enumUnion({
	GasCoin: literal(true),
	Input: pipe(number(), integer()),
	Result: pipe(number(), integer()),
	NestedResult: tuple([pipe(number(), integer()), pipe(number(), integer())])
});
var GasData = object({
	budget: nullable(JsonU64),
	price: nullable(JsonU64),
	owner: nullable(SuiAddress),
	payment: nullable(array(ObjectRefSchema))
});
var ProgrammableMoveCall = object({
	package: ObjectID,
	module: string(),
	function: string(),
	typeArguments: array(string()),
	arguments: array(Argument)
});
var $Intent = object({
	name: string(),
	inputs: record(string(), union([Argument, array(Argument)])),
	data: record(string(), unknown())
});
var Command = enumUnion({
	MoveCall: ProgrammableMoveCall,
	TransferObjects: object({
		objects: array(Argument),
		address: Argument
	}),
	SplitCoins: object({
		coin: Argument,
		amounts: array(Argument)
	}),
	MergeCoins: object({
		destination: Argument,
		sources: array(Argument)
	}),
	Publish: object({
		modules: array(BCSBytes),
		dependencies: array(ObjectID)
	}),
	MakeMoveVec: object({
		type: nullable(string()),
		elements: array(Argument)
	}),
	Upgrade: object({
		modules: array(BCSBytes),
		dependencies: array(ObjectID),
		package: ObjectID,
		ticket: Argument
	}),
	$Intent
});
var CallArg = enumUnion({
	Object: enumUnion({
		ImmOrOwnedObject: ObjectRefSchema,
		SharedObject: object({
			objectId: ObjectID,
			initialSharedVersion: JsonU64,
			mutable: boolean()
		}),
		Receiving: ObjectRefSchema
	}),
	Pure: object({ bytes: BCSBytes }),
	UnresolvedPure: object({ value: unknown() }),
	UnresolvedObject: object({
		objectId: ObjectID,
		version: optional(nullable(JsonU64)),
		digest: optional(nullable(string())),
		initialSharedVersion: optional(nullable(JsonU64)),
		mutable: optional(nullable(boolean()))
	})
});
var TransactionExpiration$1 = enumUnion({
	None: literal(true),
	Epoch: JsonU64
});
var SerializedTransactionDataV2Schema = object({
	version: literal(2),
	sender: nullish(SuiAddress),
	expiration: nullish(TransactionExpiration$1),
	gasData: GasData,
	inputs: array(CallArg),
	commands: array(Command),
	digest: optional(nullable(string()))
});

//#endregion
//#region node_modules/.pnpm/@mysten+sui@1.45.2_typescript@5.9.3/node_modules/@mysten/sui/dist/esm/jsonRpc/json-rpc-resolver.js
var MAX_OBJECTS_PER_FETCH = 50;
var GAS_SAFE_OVERHEAD = 1000n;
var MAX_GAS = 5e10;
function jsonRpcClientResolveTransactionPlugin(client) {
	return async function resolveTransactionData(transactionData, options, next) {
		await normalizeInputs(transactionData, client);
		await resolveObjectReferences(transactionData, client);
		if (!options.onlyTransactionKind) {
			await setGasPrice(transactionData, client);
			await setGasBudget(transactionData, client);
			await setGasPayment(transactionData, client);
		}
		return await next();
	};
}
async function setGasPrice(transactionData, client) {
	if (!transactionData.gasConfig.price) transactionData.gasConfig.price = String(await client.getReferenceGasPrice());
}
async function setGasBudget(transactionData, client) {
	if (transactionData.gasConfig.budget) return;
	const dryRunResult = await client.dryRunTransactionBlock({ transactionBlock: transactionData.build({ overrides: { gasData: {
		budget: String(MAX_GAS),
		payment: []
	} } }) });
	if (dryRunResult.effects.status.status !== "success") throw new Error(`Dry run failed, could not automatically determine a budget: ${dryRunResult.effects.status.error}`, { cause: dryRunResult });
	const safeOverhead = GAS_SAFE_OVERHEAD * BigInt(transactionData.gasConfig.price || 1n);
	const baseComputationCostWithOverhead = BigInt(dryRunResult.effects.gasUsed.computationCost) + safeOverhead;
	const gasBudget = baseComputationCostWithOverhead + BigInt(dryRunResult.effects.gasUsed.storageCost) - BigInt(dryRunResult.effects.gasUsed.storageRebate);
	transactionData.gasConfig.budget = String(gasBudget > baseComputationCostWithOverhead ? gasBudget : baseComputationCostWithOverhead);
}
async function setGasPayment(transactionData, client) {
	if (!transactionData.gasConfig.payment) {
		const paymentCoins = (await client.getCoins({
			owner: transactionData.gasConfig.owner || transactionData.sender,
			coinType: SUI_TYPE_ARG
		})).data.filter((coin) => {
			return !transactionData.inputs.find((input) => {
				if (input.Object?.ImmOrOwnedObject) return coin.coinObjectId === input.Object.ImmOrOwnedObject.objectId;
				return false;
			});
		}).map((coin) => ({
			objectId: coin.coinObjectId,
			digest: coin.digest,
			version: coin.version
		}));
		if (!paymentCoins.length) throw new Error("No valid gas coins found for the transaction.");
		transactionData.gasConfig.payment = paymentCoins.map((payment) => parse(ObjectRefSchema, payment));
	}
}
async function resolveObjectReferences(transactionData, client) {
	const objectsToResolve = transactionData.inputs.filter((input) => {
		return input.UnresolvedObject && !(input.UnresolvedObject.version || input.UnresolvedObject?.initialSharedVersion);
	});
	const dedupedIds = [...new Set(objectsToResolve.map((input) => normalizeSuiObjectId(input.UnresolvedObject.objectId)))];
	const objectChunks = dedupedIds.length ? chunk(dedupedIds, MAX_OBJECTS_PER_FETCH) : [];
	const resolved = (await Promise.all(objectChunks.map((chunk2) => client.multiGetObjects({
		ids: chunk2,
		options: { showOwner: true }
	})))).flat();
	const responsesById = new Map(dedupedIds.map((id, index) => {
		return [id, resolved[index]];
	}));
	const invalidObjects = Array.from(responsesById).filter(([_, obj]) => obj.error).map(([_, obj]) => JSON.stringify(obj.error));
	if (invalidObjects.length) throw new Error(`The following input objects are invalid: ${invalidObjects.join(", ")}`);
	const objects = resolved.map((object$1) => {
		if (object$1.error || !object$1.data) throw new Error(`Failed to fetch object: ${object$1.error}`);
		const owner = object$1.data.owner;
		const initialSharedVersion = owner && typeof owner === "object" ? "Shared" in owner ? owner.Shared.initial_shared_version : "ConsensusAddressOwner" in owner ? owner.ConsensusAddressOwner.start_version : null : null;
		return {
			objectId: object$1.data.objectId,
			digest: object$1.data.digest,
			version: object$1.data.version,
			initialSharedVersion
		};
	});
	const objectsById = new Map(dedupedIds.map((id, index) => {
		return [id, objects[index]];
	}));
	for (const [index, input] of transactionData.inputs.entries()) {
		if (!input.UnresolvedObject) continue;
		let updated;
		const id = normalizeSuiAddress(input.UnresolvedObject.objectId);
		const object$1 = objectsById.get(id);
		if (input.UnresolvedObject.initialSharedVersion ?? object$1?.initialSharedVersion) updated = Inputs.SharedObjectRef({
			objectId: id,
			initialSharedVersion: input.UnresolvedObject.initialSharedVersion || object$1?.initialSharedVersion,
			mutable: input.UnresolvedObject.mutable || isUsedAsMutable(transactionData, index)
		});
		else if (isUsedAsReceiving(transactionData, index)) updated = Inputs.ReceivingRef({
			objectId: id,
			digest: input.UnresolvedObject.digest ?? object$1?.digest,
			version: input.UnresolvedObject.version ?? object$1?.version
		});
		transactionData.inputs[transactionData.inputs.indexOf(input)] = updated ?? Inputs.ObjectRef({
			objectId: id,
			digest: input.UnresolvedObject.digest ?? object$1?.digest,
			version: input.UnresolvedObject.version ?? object$1?.version
		});
	}
}
async function normalizeInputs(transactionData, client) {
	const { inputs, commands } = transactionData;
	const moveCallsToResolve = [];
	const moveFunctionsToResolve = /* @__PURE__ */ new Set();
	commands.forEach((command) => {
		if (command.MoveCall) {
			if (command.MoveCall._argumentTypes) return;
			if (command.MoveCall.arguments.map((arg) => {
				if (arg.$kind === "Input") return transactionData.inputs[arg.Input];
				return null;
			}).some((input) => input?.UnresolvedPure || input?.UnresolvedObject && typeof input?.UnresolvedObject.mutable !== "boolean")) {
				const functionName = `${command.MoveCall.package}::${command.MoveCall.module}::${command.MoveCall.function}`;
				moveFunctionsToResolve.add(functionName);
				moveCallsToResolve.push(command.MoveCall);
			}
		}
	});
	const moveFunctionParameters = /* @__PURE__ */ new Map();
	if (moveFunctionsToResolve.size > 0) await Promise.all([...moveFunctionsToResolve].map(async (functionName) => {
		const [packageId, moduleId, functionId] = functionName.split("::");
		const def = await client.getNormalizedMoveFunction({
			package: packageId,
			module: moduleId,
			function: functionId
		});
		moveFunctionParameters.set(functionName, def.parameters.map((param) => normalizedTypeToMoveTypeSignature(param)));
	}));
	if (moveCallsToResolve.length) await Promise.all(moveCallsToResolve.map(async (moveCall) => {
		const parameters = moveFunctionParameters.get(`${moveCall.package}::${moveCall.module}::${moveCall.function}`);
		if (!parameters) return;
		moveCall._argumentTypes = parameters.length > 0 && isTxContext(parameters.at(-1)) ? parameters.slice(0, parameters.length - 1) : parameters;
	}));
	commands.forEach((command) => {
		if (!command.MoveCall) return;
		const moveCall = command.MoveCall;
		const fnName = `${moveCall.package}::${moveCall.module}::${moveCall.function}`;
		const params = moveCall._argumentTypes;
		if (!params) return;
		if (params.length !== command.MoveCall.arguments.length) throw new Error(`Incorrect number of arguments for ${fnName}`);
		params.forEach((param, i) => {
			const arg = moveCall.arguments[i];
			if (arg.$kind !== "Input") return;
			const input = inputs[arg.Input];
			if (!input.UnresolvedPure && !input.UnresolvedObject) return;
			const inputValue = input.UnresolvedPure?.value ?? input.UnresolvedObject?.objectId;
			const schema = getPureBcsSchema(param.body);
			if (schema) {
				arg.type = "pure";
				inputs[inputs.indexOf(input)] = Inputs.Pure(schema.serialize(inputValue));
				return;
			}
			if (typeof inputValue !== "string") throw new Error(`Expect the argument to be an object id string, got ${JSON.stringify(inputValue, null, 2)}`);
			arg.type = "object";
			const unresolvedObject = input.UnresolvedPure ? {
				$kind: "UnresolvedObject",
				UnresolvedObject: { objectId: inputValue }
			} : input;
			inputs[arg.Input] = unresolvedObject;
		});
	});
}
function isUsedAsMutable(transactionData, index) {
	let usedAsMutable = false;
	transactionData.getInputUses(index, (arg, tx) => {
		if (tx.MoveCall && tx.MoveCall._argumentTypes) {
			const argIndex = tx.MoveCall.arguments.indexOf(arg);
			usedAsMutable = tx.MoveCall._argumentTypes[argIndex].ref !== "&" || usedAsMutable;
		}
		if (tx.$kind === "MakeMoveVec" || tx.$kind === "MergeCoins" || tx.$kind === "SplitCoins" || tx.$kind === "TransferObjects") usedAsMutable = true;
	});
	return usedAsMutable;
}
function isUsedAsReceiving(transactionData, index) {
	let usedAsReceiving = false;
	transactionData.getInputUses(index, (arg, tx) => {
		if (tx.MoveCall && tx.MoveCall._argumentTypes) {
			const argIndex = tx.MoveCall.arguments.indexOf(arg);
			usedAsReceiving = isReceivingType(tx.MoveCall._argumentTypes[argIndex]) || usedAsReceiving;
		}
	});
	return usedAsReceiving;
}
function isReceivingType(type) {
	if (typeof type.body !== "object" || !("datatype" in type.body)) return false;
	return type.body.datatype.package === "0x2" && type.body.datatype.module === "transfer" && type.body.datatype.type === "Receiving";
}

//#endregion
//#region node_modules/.pnpm/@mysten+sui@1.45.2_typescript@5.9.3/node_modules/@mysten/sui/dist/esm/transactions/resolve.js
function needsTransactionResolution(data, options) {
	if (data.inputs.some((input) => {
		return input.UnresolvedObject || input.UnresolvedPure;
	})) return true;
	if (!options.onlyTransactionKind) {
		if (!data.gasConfig.price || !data.gasConfig.budget || !data.gasConfig.payment) return true;
	}
	return false;
}
async function resolveTransactionPlugin(transactionData, options, next) {
	normalizeRawArguments(transactionData);
	if (!needsTransactionResolution(transactionData, options)) {
		await validate(transactionData);
		return next();
	}
	const client = getClient$1(options);
	return (client.core?.resolveTransactionPlugin() ?? jsonRpcClientResolveTransactionPlugin(client))(transactionData, options, async () => {
		await validate(transactionData);
		await next();
	});
}
function validate(transactionData) {
	transactionData.inputs.forEach((input, index) => {
		if (input.$kind !== "Object" && input.$kind !== "Pure") throw new Error(`Input at index ${index} has not been resolved.  Expected a Pure or Object input, but found ${JSON.stringify(input)}`);
	});
}
function getClient$1(options) {
	if (!options.client) throw new Error(`No sui client passed to Transaction#build, but transaction data was not sufficient to build offline.`);
	return options.client;
}
function normalizeRawArguments(transactionData) {
	for (const command of transactionData.commands) switch (command.$kind) {
		case "SplitCoins":
			command.SplitCoins.amounts.forEach((amount) => {
				normalizeRawArgument(amount, suiBcs.U64, transactionData);
			});
			break;
		case "TransferObjects":
			normalizeRawArgument(command.TransferObjects.address, suiBcs.Address, transactionData);
			break;
	}
}
function normalizeRawArgument(arg, schema, transactionData) {
	if (arg.$kind !== "Input") return;
	const input = transactionData.inputs[arg.Input];
	if (input.$kind !== "UnresolvedPure") return;
	transactionData.inputs[arg.Input] = Inputs.Pure(schema.serialize(input.UnresolvedPure.value));
}

//#endregion
//#region node_modules/.pnpm/@mysten+sui@1.45.2_typescript@5.9.3/node_modules/@mysten/sui/dist/esm/transactions/object.js
function createObjectMethods(makeObject) {
	function object$1(value) {
		return makeObject(value);
	}
	object$1.system = (options) => {
		const mutable = options?.mutable;
		if (mutable !== void 0) return object$1(Inputs.SharedObjectRef({
			objectId: "0x5",
			initialSharedVersion: 1,
			mutable
		}));
		return object$1({
			$kind: "UnresolvedObject",
			UnresolvedObject: {
				objectId: "0x5",
				initialSharedVersion: 1
			}
		});
	};
	object$1.clock = () => object$1(Inputs.SharedObjectRef({
		objectId: "0x6",
		initialSharedVersion: 1,
		mutable: false
	}));
	object$1.random = () => object$1({
		$kind: "UnresolvedObject",
		UnresolvedObject: {
			objectId: "0x8",
			mutable: false
		}
	});
	object$1.denyList = (options) => {
		return object$1({
			$kind: "UnresolvedObject",
			UnresolvedObject: {
				objectId: "0x403",
				mutable: options?.mutable
			}
		});
	};
	object$1.option = ({ type, value }) => (tx) => tx.moveCall({
		typeArguments: [type],
		target: `0x1::option::${value === null ? "none" : "some"}`,
		arguments: value === null ? [] : [tx.object(value)]
	});
	return object$1;
}

//#endregion
//#region node_modules/.pnpm/@mysten+sui@1.45.2_typescript@5.9.3/node_modules/@mysten/sui/dist/esm/transactions/pure.js
function createPure(makePure) {
	function pure(typeOrSerializedValue, value) {
		if (typeof typeOrSerializedValue === "string") return makePure(pureBcsSchemaFromTypeName(typeOrSerializedValue).serialize(value));
		if (typeOrSerializedValue instanceof Uint8Array || isSerializedBcs(typeOrSerializedValue)) return makePure(typeOrSerializedValue);
		throw new Error("tx.pure must be called either a bcs type name, or a serialized bcs value");
	}
	pure.u8 = (value) => makePure(suiBcs.U8.serialize(value));
	pure.u16 = (value) => makePure(suiBcs.U16.serialize(value));
	pure.u32 = (value) => makePure(suiBcs.U32.serialize(value));
	pure.u64 = (value) => makePure(suiBcs.U64.serialize(value));
	pure.u128 = (value) => makePure(suiBcs.U128.serialize(value));
	pure.u256 = (value) => makePure(suiBcs.U256.serialize(value));
	pure.bool = (value) => makePure(suiBcs.Bool.serialize(value));
	pure.string = (value) => makePure(suiBcs.String.serialize(value));
	pure.address = (value) => makePure(suiBcs.Address.serialize(value));
	pure.id = pure.address;
	pure.vector = (type, value) => {
		return makePure(suiBcs.vector(pureBcsSchemaFromTypeName(type)).serialize(value));
	};
	pure.option = (type, value) => {
		return makePure(suiBcs.option(pureBcsSchemaFromTypeName(type)).serialize(value));
	};
	return pure;
}

//#endregion
//#region node_modules/.pnpm/@mysten+sui@1.45.2_typescript@5.9.3/node_modules/@mysten/sui/dist/esm/transactions/hash.js
function hashTypedData(typeTag, data) {
	const typeTagBytes = Array.from(`${typeTag}::`).map((e) => e.charCodeAt(0));
	const dataWithTag = new Uint8Array(typeTagBytes.length + data.length);
	dataWithTag.set(typeTagBytes);
	dataWithTag.set(data, typeTagBytes.length);
	return blake2b(dataWithTag, { dkLen: 32 });
}

//#endregion
//#region node_modules/.pnpm/@mysten+sui@1.45.2_typescript@5.9.3/node_modules/@mysten/sui/dist/esm/transactions/utils.js
function getIdFromCallArg(arg) {
	if (typeof arg === "string") return normalizeSuiAddress(arg);
	if (arg.Object) {
		if (arg.Object.ImmOrOwnedObject) return normalizeSuiAddress(arg.Object.ImmOrOwnedObject.objectId);
		if (arg.Object.Receiving) return normalizeSuiAddress(arg.Object.Receiving.objectId);
		return normalizeSuiAddress(arg.Object.SharedObject.objectId);
	}
	if (arg.UnresolvedObject) return normalizeSuiAddress(arg.UnresolvedObject.objectId);
}
function isArgument(value) {
	return is(ArgumentSchema, value);
}
function remapCommandArguments(command, inputMapping, commandMapping) {
	const remapArg = (arg) => {
		switch (arg.$kind) {
			case "Input": {
				const newInputIndex = inputMapping.get(arg.Input);
				if (newInputIndex === void 0) throw new Error(`Input ${arg.Input} not found in input mapping`);
				return {
					...arg,
					Input: newInputIndex
				};
			}
			case "Result": {
				const newCommandIndex = commandMapping.get(arg.Result);
				if (newCommandIndex !== void 0) return {
					...arg,
					Result: newCommandIndex
				};
				return arg;
			}
			case "NestedResult": {
				const newCommandIndex = commandMapping.get(arg.NestedResult[0]);
				if (newCommandIndex !== void 0) return {
					...arg,
					NestedResult: [newCommandIndex, arg.NestedResult[1]]
				};
				return arg;
			}
			default: return arg;
		}
	};
	switch (command.$kind) {
		case "MoveCall":
			command.MoveCall.arguments = command.MoveCall.arguments.map(remapArg);
			break;
		case "TransferObjects":
			command.TransferObjects.objects = command.TransferObjects.objects.map(remapArg);
			command.TransferObjects.address = remapArg(command.TransferObjects.address);
			break;
		case "SplitCoins":
			command.SplitCoins.coin = remapArg(command.SplitCoins.coin);
			command.SplitCoins.amounts = command.SplitCoins.amounts.map(remapArg);
			break;
		case "MergeCoins":
			command.MergeCoins.destination = remapArg(command.MergeCoins.destination);
			command.MergeCoins.sources = command.MergeCoins.sources.map(remapArg);
			break;
		case "MakeMoveVec":
			command.MakeMoveVec.elements = command.MakeMoveVec.elements.map(remapArg);
			break;
		case "Upgrade":
			command.Upgrade.ticket = remapArg(command.Upgrade.ticket);
			break;
		case "$Intent": {
			const inputs = command.$Intent.inputs;
			command.$Intent.inputs = {};
			for (const [key, value] of Object.entries(inputs)) command.$Intent.inputs[key] = Array.isArray(value) ? value.map(remapArg) : remapArg(value);
			break;
		}
		case "Publish": break;
	}
}

//#endregion
//#region node_modules/.pnpm/@mysten+sui@1.45.2_typescript@5.9.3/node_modules/@mysten/sui/dist/esm/transactions/TransactionData.js
function prepareSuiAddress(address) {
	return normalizeSuiAddress(address).replace("0x", "");
}
var TransactionDataBuilder = class TransactionDataBuilder {
	constructor(clone) {
		this.version = 2;
		this.sender = clone?.sender ?? null;
		this.expiration = clone?.expiration ?? null;
		this.inputs = clone?.inputs ?? [];
		this.commands = clone?.commands ?? [];
		this.gasData = clone?.gasData ?? {
			budget: null,
			price: null,
			owner: null,
			payment: null
		};
	}
	static fromKindBytes(bytes) {
		const programmableTx = suiBcs.TransactionKind.parse(bytes).ProgrammableTransaction;
		if (!programmableTx) throw new Error("Unable to deserialize from bytes.");
		return TransactionDataBuilder.restore({
			version: 2,
			sender: null,
			expiration: null,
			gasData: {
				budget: null,
				owner: null,
				payment: null,
				price: null
			},
			inputs: programmableTx.inputs,
			commands: programmableTx.commands
		});
	}
	static fromBytes(bytes) {
		const data = suiBcs.TransactionData.parse(bytes)?.V1;
		const programmableTx = data.kind.ProgrammableTransaction;
		if (!data || !programmableTx) throw new Error("Unable to deserialize from bytes.");
		return TransactionDataBuilder.restore({
			version: 2,
			sender: data.sender,
			expiration: data.expiration,
			gasData: data.gasData,
			inputs: programmableTx.inputs,
			commands: programmableTx.commands
		});
	}
	static restore(data) {
		if (data.version === 2) return new TransactionDataBuilder(parse(TransactionDataSchema, data));
		else return new TransactionDataBuilder(parse(TransactionDataSchema, transactionDataFromV1(data)));
	}
	/**
	* Generate transaction digest.
	*
	* @param bytes BCS serialized transaction data
	* @returns transaction digest.
	*/
	static getDigestFromBytes(bytes) {
		return toBase58(hashTypedData("TransactionData", bytes));
	}
	get gasConfig() {
		return this.gasData;
	}
	set gasConfig(value) {
		this.gasData = value;
	}
	build({ maxSizeBytes = Infinity, overrides, onlyTransactionKind } = {}) {
		const inputs = this.inputs;
		const commands = this.commands;
		const kind = { ProgrammableTransaction: {
			inputs,
			commands
		} };
		if (onlyTransactionKind) return suiBcs.TransactionKind.serialize(kind, { maxSize: maxSizeBytes }).toBytes();
		const expiration = overrides?.expiration ?? this.expiration;
		const sender = overrides?.sender ?? this.sender;
		const gasData = {
			...this.gasData,
			...overrides?.gasConfig,
			...overrides?.gasData
		};
		if (!sender) throw new Error("Missing transaction sender");
		if (!gasData.budget) throw new Error("Missing gas budget");
		if (!gasData.payment) throw new Error("Missing gas payment");
		if (!gasData.price) throw new Error("Missing gas price");
		const transactionData = {
			sender: prepareSuiAddress(sender),
			expiration: expiration ? expiration : { None: true },
			gasData: {
				payment: gasData.payment,
				owner: prepareSuiAddress(this.gasData.owner ?? sender),
				price: BigInt(gasData.price),
				budget: BigInt(gasData.budget)
			},
			kind: { ProgrammableTransaction: {
				inputs,
				commands
			} }
		};
		return suiBcs.TransactionData.serialize({ V1: transactionData }, { maxSize: maxSizeBytes }).toBytes();
	}
	addInput(type, arg) {
		const index = this.inputs.length;
		this.inputs.push(arg);
		return {
			Input: index,
			type,
			$kind: "Input"
		};
	}
	getInputUses(index, fn) {
		this.mapArguments((arg, command) => {
			if (arg.$kind === "Input" && arg.Input === index) fn(arg, command);
			return arg;
		});
	}
	mapCommandArguments(index, fn) {
		const command = this.commands[index];
		switch (command.$kind) {
			case "MoveCall":
				command.MoveCall.arguments = command.MoveCall.arguments.map((arg) => fn(arg, command, index));
				break;
			case "TransferObjects":
				command.TransferObjects.objects = command.TransferObjects.objects.map((arg) => fn(arg, command, index));
				command.TransferObjects.address = fn(command.TransferObjects.address, command, index);
				break;
			case "SplitCoins":
				command.SplitCoins.coin = fn(command.SplitCoins.coin, command, index);
				command.SplitCoins.amounts = command.SplitCoins.amounts.map((arg) => fn(arg, command, index));
				break;
			case "MergeCoins":
				command.MergeCoins.destination = fn(command.MergeCoins.destination, command, index);
				command.MergeCoins.sources = command.MergeCoins.sources.map((arg) => fn(arg, command, index));
				break;
			case "MakeMoveVec":
				command.MakeMoveVec.elements = command.MakeMoveVec.elements.map((arg) => fn(arg, command, index));
				break;
			case "Upgrade":
				command.Upgrade.ticket = fn(command.Upgrade.ticket, command, index);
				break;
			case "$Intent":
				const inputs = command.$Intent.inputs;
				command.$Intent.inputs = {};
				for (const [key, value] of Object.entries(inputs)) command.$Intent.inputs[key] = Array.isArray(value) ? value.map((arg) => fn(arg, command, index)) : fn(value, command, index);
				break;
			case "Publish": break;
			default: throw new Error(`Unexpected transaction kind: ${command.$kind}`);
		}
	}
	mapArguments(fn) {
		for (const commandIndex of this.commands.keys()) this.mapCommandArguments(commandIndex, fn);
	}
	replaceCommand(index, replacement, resultIndex = index) {
		if (!Array.isArray(replacement)) {
			this.commands[index] = replacement;
			return;
		}
		const sizeDiff = replacement.length - 1;
		this.commands.splice(index, 1, ...structuredClone(replacement));
		this.mapArguments((arg, _command, commandIndex) => {
			if (commandIndex < index + replacement.length) return arg;
			if (typeof resultIndex !== "number") {
				if (arg.$kind === "Result" && arg.Result === index || arg.$kind === "NestedResult" && arg.NestedResult[0] === index) if (!("NestedResult" in arg) || arg.NestedResult[1] === 0) return parse(ArgumentSchema, structuredClone(resultIndex));
				else throw new Error(`Cannot replace command ${index} with a specific result type: NestedResult[${index}, ${arg.NestedResult[1]}] references a nested element that cannot be mapped to the replacement result`);
			}
			switch (arg.$kind) {
				case "Result":
					if (arg.Result === index && typeof resultIndex === "number") arg.Result = resultIndex;
					if (arg.Result > index) arg.Result += sizeDiff;
					break;
				case "NestedResult":
					if (arg.NestedResult[0] === index && typeof resultIndex === "number") return {
						$kind: "NestedResult",
						NestedResult: [resultIndex, arg.NestedResult[1]]
					};
					if (arg.NestedResult[0] > index) arg.NestedResult[0] += sizeDiff;
					break;
			}
			return arg;
		});
	}
	replaceCommandWithTransaction(index, otherTransaction, result) {
		if (result.$kind !== "Result" && result.$kind !== "NestedResult") throw new Error("Result must be of kind Result or NestedResult");
		this.insertTransaction(index, otherTransaction);
		this.replaceCommand(index + otherTransaction.commands.length, [], "Result" in result ? { NestedResult: [result.Result + index, 0] } : { NestedResult: [result.NestedResult[0] + index, result.NestedResult[1]] });
	}
	insertTransaction(atCommandIndex, otherTransaction) {
		const inputMapping = /* @__PURE__ */ new Map();
		const commandMapping = /* @__PURE__ */ new Map();
		for (let i = 0; i < otherTransaction.inputs.length; i++) {
			const otherInput = otherTransaction.inputs[i];
			const id = getIdFromCallArg(otherInput);
			let existingIndex = -1;
			if (id !== void 0) {
				existingIndex = this.inputs.findIndex((input) => getIdFromCallArg(input) === id);
				if (existingIndex !== -1 && this.inputs[existingIndex].Object?.SharedObject && otherInput.Object?.SharedObject) this.inputs[existingIndex].Object.SharedObject.mutable = this.inputs[existingIndex].Object.SharedObject.mutable || otherInput.Object.SharedObject.mutable;
			}
			if (existingIndex !== -1) inputMapping.set(i, existingIndex);
			else {
				const newIndex = this.inputs.length;
				this.inputs.push(otherInput);
				inputMapping.set(i, newIndex);
			}
		}
		for (let i = 0; i < otherTransaction.commands.length; i++) commandMapping.set(i, atCommandIndex + i);
		const remappedCommands = [];
		for (let i = 0; i < otherTransaction.commands.length; i++) {
			const command = structuredClone(otherTransaction.commands[i]);
			remapCommandArguments(command, inputMapping, commandMapping);
			remappedCommands.push(command);
		}
		this.commands.splice(atCommandIndex, 0, ...remappedCommands);
		const sizeDiff = remappedCommands.length;
		if (sizeDiff > 0) this.mapArguments((arg, _command, commandIndex) => {
			if (commandIndex >= atCommandIndex && commandIndex < atCommandIndex + remappedCommands.length) return arg;
			switch (arg.$kind) {
				case "Result":
					if (arg.Result >= atCommandIndex) arg.Result += sizeDiff;
					break;
				case "NestedResult":
					if (arg.NestedResult[0] >= atCommandIndex) arg.NestedResult[0] += sizeDiff;
					break;
			}
			return arg;
		});
	}
	getDigest() {
		const bytes = this.build({ onlyTransactionKind: false });
		return TransactionDataBuilder.getDigestFromBytes(bytes);
	}
	snapshot() {
		return parse(TransactionDataSchema, this);
	}
	shallowClone() {
		return new TransactionDataBuilder({
			version: this.version,
			sender: this.sender,
			expiration: this.expiration,
			gasData: { ...this.gasData },
			inputs: [...this.inputs],
			commands: [...this.commands]
		});
	}
	applyResolvedData(resolved) {
		if (!this.sender) this.sender = resolved.sender ?? null;
		if (!this.expiration) this.expiration = resolved.expiration ?? null;
		if (!this.gasData.budget) this.gasData.budget = resolved.gasData.budget;
		if (!this.gasData.owner) this.gasData.owner = resolved.gasData.owner ?? null;
		if (!this.gasData.payment) this.gasData.payment = resolved.gasData.payment;
		if (!this.gasData.price) this.gasData.price = resolved.gasData.price;
		for (let i = 0; i < this.inputs.length; i++) {
			const input = this.inputs[i];
			const resolvedInput = resolved.inputs[i];
			switch (input.$kind) {
				case "UnresolvedPure":
					if (resolvedInput.$kind !== "Pure") throw new Error(`Expected input at index ${i} to resolve to a Pure argument, but got ${JSON.stringify(resolvedInput)}`);
					this.inputs[i] = resolvedInput;
					break;
				case "UnresolvedObject":
					if (resolvedInput.$kind !== "Object") throw new Error(`Expected input at index ${i} to resolve to an Object argument, but got ${JSON.stringify(resolvedInput)}`);
					if (resolvedInput.Object.$kind === "ImmOrOwnedObject" || resolvedInput.Object.$kind === "Receiving") {
						const original = input.UnresolvedObject;
						const resolved2 = resolvedInput.Object.ImmOrOwnedObject ?? resolvedInput.Object.Receiving;
						if (normalizeSuiAddress(original.objectId) !== normalizeSuiAddress(resolved2.objectId) || original.version != null && original.version !== resolved2.version || original.digest != null && original.digest !== resolved2.digest || original.mutable != null || original.initialSharedVersion != null) throw new Error(`Input at index ${i} did not match unresolved object. ${JSON.stringify(original)} is not compatible with ${JSON.stringify(resolved2)}`);
					} else if (resolvedInput.Object.$kind === "SharedObject") {
						const original = input.UnresolvedObject;
						const resolved2 = resolvedInput.Object.SharedObject;
						if (normalizeSuiAddress(original.objectId) !== normalizeSuiAddress(resolved2.objectId) || original.initialSharedVersion != null && original.initialSharedVersion !== resolved2.initialSharedVersion || original.mutable != null && original.mutable !== resolved2.mutable || original.version != null || original.digest != null) throw new Error(`Input at index ${i} did not match unresolved object. ${JSON.stringify(original)} is not compatible with ${JSON.stringify(resolved2)}`);
					} else throw new Error(`Input at index ${i} resolved to an unexpected Object kind: ${JSON.stringify(resolvedInput.Object)}`);
					this.inputs[i] = resolvedInput;
					break;
			}
		}
	}
};

//#endregion
//#region node_modules/.pnpm/@mysten+sui@1.45.2_typescript@5.9.3/node_modules/@mysten/sui/dist/esm/experimental/cache.js
var __typeError$2 = (msg) => {
	throw TypeError(msg);
};
var __accessCheck$2 = (obj, member, msg) => member.has(obj) || __typeError$2("Cannot " + msg);
var __privateGet$2 = (obj, member, getter) => (__accessCheck$2(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd$2 = (obj, member, value) => member.has(obj) ? __typeError$2("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet$2 = (obj, member, value, setter) => (__accessCheck$2(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var _prefix, _cache$1;
var _ClientCache = class _ClientCache$1 {
	constructor({ prefix, cache } = {}) {
		__privateAdd$2(this, _prefix);
		__privateAdd$2(this, _cache$1);
		__privateSet$2(this, _prefix, prefix ?? []);
		__privateSet$2(this, _cache$1, cache ?? /* @__PURE__ */ new Map());
	}
	read(key, load) {
		const cacheKey = [__privateGet$2(this, _prefix), ...key].join(":");
		if (__privateGet$2(this, _cache$1).has(cacheKey)) return __privateGet$2(this, _cache$1).get(cacheKey);
		const result = load();
		__privateGet$2(this, _cache$1).set(cacheKey, result);
		if (typeof result === "object" && result !== null && "then" in result) return Promise.resolve(result).then((v) => {
			__privateGet$2(this, _cache$1).set(cacheKey, v);
			return v;
		}).catch((err) => {
			__privateGet$2(this, _cache$1).delete(cacheKey);
			throw err;
		});
		return result;
	}
	readSync(key, load) {
		const cacheKey = [__privateGet$2(this, _prefix), ...key].join(":");
		if (__privateGet$2(this, _cache$1).has(cacheKey)) return __privateGet$2(this, _cache$1).get(cacheKey);
		const result = load();
		__privateGet$2(this, _cache$1).set(cacheKey, result);
		return result;
	}
	clear(prefix) {
		const prefixKey = [...__privateGet$2(this, _prefix), ...prefix ?? []].join(":");
		if (!prefixKey) {
			__privateGet$2(this, _cache$1).clear();
			return;
		}
		for (const key of __privateGet$2(this, _cache$1).keys()) if (key.startsWith(prefixKey)) __privateGet$2(this, _cache$1).delete(key);
	}
	scope(prefix) {
		return new _ClientCache$1({
			prefix: [...__privateGet$2(this, _prefix), ...Array.isArray(prefix) ? prefix : [prefix]],
			cache: __privateGet$2(this, _cache$1)
		});
	}
};
_prefix = /* @__PURE__ */ new WeakMap();
_cache$1 = /* @__PURE__ */ new WeakMap();
var ClientCache = _ClientCache;

//#endregion
//#region node_modules/.pnpm/@mysten+sui@1.45.2_typescript@5.9.3/node_modules/@mysten/sui/dist/esm/version.js
var PACKAGE_VERSION = "1.45.2";
var TARGETED_RPC_VERSION = "1.62.0";

//#endregion
//#region node_modules/.pnpm/@mysten+sui@1.45.2_typescript@5.9.3/node_modules/@mysten/sui/dist/esm/experimental/mvr.js
var __typeError$1 = (msg) => {
	throw TypeError(msg);
};
var __accessCheck$1 = (obj, member, msg) => member.has(obj) || __typeError$1("Cannot " + msg);
var __privateGet$1 = (obj, member, getter) => (__accessCheck$1(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd$1 = (obj, member, value) => member.has(obj) ? __typeError$1("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet$1 = (obj, member, value, setter) => (__accessCheck$1(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod$1 = (obj, member, method) => (__accessCheck$1(obj, member, "access private method"), method);
var _cache, _url, _pageSize, _overrides, _MvrClient_instances, mvrPackageDataLoader_get, mvrTypeDataLoader_get, resolvePackages_fn, resolveTypes_fn, fetch_fn;
var NAME_SEPARATOR = "/";
var MVR_API_HEADER = { "Mvr-Source": `@mysten/sui@${PACKAGE_VERSION}` };
var MvrClient = class {
	constructor({ cache, url, pageSize = 50, overrides }) {
		__privateAdd$1(this, _MvrClient_instances);
		__privateAdd$1(this, _cache);
		__privateAdd$1(this, _url);
		__privateAdd$1(this, _pageSize);
		__privateAdd$1(this, _overrides);
		__privateSet$1(this, _cache, cache);
		__privateSet$1(this, _url, url);
		__privateSet$1(this, _pageSize, pageSize);
		__privateSet$1(this, _overrides, {
			packages: overrides?.packages,
			types: overrides?.types
		});
		validateOverrides(__privateGet$1(this, _overrides));
	}
	async resolvePackage({ package: name }) {
		if (!hasMvrName(name)) return { package: name };
		return { package: await __privateGet$1(this, _MvrClient_instances, mvrPackageDataLoader_get).load(name) };
	}
	async resolveType({ type }) {
		if (!hasMvrName(type)) return { type };
		const mvrTypes = [...extractMvrTypes(type)];
		const resolvedTypes = await __privateGet$1(this, _MvrClient_instances, mvrTypeDataLoader_get).loadMany(mvrTypes);
		const typeMap = {};
		for (let i = 0; i < mvrTypes.length; i++) {
			const resolvedType = resolvedTypes[i];
			if (resolvedType instanceof Error) throw resolvedType;
			typeMap[mvrTypes[i]] = resolvedType;
		}
		return { type: replaceMvrNames(type, typeMap) };
	}
	async resolve({ types = [], packages = [] }) {
		const mvrTypes = /* @__PURE__ */ new Set();
		for (const type of types ?? []) extractMvrTypes(type, mvrTypes);
		const typesArray = [...mvrTypes];
		const [resolvedTypes, resolvedPackages] = await Promise.all([typesArray.length > 0 ? __privateGet$1(this, _MvrClient_instances, mvrTypeDataLoader_get).loadMany(typesArray) : [], packages.length > 0 ? __privateGet$1(this, _MvrClient_instances, mvrPackageDataLoader_get).loadMany(packages) : []]);
		const typeMap = { ...__privateGet$1(this, _overrides)?.types };
		for (const [i, type] of typesArray.entries()) {
			const resolvedType = resolvedTypes[i];
			if (resolvedType instanceof Error) throw resolvedType;
			typeMap[type] = resolvedType;
		}
		const replacedTypes = {};
		for (const type of types ?? []) replacedTypes[type] = { type: replaceMvrNames(type, typeMap) };
		const replacedPackages = {};
		for (const [i, pkg] of (packages ?? []).entries()) {
			const resolvedPkg = __privateGet$1(this, _overrides)?.packages?.[pkg] ?? resolvedPackages[i];
			if (resolvedPkg instanceof Error) throw resolvedPkg;
			replacedPackages[pkg] = { package: resolvedPkg };
		}
		return {
			types: replacedTypes,
			packages: replacedPackages
		};
	}
};
_cache = /* @__PURE__ */ new WeakMap();
_url = /* @__PURE__ */ new WeakMap();
_pageSize = /* @__PURE__ */ new WeakMap();
_overrides = /* @__PURE__ */ new WeakMap();
_MvrClient_instances = /* @__PURE__ */ new WeakSet();
mvrPackageDataLoader_get = function() {
	return __privateGet$1(this, _cache).readSync(["#mvrPackageDataLoader", __privateGet$1(this, _url) ?? ""], () => {
		const loader = new DataLoader(async (packages) => {
			if (!__privateGet$1(this, _url)) throw new Error(`MVR Api URL is not set for the current client (resolving ${packages.join(", ")})`);
			const resolved = await __privateMethod$1(this, _MvrClient_instances, resolvePackages_fn).call(this, packages);
			return packages.map((pkg) => resolved[pkg] ?? /* @__PURE__ */ new Error(`Failed to resolve package: ${pkg}`));
		});
		const overrides = __privateGet$1(this, _overrides)?.packages;
		if (overrides) for (const [pkg, id] of Object.entries(overrides)) loader.prime(pkg, id);
		return loader;
	});
};
mvrTypeDataLoader_get = function() {
	return __privateGet$1(this, _cache).readSync(["#mvrTypeDataLoader", __privateGet$1(this, _url) ?? ""], () => {
		const loader = new DataLoader(async (types) => {
			if (!__privateGet$1(this, _url)) throw new Error(`MVR Api URL is not set for the current client (resolving ${types.join(", ")})`);
			const resolved = await __privateMethod$1(this, _MvrClient_instances, resolveTypes_fn).call(this, types);
			return types.map((type) => resolved[type] ?? /* @__PURE__ */ new Error(`Failed to resolve type: ${type}`));
		});
		const overrides = __privateGet$1(this, _overrides)?.types;
		if (overrides) for (const [type, id] of Object.entries(overrides)) loader.prime(type, id);
		return loader;
	});
};
resolvePackages_fn = async function(packages) {
	if (packages.length === 0) return {};
	const batches = chunk(packages, __privateGet$1(this, _pageSize));
	const results = {};
	await Promise.all(batches.map(async (batch) => {
		const data = await __privateMethod$1(this, _MvrClient_instances, fetch_fn).call(this, "/v1/resolution/bulk", { names: batch });
		if (!data?.resolution) return;
		for (const pkg of Object.keys(data?.resolution)) {
			const pkgData = data.resolution[pkg]?.package_id;
			if (!pkgData) continue;
			results[pkg] = pkgData;
		}
	}));
	return results;
};
resolveTypes_fn = async function(types) {
	if (types.length === 0) return {};
	const batches = chunk(types, __privateGet$1(this, _pageSize));
	const results = {};
	await Promise.all(batches.map(async (batch) => {
		const data = await __privateMethod$1(this, _MvrClient_instances, fetch_fn).call(this, "/v1/struct-definition/bulk", { types: batch });
		if (!data?.resolution) return;
		for (const type of Object.keys(data?.resolution)) {
			const typeData = data.resolution[type]?.type_tag;
			if (!typeData) continue;
			results[type] = typeData;
		}
	}));
	return results;
};
fetch_fn = async function(url, body) {
	if (!__privateGet$1(this, _url)) throw new Error("MVR Api URL is not set for the current client");
	const response = await fetch(`${__privateGet$1(this, _url)}${url}`, {
		method: "POST",
		headers: {
			"Content-Type": "application/json",
			...MVR_API_HEADER
		},
		body: JSON.stringify(body)
	});
	if (!response.ok) {
		const errorBody = await response.json().catch(() => ({}));
		throw new Error(`Failed to resolve types: ${errorBody?.message}`);
	}
	return response.json();
};
function validateOverrides(overrides) {
	if (overrides?.packages) for (const [pkg, id] of Object.entries(overrides.packages)) {
		if (!isValidNamedPackage(pkg)) throw new Error(`Invalid package name: ${pkg}`);
		if (!isValidSuiAddress(normalizeSuiAddress(id))) throw new Error(`Invalid package ID: ${id}`);
	}
	if (overrides?.types) for (const [type, val] of Object.entries(overrides.types)) {
		if (parseStructTag(type).typeParams.length > 0) throw new Error("Type overrides must be first-level only. If you want to supply generic types, just pass each type individually.");
		if (!isValidSuiAddress(parseStructTag(val).address)) throw new Error(`Invalid type: ${val}`);
	}
}
function extractMvrTypes(type, types = /* @__PURE__ */ new Set()) {
	if (typeof type === "string" && !hasMvrName(type)) return types;
	const tag = isStructTag(type) ? type : parseStructTag(type);
	if (hasMvrName(tag.address)) types.add(`${tag.address}::${tag.module}::${tag.name}`);
	for (const param of tag.typeParams) extractMvrTypes(param, types);
	return types;
}
function replaceMvrNames(tag, typeCache) {
	const type = isStructTag(tag) ? tag : parseStructTag(tag);
	const cacheHit = typeCache[`${type.address}::${type.module}::${type.name}`];
	return normalizeStructTag({
		...type,
		address: cacheHit ? cacheHit.split("::")[0] : type.address,
		typeParams: type.typeParams.map((param) => replaceMvrNames(param, typeCache))
	});
}
function hasMvrName(nameOrType) {
	return nameOrType.includes(NAME_SEPARATOR) || nameOrType.includes("@") || nameOrType.includes(".sui");
}
function isStructTag(type) {
	return typeof type === "object" && "address" in type && "module" in type && "name" in type && "typeParams" in type;
}
function findNamesInTransaction(builder) {
	const packages = /* @__PURE__ */ new Set();
	const types = /* @__PURE__ */ new Set();
	for (const command of builder.commands) switch (command.$kind) {
		case "MakeMoveVec":
			if (command.MakeMoveVec.type) getNamesFromTypeList([command.MakeMoveVec.type]).forEach((type) => {
				types.add(type);
			});
			break;
		case "MoveCall":
			const moveCall = command.MoveCall;
			const pkg = moveCall.package.split("::")[0];
			if (hasMvrName(pkg)) {
				if (!isValidNamedPackage(pkg)) throw new Error(`Invalid package name: ${pkg}`);
				packages.add(pkg);
			}
			getNamesFromTypeList(moveCall.typeArguments ?? []).forEach((type) => {
				types.add(type);
			});
			break;
		default: break;
	}
	return {
		packages: [...packages],
		types: [...types]
	};
}
function replaceNames(builder, resolved) {
	for (const command of builder.commands) {
		if (command.MakeMoveVec?.type) {
			if (!hasMvrName(command.MakeMoveVec.type)) continue;
			if (!resolved.types[command.MakeMoveVec.type]) throw new Error(`No resolution found for type: ${command.MakeMoveVec.type}`);
			command.MakeMoveVec.type = resolved.types[command.MakeMoveVec.type].type;
		}
		const tx = command.MoveCall;
		if (!tx) continue;
		const nameParts = tx.package.split("::");
		const name = nameParts[0];
		if (hasMvrName(name) && !resolved.packages[name]) throw new Error(`No address found for package: ${name}`);
		if (hasMvrName(name)) {
			nameParts[0] = resolved.packages[name].package;
			tx.package = nameParts.join("::");
		}
		const types = tx.typeArguments;
		if (!types) continue;
		for (let i = 0; i < types.length; i++) {
			if (!hasMvrName(types[i])) continue;
			if (!resolved.types[types[i]]) throw new Error(`No resolution found for type: ${types[i]}`);
			types[i] = resolved.types[types[i]].type;
		}
		tx.typeArguments = types;
	}
}
function getNamesFromTypeList(types) {
	const names = /* @__PURE__ */ new Set();
	for (const type of types) if (hasMvrName(type)) {
		if (!isValidNamedType(type)) throw new Error(`Invalid type with names: ${type}`);
		names.add(type);
	}
	return names;
}

//#endregion
//#region node_modules/.pnpm/@mysten+sui@1.45.2_typescript@5.9.3/node_modules/@mysten/sui/dist/esm/transactions/plugins/NamedPackagesPlugin.js
var cacheMap = /* @__PURE__ */ new WeakMap();
var namedPackagesPlugin = (options) => {
	let mvrClient;
	if (options) {
		const overrides = options.overrides ?? {
			packages: {},
			types: {}
		};
		if (!cacheMap.has(overrides)) cacheMap.set(overrides, new ClientCache());
		mvrClient = new MvrClient({
			cache: cacheMap.get(overrides),
			url: options.url,
			pageSize: options.pageSize,
			overrides
		});
	}
	return async (transactionData, buildOptions, next) => {
		const names = findNamesInTransaction(transactionData);
		if (names.types.length === 0 && names.packages.length === 0) return next();
		replaceNames(transactionData, await (mvrClient || getClient(buildOptions).core.mvr).resolve({
			types: names.types,
			packages: names.packages
		}));
		await next();
	};
};
function getClient(options) {
	if (!options.client) throw new Error(`No sui client passed to Transaction#build, but transaction data was not sufficient to build offline.`);
	return options.client;
}

//#endregion
//#region node_modules/.pnpm/@mysten+sui@1.45.2_typescript@5.9.3/node_modules/@mysten/sui/dist/esm/transactions/Transaction.js
var __typeError = (msg) => {
	throw TypeError(msg);
};
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);
var _serializationPlugins, _buildPlugins, _intentResolvers, _inputSection, _commandSection, _availableResults, _pendingPromises, _added, _data, _Transaction_instances, fork_fn, addCommand_fn, addInput_fn, normalizeTransactionArgument_fn, resolveArgument_fn, prepareBuild_fn, runPlugins_fn, waitForPendingTasks_fn, sortCommandsAndInputs_fn;
function createTransactionResult(index, length = Infinity) {
	const baseResult = {
		$kind: "Result",
		get Result() {
			return typeof index === "function" ? index() : index;
		}
	};
	const nestedResults = [];
	const nestedResultFor = (resultIndex) => nestedResults[resultIndex] ?? (nestedResults[resultIndex] = {
		$kind: "NestedResult",
		get NestedResult() {
			return [typeof index === "function" ? index() : index, resultIndex];
		}
	});
	return new Proxy(baseResult, {
		set() {
			throw new Error("The transaction result is a proxy, and does not support setting properties directly");
		},
		get(target, property) {
			if (property in target) return Reflect.get(target, property);
			if (property === Symbol.iterator) return function* () {
				let i = 0;
				while (i < length) {
					yield nestedResultFor(i);
					i++;
				}
			};
			if (typeof property === "symbol") return;
			const resultIndex = parseInt(property, 10);
			if (Number.isNaN(resultIndex) || resultIndex < 0) return;
			return nestedResultFor(resultIndex);
		}
	});
}
var TRANSACTION_BRAND = Symbol.for("@mysten/transaction");
function isTransaction(obj) {
	return !!obj && typeof obj === "object" && obj[TRANSACTION_BRAND] === true;
}
var modulePluginRegistry = {
	buildPlugins: /* @__PURE__ */ new Map(),
	serializationPlugins: /* @__PURE__ */ new Map()
};
var TRANSACTION_REGISTRY_KEY = Symbol.for("@mysten/transaction/registry");
function getGlobalPluginRegistry() {
	try {
		const target = globalThis;
		if (!target[TRANSACTION_REGISTRY_KEY]) target[TRANSACTION_REGISTRY_KEY] = modulePluginRegistry;
		return target[TRANSACTION_REGISTRY_KEY];
	} catch {
		return modulePluginRegistry;
	}
}
var _Transaction = class _Transaction$1 {
	constructor() {
		__privateAdd(this, _Transaction_instances);
		__privateAdd(this, _serializationPlugins);
		__privateAdd(this, _buildPlugins);
		__privateAdd(this, _intentResolvers, /* @__PURE__ */ new Map());
		__privateAdd(this, _inputSection, []);
		__privateAdd(this, _commandSection, []);
		__privateAdd(this, _availableResults, /* @__PURE__ */ new Set());
		__privateAdd(this, _pendingPromises, /* @__PURE__ */ new Set());
		__privateAdd(this, _added, /* @__PURE__ */ new Map());
		__privateAdd(this, _data);
		/**
		* Add a new object input to the transaction.
		*/
		this.object = createObjectMethods((value) => {
			if (typeof value === "function") return this.object(this.add(value));
			if (typeof value === "object" && is(ArgumentSchema, value)) return value;
			const id = getIdFromCallArg(value);
			const inserted = __privateGet(this, _data).inputs.find((i) => id === getIdFromCallArg(i));
			if (inserted?.Object?.SharedObject && typeof value === "object" && value.Object?.SharedObject) inserted.Object.SharedObject.mutable = inserted.Object.SharedObject.mutable || value.Object.SharedObject.mutable;
			return inserted ? {
				$kind: "Input",
				Input: __privateGet(this, _data).inputs.indexOf(inserted),
				type: "object"
			} : __privateMethod(this, _Transaction_instances, addInput_fn).call(this, "object", typeof value === "string" ? {
				$kind: "UnresolvedObject",
				UnresolvedObject: { objectId: normalizeSuiAddress(value) }
			} : value);
		});
		const globalPlugins = getGlobalPluginRegistry();
		__privateSet(this, _data, new TransactionDataBuilder());
		__privateSet(this, _buildPlugins, [...globalPlugins.buildPlugins.values()]);
		__privateSet(this, _serializationPlugins, [...globalPlugins.serializationPlugins.values()]);
	}
	/**
	* Converts from a serialize transaction kind (built with `build({ onlyTransactionKind: true })`) to a `Transaction` class.
	* Supports either a byte array, or base64-encoded bytes.
	*/
	static fromKind(serialized) {
		const tx = new _Transaction$1();
		__privateSet(tx, _data, TransactionDataBuilder.fromKindBytes(typeof serialized === "string" ? fromBase64(serialized) : serialized));
		__privateSet(tx, _inputSection, __privateGet(tx, _data).inputs.slice());
		__privateSet(tx, _commandSection, __privateGet(tx, _data).commands.slice());
		__privateSet(tx, _availableResults, new Set(__privateGet(tx, _commandSection).map((_, i) => i)));
		return tx;
	}
	/**
	* Converts from a serialized transaction format to a `Transaction` class.
	* There are two supported serialized formats:
	* - A string returned from `Transaction#serialize`. The serialized format must be compatible, or it will throw an error.
	* - A byte array (or base64-encoded bytes) containing BCS transaction data.
	*/
	static from(transaction) {
		const newTransaction = new _Transaction$1();
		if (isTransaction(transaction)) __privateSet(newTransaction, _data, TransactionDataBuilder.restore(transaction.getData()));
		else if (typeof transaction !== "string" || !transaction.startsWith("{")) __privateSet(newTransaction, _data, TransactionDataBuilder.fromBytes(typeof transaction === "string" ? fromBase64(transaction) : transaction));
		else __privateSet(newTransaction, _data, TransactionDataBuilder.restore(JSON.parse(transaction)));
		__privateSet(newTransaction, _inputSection, __privateGet(newTransaction, _data).inputs.slice());
		__privateSet(newTransaction, _commandSection, __privateGet(newTransaction, _data).commands.slice());
		__privateSet(newTransaction, _availableResults, new Set(__privateGet(newTransaction, _commandSection).map((_, i) => i)));
		return newTransaction;
	}
	static registerGlobalSerializationPlugin(stepOrStep, step) {
		getGlobalPluginRegistry().serializationPlugins.set(stepOrStep, step ?? stepOrStep);
	}
	static unregisterGlobalSerializationPlugin(name) {
		getGlobalPluginRegistry().serializationPlugins.delete(name);
	}
	static registerGlobalBuildPlugin(stepOrStep, step) {
		getGlobalPluginRegistry().buildPlugins.set(stepOrStep, step ?? stepOrStep);
	}
	static unregisterGlobalBuildPlugin(name) {
		getGlobalPluginRegistry().buildPlugins.delete(name);
	}
	addSerializationPlugin(step) {
		__privateGet(this, _serializationPlugins).push(step);
	}
	addBuildPlugin(step) {
		__privateGet(this, _buildPlugins).push(step);
	}
	addIntentResolver(intent, resolver) {
		if (__privateGet(this, _intentResolvers).has(intent) && __privateGet(this, _intentResolvers).get(intent) !== resolver) throw new Error(`Intent resolver for ${intent} already exists`);
		__privateGet(this, _intentResolvers).set(intent, resolver);
	}
	setSender(sender) {
		__privateGet(this, _data).sender = sender;
	}
	/**
	* Sets the sender only if it has not already been set.
	* This is useful for sponsored transaction flows where the sender may not be the same as the signer address.
	*/
	setSenderIfNotSet(sender) {
		if (!__privateGet(this, _data).sender) __privateGet(this, _data).sender = sender;
	}
	setExpiration(expiration) {
		__privateGet(this, _data).expiration = expiration ? parse(TransactionExpiration, expiration) : null;
	}
	setGasPrice(price) {
		__privateGet(this, _data).gasConfig.price = String(price);
	}
	setGasBudget(budget) {
		__privateGet(this, _data).gasConfig.budget = String(budget);
	}
	setGasBudgetIfNotSet(budget) {
		if (__privateGet(this, _data).gasData.budget == null) __privateGet(this, _data).gasConfig.budget = String(budget);
	}
	setGasOwner(owner) {
		__privateGet(this, _data).gasConfig.owner = owner;
	}
	setGasPayment(payments) {
		__privateGet(this, _data).gasConfig.payment = payments.map((payment) => parse(ObjectRefSchema, payment));
	}
	/** @deprecated Use `getData()` instead. */
	get blockData() {
		return serializeV1TransactionData(__privateGet(this, _data).snapshot());
	}
	/** Get a snapshot of the transaction data, in JSON form: */
	getData() {
		return __privateGet(this, _data).snapshot();
	}
	get [TRANSACTION_BRAND]() {
		return true;
	}
	get pure() {
		Object.defineProperty(this, "pure", {
			enumerable: false,
			value: createPure((value) => {
				if (isSerializedBcs(value)) return __privateMethod(this, _Transaction_instances, addInput_fn).call(this, "pure", {
					$kind: "Pure",
					Pure: { bytes: value.toBase64() }
				});
				return __privateMethod(this, _Transaction_instances, addInput_fn).call(this, "pure", is(NormalizedCallArg, value) ? parse(NormalizedCallArg, value) : value instanceof Uint8Array ? Inputs.Pure(value) : {
					$kind: "UnresolvedPure",
					UnresolvedPure: { value }
				});
			})
		});
		return this.pure;
	}
	/** Returns an argument for the gas coin, to be used in a transaction. */
	get gas() {
		return {
			$kind: "GasCoin",
			GasCoin: true
		};
	}
	/**
	* Add a new object input to the transaction using the fully-resolved object reference.
	* If you only have an object ID, use `builder.object(id)` instead.
	*/
	objectRef(...args) {
		return this.object(Inputs.ObjectRef(...args));
	}
	/**
	* Add a new receiving input to the transaction using the fully-resolved object reference.
	* If you only have an object ID, use `builder.object(id)` instead.
	*/
	receivingRef(...args) {
		return this.object(Inputs.ReceivingRef(...args));
	}
	/**
	* Add a new shared object input to the transaction using the fully-resolved shared object reference.
	* If you only have an object ID, use `builder.object(id)` instead.
	*/
	sharedObjectRef(...args) {
		return this.object(Inputs.SharedObjectRef(...args));
	}
	add(command) {
		if (typeof command === "function") {
			if (__privateGet(this, _added).has(command)) return __privateGet(this, _added).get(command);
			const fork = __privateMethod(this, _Transaction_instances, fork_fn).call(this);
			const result = command(fork);
			if (!(result && typeof result === "object" && "then" in result)) {
				__privateSet(this, _availableResults, __privateGet(fork, _availableResults));
				__privateGet(this, _added).set(command, result);
				return result;
			}
			const placeholder = __privateMethod(this, _Transaction_instances, addCommand_fn).call(this, {
				$kind: "$Intent",
				$Intent: {
					name: "AsyncTransactionThunk",
					inputs: {},
					data: {
						resultIndex: __privateGet(this, _data).commands.length,
						result: null
					}
				}
			});
			__privateGet(this, _pendingPromises).add(Promise.resolve(result).then((result2) => {
				placeholder.$Intent.data.result = result2;
			}));
			const txResult = createTransactionResult(() => placeholder.$Intent.data.resultIndex);
			__privateGet(this, _added).set(command, txResult);
			return txResult;
		} else __privateMethod(this, _Transaction_instances, addCommand_fn).call(this, command);
		return createTransactionResult(__privateGet(this, _data).commands.length - 1);
	}
	splitCoins(coin, amounts) {
		const command = Commands.SplitCoins(typeof coin === "string" ? this.object(coin) : __privateMethod(this, _Transaction_instances, resolveArgument_fn).call(this, coin), amounts.map((amount) => typeof amount === "number" || typeof amount === "bigint" || typeof amount === "string" ? this.pure.u64(amount) : __privateMethod(this, _Transaction_instances, normalizeTransactionArgument_fn).call(this, amount)));
		__privateMethod(this, _Transaction_instances, addCommand_fn).call(this, command);
		return createTransactionResult(__privateGet(this, _data).commands.length - 1, amounts.length);
	}
	mergeCoins(destination, sources) {
		return this.add(Commands.MergeCoins(this.object(destination), sources.map((src) => this.object(src))));
	}
	publish({ modules, dependencies }) {
		return this.add(Commands.Publish({
			modules,
			dependencies
		}));
	}
	upgrade({ modules, dependencies, package: packageId, ticket }) {
		return this.add(Commands.Upgrade({
			modules,
			dependencies,
			package: packageId,
			ticket: this.object(ticket)
		}));
	}
	moveCall({ arguments: args, ...input }) {
		return this.add(Commands.MoveCall({
			...input,
			arguments: args?.map((arg) => __privateMethod(this, _Transaction_instances, normalizeTransactionArgument_fn).call(this, arg))
		}));
	}
	transferObjects(objects, address) {
		return this.add(Commands.TransferObjects(objects.map((obj) => this.object(obj)), typeof address === "string" ? this.pure.address(address) : __privateMethod(this, _Transaction_instances, normalizeTransactionArgument_fn).call(this, address)));
	}
	makeMoveVec({ type, elements }) {
		return this.add(Commands.MakeMoveVec({
			type,
			elements: elements.map((obj) => this.object(obj))
		}));
	}
	/**
	* @deprecated Use toJSON instead.
	* For synchronous serialization, you can use `getData()`
	* */
	serialize() {
		return JSON.stringify(serializeV1TransactionData(__privateGet(this, _data).snapshot()));
	}
	async toJSON(options = {}) {
		await this.prepareForSerialization(options);
		const fullyResolved = this.isFullyResolved();
		return JSON.stringify(parse(SerializedTransactionDataV2Schema, fullyResolved ? {
			...__privateGet(this, _data).snapshot(),
			digest: __privateGet(this, _data).getDigest()
		} : __privateGet(this, _data).snapshot()), (_key, value) => typeof value === "bigint" ? value.toString() : value, 2);
	}
	/** Build the transaction to BCS bytes, and sign it with the provided keypair. */
	async sign(options) {
		const { signer, ...buildOptions } = options;
		const bytes = await this.build(buildOptions);
		return signer.signTransaction(bytes);
	}
	/**
	*  Ensures that:
	*  - All objects have been fully resolved to a specific version
	*  - All pure inputs have been serialized to bytes
	*  - All async thunks have been fully resolved
	*  - All transaction intents have been resolved
	* 	- The gas payment, budget, and price have been set
	*  - The transaction sender has been set
	*
	*  When true, the transaction will always be built to the same bytes and digest (unless the transaction is mutated)
	*/
	isFullyResolved() {
		if (!__privateGet(this, _data).sender) return false;
		if (__privateGet(this, _pendingPromises).size > 0) return false;
		if (__privateGet(this, _data).commands.some((cmd) => cmd.$Intent)) return false;
		if (needsTransactionResolution(__privateGet(this, _data), {})) return false;
		return true;
	}
	/** Build the transaction to BCS bytes. */
	async build(options = {}) {
		await this.prepareForSerialization(options);
		await __privateMethod(this, _Transaction_instances, prepareBuild_fn).call(this, options);
		return __privateGet(this, _data).build({ onlyTransactionKind: options.onlyTransactionKind });
	}
	/** Derive transaction digest */
	async getDigest(options = {}) {
		await this.prepareForSerialization(options);
		await __privateMethod(this, _Transaction_instances, prepareBuild_fn).call(this, options);
		return __privateGet(this, _data).getDigest();
	}
	async prepareForSerialization(options) {
		await __privateMethod(this, _Transaction_instances, waitForPendingTasks_fn).call(this);
		__privateMethod(this, _Transaction_instances, sortCommandsAndInputs_fn).call(this);
		const intents = /* @__PURE__ */ new Set();
		for (const command of __privateGet(this, _data).commands) if (command.$Intent) intents.add(command.$Intent.name);
		const steps = [...__privateGet(this, _serializationPlugins)];
		for (const intent of intents) {
			if (options.supportedIntents?.includes(intent)) continue;
			if (!__privateGet(this, _intentResolvers).has(intent)) throw new Error(`Missing intent resolver for ${intent}`);
			steps.push(__privateGet(this, _intentResolvers).get(intent));
		}
		steps.push(namedPackagesPlugin());
		await __privateMethod(this, _Transaction_instances, runPlugins_fn).call(this, steps, options);
	}
};
_serializationPlugins = /* @__PURE__ */ new WeakMap();
_buildPlugins = /* @__PURE__ */ new WeakMap();
_intentResolvers = /* @__PURE__ */ new WeakMap();
_inputSection = /* @__PURE__ */ new WeakMap();
_commandSection = /* @__PURE__ */ new WeakMap();
_availableResults = /* @__PURE__ */ new WeakMap();
_pendingPromises = /* @__PURE__ */ new WeakMap();
_added = /* @__PURE__ */ new WeakMap();
_data = /* @__PURE__ */ new WeakMap();
_Transaction_instances = /* @__PURE__ */ new WeakSet();
fork_fn = function() {
	const fork = new _Transaction();
	__privateSet(fork, _data, __privateGet(this, _data));
	__privateSet(fork, _serializationPlugins, __privateGet(this, _serializationPlugins));
	__privateSet(fork, _buildPlugins, __privateGet(this, _buildPlugins));
	__privateSet(fork, _intentResolvers, __privateGet(this, _intentResolvers));
	__privateSet(fork, _pendingPromises, __privateGet(this, _pendingPromises));
	__privateSet(fork, _availableResults, new Set(__privateGet(this, _availableResults)));
	__privateSet(fork, _added, __privateGet(this, _added));
	__privateGet(this, _inputSection).push(__privateGet(fork, _inputSection));
	__privateGet(this, _commandSection).push(__privateGet(fork, _commandSection));
	return fork;
};
addCommand_fn = function(command) {
	const resultIndex = __privateGet(this, _data).commands.length;
	__privateGet(this, _commandSection).push(command);
	__privateGet(this, _availableResults).add(resultIndex);
	__privateGet(this, _data).commands.push(command);
	__privateGet(this, _data).mapCommandArguments(resultIndex, (arg) => {
		if (arg.$kind === "Result" && !__privateGet(this, _availableResults).has(arg.Result)) throw new Error(`Result { Result: ${arg.Result} } is not available to use in the current transaction`);
		if (arg.$kind === "NestedResult" && !__privateGet(this, _availableResults).has(arg.NestedResult[0])) throw new Error(`Result { NestedResult: [${arg.NestedResult[0]}, ${arg.NestedResult[1]}] } is not available to use in the current transaction`);
		if (arg.$kind === "Input" && arg.Input >= __privateGet(this, _data).inputs.length) throw new Error(`Input { Input: ${arg.Input} } references an input that does not exist in the current transaction`);
		return arg;
	});
	return command;
};
addInput_fn = function(type, input) {
	__privateGet(this, _inputSection).push(input);
	return __privateGet(this, _data).addInput(type, input);
};
normalizeTransactionArgument_fn = function(arg) {
	if (isSerializedBcs(arg)) return this.pure(arg);
	return __privateMethod(this, _Transaction_instances, resolveArgument_fn).call(this, arg);
};
resolveArgument_fn = function(arg) {
	if (typeof arg === "function") {
		const resolved = this.add(arg);
		if (typeof resolved === "function") return __privateMethod(this, _Transaction_instances, resolveArgument_fn).call(this, resolved);
		return parse(ArgumentSchema, resolved);
	}
	return parse(ArgumentSchema, arg);
};
prepareBuild_fn = async function(options) {
	if (!options.onlyTransactionKind && !__privateGet(this, _data).sender) throw new Error("Missing transaction sender");
	await __privateMethod(this, _Transaction_instances, runPlugins_fn).call(this, [...__privateGet(this, _buildPlugins), resolveTransactionPlugin], options);
};
runPlugins_fn = async function(plugins, options) {
	try {
		const createNext = (i) => {
			if (i >= plugins.length) return () => {};
			const plugin = plugins[i];
			return async () => {
				const next = createNext(i + 1);
				let calledNext = false;
				let nextResolved = false;
				await plugin(__privateGet(this, _data), options, async () => {
					if (calledNext) throw new Error(`next() was call multiple times in TransactionPlugin ${i}`);
					calledNext = true;
					await next();
					nextResolved = true;
				});
				if (!calledNext) throw new Error(`next() was not called in TransactionPlugin ${i}`);
				if (!nextResolved) throw new Error(`next() was not awaited in TransactionPlugin ${i}`);
			};
		};
		await createNext(0)();
	} finally {
		__privateSet(this, _inputSection, __privateGet(this, _data).inputs.slice());
		__privateSet(this, _commandSection, __privateGet(this, _data).commands.slice());
		__privateSet(this, _availableResults, new Set(__privateGet(this, _commandSection).map((_, i) => i)));
	}
};
waitForPendingTasks_fn = async function() {
	while (__privateGet(this, _pendingPromises).size > 0) {
		const newPromise = Promise.all(__privateGet(this, _pendingPromises));
		__privateGet(this, _pendingPromises).clear();
		__privateGet(this, _pendingPromises).add(newPromise);
		await newPromise;
		__privateGet(this, _pendingPromises).delete(newPromise);
	}
};
sortCommandsAndInputs_fn = function() {
	const unorderedCommands = __privateGet(this, _data).commands;
	const unorderedInputs = __privateGet(this, _data).inputs;
	const orderedCommands = __privateGet(this, _commandSection).flat(Infinity);
	const orderedInputs = __privateGet(this, _inputSection).flat(Infinity);
	if (orderedCommands.length !== unorderedCommands.length) throw new Error("Unexpected number of commands found in transaction data");
	if (orderedInputs.length !== unorderedInputs.length) throw new Error("Unexpected number of inputs found in transaction data");
	const filteredCommands = orderedCommands.filter((cmd) => cmd.$Intent?.name !== "AsyncTransactionThunk");
	__privateGet(this, _data).commands = filteredCommands;
	__privateGet(this, _data).inputs = orderedInputs;
	__privateSet(this, _commandSection, filteredCommands);
	__privateSet(this, _inputSection, orderedInputs);
	__privateSet(this, _availableResults, new Set(filteredCommands.map((_, i) => i)));
	function getOriginalIndex(index) {
		const command = unorderedCommands[index];
		if (command.$Intent?.name === "AsyncTransactionThunk") {
			const result = command.$Intent.data.result;
			if (result == null) throw new Error("AsyncTransactionThunk has not been resolved");
			return getOriginalIndex(result.Result);
		}
		const updated = filteredCommands.indexOf(command);
		if (updated === -1) throw new Error("Unable to find original index for command");
		return updated;
	}
	__privateGet(this, _data).mapArguments((arg) => {
		if (arg.$kind === "Input") {
			const updated = orderedInputs.indexOf(unorderedInputs[arg.Input]);
			if (updated === -1) throw new Error("Input has not been resolved");
			return {
				...arg,
				Input: updated
			};
		} else if (arg.$kind === "Result") {
			const updated = getOriginalIndex(arg.Result);
			return {
				...arg,
				Result: updated
			};
		} else if (arg.$kind === "NestedResult") {
			const updated = getOriginalIndex(arg.NestedResult[0]);
			return {
				...arg,
				NestedResult: [updated, arg.NestedResult[1]]
			};
		}
		return arg;
	});
	for (const [i, cmd] of unorderedCommands.entries()) if (cmd.$Intent?.name === "AsyncTransactionThunk") try {
		cmd.$Intent.data.resultIndex = getOriginalIndex(i);
	} catch {}
};
var Transaction = _Transaction;

//#endregion
export { abytes as $, Inputs as A, fromBase58 as At, add4L as B, optional as C, normalizeSuiNSName as Ct, string as D, toHex as Dt, safeParse as E, fromHex as Et, blake2b as F, rotrSH as G, add5L as H, add as I, shrSL as J, rotrSL as K, add3H as L, normalizedTypeToMoveTypeSignature as M, suiBcs as N, uuid as O, fromBase64 as Ot, TypeTagSerializer as P, Hash as Q, add3L as R, object as S, isValidNamedPackage as St, pipe as T, chunk as Tt, rotrBH as U, add5H as V, rotrBL as W, HashMD as X, split as Y, SHA512_IV as Z, array as _, isValidTransactionDigest as _t, hasMvrName as a, clean as at, literal as b, normalizeSuiObjectId as bt, ClientCache as c, createView as ct, createPure as d, kdfInputToBytes as dt, aexists as et, createObjectMethods as f, randomBytes as ft, UpgradePolicy as g, isValidSuiObjectId as gt, Commands as h, isValidSuiAddress as ht, MvrClient as i, checkOpts as it, getPureBcsSchema as j, bech32 as jt, variant as k, toBase64 as kt, TransactionDataBuilder as l, hexToBytes as lt, jsonRpcClientResolveTransactionPlugin as m, SUI_ADDRESS_LENGTH as mt, isTransaction as n, anumber as nt, PACKAGE_VERSION as o, concatBytes as ot, getClient$1 as p, toBytes as pt, shrSH as q, namedPackagesPlugin as r, bytesToHex as rt, TARGETED_RPC_VERSION as s, createHasher as st, Transaction as t, ahash as tt, isArgument as u, isBytes as ut, bigint as v, normalizeStructTag as vt, parse as w, bcs as wt, number as x, parseStructTag as xt, boolean as y, normalizeSuiAddress as yt, add4H as z };
//# sourceMappingURL=Transaction-DWkJnoaJ.js.map