import { A as Inputs, D as string, N as suiBcs, S as object, d as createPure, f as createObjectMethods, h as Commands, kt as toBase64, l as TransactionDataBuilder, n as isTransaction, p as getClient, t as Transaction, v as bigint, vt as normalizeStructTag, w as parse, yt as normalizeSuiAddress } from "./Transaction-DWkJnoaJ.js";

//#region node_modules/.pnpm/@mysten+utils@0.2.0/node_modules/@mysten/utils/dist/esm/with-resolver.js
function promiseWithResolvers() {
	let resolver;
	let rejecter;
	return {
		promise: new Promise((resolve, reject) => {
			resolver = resolve;
			rejecter = reject;
		}),
		resolve: resolver,
		reject: rejecter
	};
}

//#endregion
//#region node_modules/.pnpm/@mysten+sui@1.45.2_typescript@5.9.3/node_modules/@mysten/sui/dist/esm/transactions/ObjectCache.js
var __typeError$4 = (msg) => {
	throw TypeError(msg);
};
var __accessCheck$4 = (obj, member, msg) => member.has(obj) || __typeError$4("Cannot " + msg);
var __privateGet$4 = (obj, member, getter) => (__accessCheck$4(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd$4 = (obj, member, value) => member.has(obj) ? __typeError$4("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet$3 = (obj, member, value, setter) => (__accessCheck$4(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var _caches, _cache$2, _onEffects;
var AsyncCache = class {
	async getObject(id) {
		const [owned, shared] = await Promise.all([this.get("OwnedObject", id), this.get("SharedOrImmutableObject", id)]);
		return owned ?? shared ?? null;
	}
	async getObjects(ids) {
		return Promise.all(ids.map((id) => this.getObject(id)));
	}
	async addObject(object$1) {
		if (object$1.owner) await this.set("OwnedObject", object$1.objectId, object$1);
		else await this.set("SharedOrImmutableObject", object$1.objectId, object$1);
		return object$1;
	}
	async addObjects(objects) {
		await Promise.all(objects.map(async (object$1) => this.addObject(object$1)));
	}
	async deleteObject(id) {
		await Promise.all([this.delete("OwnedObject", id), this.delete("SharedOrImmutableObject", id)]);
	}
	async deleteObjects(ids) {
		await Promise.all(ids.map((id) => this.deleteObject(id)));
	}
	async getMoveFunctionDefinition(ref) {
		const functionName = `${normalizeSuiAddress(ref.package)}::${ref.module}::${ref.function}`;
		return this.get("MoveFunction", functionName);
	}
	async addMoveFunctionDefinition(functionEntry) {
		const pkg = normalizeSuiAddress(functionEntry.package);
		const functionName = `${pkg}::${functionEntry.module}::${functionEntry.function}`;
		const entry = {
			...functionEntry,
			package: pkg
		};
		await this.set("MoveFunction", functionName, entry);
		return entry;
	}
	async deleteMoveFunctionDefinition(ref) {
		const functionName = `${normalizeSuiAddress(ref.package)}::${ref.module}::${ref.function}`;
		await this.delete("MoveFunction", functionName);
	}
	async getCustom(key) {
		return this.get("Custom", key);
	}
	async setCustom(key, value) {
		return this.set("Custom", key, value);
	}
	async deleteCustom(key) {
		return this.delete("Custom", key);
	}
};
var InMemoryCache = class extends AsyncCache {
	constructor() {
		super(...arguments);
		__privateAdd$4(this, _caches, {
			OwnedObject: /* @__PURE__ */ new Map(),
			SharedOrImmutableObject: /* @__PURE__ */ new Map(),
			MoveFunction: /* @__PURE__ */ new Map(),
			Custom: /* @__PURE__ */ new Map()
		});
	}
	async get(type, key) {
		return __privateGet$4(this, _caches)[type].get(key) ?? null;
	}
	async set(type, key, value) {
		__privateGet$4(this, _caches)[type].set(key, value);
	}
	async delete(type, key) {
		__privateGet$4(this, _caches)[type].delete(key);
	}
	async clear(type) {
		if (type) __privateGet$4(this, _caches)[type].clear();
		else for (const cache of Object.values(__privateGet$4(this, _caches))) cache.clear();
	}
};
_caches = /* @__PURE__ */ new WeakMap();
var ObjectCache = class {
	constructor({ cache = new InMemoryCache(), onEffects }) {
		__privateAdd$4(this, _cache$2);
		__privateAdd$4(this, _onEffects);
		__privateSet$3(this, _cache$2, cache);
		__privateSet$3(this, _onEffects, onEffects);
	}
	asPlugin() {
		return async (transactionData, _options, next) => {
			const unresolvedObjects = transactionData.inputs.filter((input) => input.UnresolvedObject).map((input) => input.UnresolvedObject.objectId);
			const cached = (await __privateGet$4(this, _cache$2).getObjects(unresolvedObjects)).filter((obj) => obj !== null);
			const byId = new Map(cached.map((obj) => [obj.objectId, obj]));
			for (const input of transactionData.inputs) {
				if (!input.UnresolvedObject) continue;
				const cached2 = byId.get(input.UnresolvedObject.objectId);
				if (!cached2) continue;
				if (cached2.initialSharedVersion && !input.UnresolvedObject.initialSharedVersion) input.UnresolvedObject.initialSharedVersion = cached2.initialSharedVersion;
				else {
					if (cached2.version && !input.UnresolvedObject.version) input.UnresolvedObject.version = cached2.version;
					if (cached2.digest && !input.UnresolvedObject.digest) input.UnresolvedObject.digest = cached2.digest;
				}
			}
			await Promise.all(transactionData.commands.map(async (commands) => {
				if (commands.MoveCall) {
					const def = await this.getMoveFunctionDefinition({
						package: commands.MoveCall.package,
						module: commands.MoveCall.module,
						function: commands.MoveCall.function
					});
					if (def) commands.MoveCall._argumentTypes = def.parameters;
				}
			}));
			await next();
			await Promise.all(transactionData.commands.map(async (commands) => {
				if (commands.MoveCall?._argumentTypes) await __privateGet$4(this, _cache$2).addMoveFunctionDefinition({
					package: commands.MoveCall.package,
					module: commands.MoveCall.module,
					function: commands.MoveCall.function,
					parameters: commands.MoveCall._argumentTypes
				});
			}));
		};
	}
	async clear() {
		await __privateGet$4(this, _cache$2).clear();
	}
	async getMoveFunctionDefinition(ref) {
		return __privateGet$4(this, _cache$2).getMoveFunctionDefinition(ref);
	}
	async getObjects(ids) {
		return __privateGet$4(this, _cache$2).getObjects(ids);
	}
	async deleteObjects(ids) {
		return __privateGet$4(this, _cache$2).deleteObjects(ids);
	}
	async clearOwnedObjects() {
		await __privateGet$4(this, _cache$2).clear("OwnedObject");
	}
	async clearCustom() {
		await __privateGet$4(this, _cache$2).clear("Custom");
	}
	async getCustom(key) {
		return __privateGet$4(this, _cache$2).getCustom(key);
	}
	async setCustom(key, value) {
		return __privateGet$4(this, _cache$2).setCustom(key, value);
	}
	async deleteCustom(key) {
		return __privateGet$4(this, _cache$2).deleteCustom(key);
	}
	async applyEffects(effects) {
		var _a;
		if (!effects.V2) throw new Error(`Unsupported transaction effects version ${effects.$kind}`);
		const { lamportVersion, changedObjects } = effects.V2;
		const deletedIds = [];
		const addedObjects = [];
		changedObjects.forEach(([id, change]) => {
			if (change.outputState.NotExist) deletedIds.push(id);
			else if (change.outputState.ObjectWrite) {
				const [digest, owner] = change.outputState.ObjectWrite;
				addedObjects.push({
					objectId: id,
					digest,
					version: lamportVersion,
					owner: owner.AddressOwner ?? owner.ObjectOwner ?? null,
					initialSharedVersion: owner.Shared?.initialSharedVersion ?? null
				});
			}
		});
		await Promise.all([
			__privateGet$4(this, _cache$2).addObjects(addedObjects),
			__privateGet$4(this, _cache$2).deleteObjects(deletedIds),
			(_a = __privateGet$4(this, _onEffects)) == null ? void 0 : _a.call(this, effects)
		]);
	}
};
_cache$2 = /* @__PURE__ */ new WeakMap();
_onEffects = /* @__PURE__ */ new WeakMap();

//#endregion
//#region node_modules/.pnpm/@mysten+sui@1.45.2_typescript@5.9.3/node_modules/@mysten/sui/dist/esm/transactions/executor/caching.js
var __typeError$3 = (msg) => {
	throw TypeError(msg);
};
var __accessCheck$3 = (obj, member, msg) => member.has(obj) || __typeError$3("Cannot " + msg);
var __privateGet$3 = (obj, member, getter) => (__accessCheck$3(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd$3 = (obj, member, value) => member.has(obj) ? __typeError$3("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet$2 = (obj, member, value, setter) => (__accessCheck$3(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var _client$1, _lastDigest$1;
var CachingTransactionExecutor = class {
	constructor({ client, ...options }) {
		__privateAdd$3(this, _client$1);
		__privateAdd$3(this, _lastDigest$1, null);
		__privateSet$2(this, _client$1, client);
		this.cache = new ObjectCache(options);
	}
	/**
	* Clears all Owned objects
	* Immutable objects, Shared objects, and Move function definitions will be preserved
	*/
	async reset() {
		await Promise.all([
			this.cache.clearOwnedObjects(),
			this.cache.clearCustom(),
			this.waitForLastTransaction()
		]);
	}
	async buildTransaction({ transaction, ...options }) {
		transaction.addBuildPlugin(this.cache.asPlugin());
		return transaction.build({
			client: __privateGet$3(this, _client$1),
			...options
		});
	}
	async executeTransaction({ transaction, options, ...input }) {
		const bytes = isTransaction(transaction) ? await this.buildTransaction({ transaction }) : transaction;
		const results = await __privateGet$3(this, _client$1).executeTransactionBlock({
			...input,
			transactionBlock: bytes,
			options: {
				...options,
				showRawEffects: true
			}
		});
		if (results.rawEffects) {
			const effects = suiBcs.TransactionEffects.parse(Uint8Array.from(results.rawEffects));
			await this.applyEffects(effects);
		}
		return results;
	}
	async signAndExecuteTransaction({ options, transaction, ...input }) {
		transaction.setSenderIfNotSet(input.signer.toSuiAddress());
		const bytes = await this.buildTransaction({ transaction });
		const { signature } = await input.signer.signTransaction(bytes);
		return await this.executeTransaction({
			transaction: bytes,
			signature,
			options
		});
	}
	async applyEffects(effects) {
		__privateSet$2(this, _lastDigest$1, effects.V2?.transactionDigest ?? null);
		await this.cache.applyEffects(effects);
	}
	async waitForLastTransaction() {
		if (__privateGet$3(this, _lastDigest$1)) {
			await __privateGet$3(this, _client$1).waitForTransaction({ digest: __privateGet$3(this, _lastDigest$1) });
			__privateSet$2(this, _lastDigest$1, null);
		}
	}
};
_client$1 = /* @__PURE__ */ new WeakMap();
_lastDigest$1 = /* @__PURE__ */ new WeakMap();

//#endregion
//#region node_modules/.pnpm/@mysten+sui@1.45.2_typescript@5.9.3/node_modules/@mysten/sui/dist/esm/transactions/executor/queue.js
var __typeError$2 = (msg) => {
	throw TypeError(msg);
};
var __accessCheck$2 = (obj, member, msg) => member.has(obj) || __typeError$2("Cannot " + msg);
var __privateGet$2 = (obj, member, getter) => (__accessCheck$2(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd$2 = (obj, member, value) => member.has(obj) ? __typeError$2("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var _queue$1, _queue2;
var SerialQueue = class {
	constructor() {
		__privateAdd$2(this, _queue$1, []);
	}
	async runTask(task) {
		return new Promise((resolve, reject) => {
			__privateGet$2(this, _queue$1).push(() => {
				task().finally(() => {
					__privateGet$2(this, _queue$1).shift();
					if (__privateGet$2(this, _queue$1).length > 0) __privateGet$2(this, _queue$1)[0]();
				}).then(resolve, reject);
			});
			if (__privateGet$2(this, _queue$1).length === 1) __privateGet$2(this, _queue$1)[0]();
		});
	}
};
_queue$1 = /* @__PURE__ */ new WeakMap();
var ParallelQueue = class {
	constructor(maxTasks) {
		__privateAdd$2(this, _queue2, []);
		this.activeTasks = 0;
		this.maxTasks = maxTasks;
	}
	runTask(task) {
		return new Promise((resolve, reject) => {
			if (this.activeTasks < this.maxTasks) {
				this.activeTasks++;
				task().finally(() => {
					if (__privateGet$2(this, _queue2).length > 0) __privateGet$2(this, _queue2).shift()();
					else this.activeTasks--;
				}).then(resolve, reject);
			} else __privateGet$2(this, _queue2).push(() => {
				task().finally(() => {
					if (__privateGet$2(this, _queue2).length > 0) __privateGet$2(this, _queue2).shift()();
					else this.activeTasks--;
				}).then(resolve, reject);
			});
		});
	}
};
_queue2 = /* @__PURE__ */ new WeakMap();

//#endregion
//#region node_modules/.pnpm/@mysten+sui@1.45.2_typescript@5.9.3/node_modules/@mysten/sui/dist/esm/transactions/executor/serial.js
var __typeError$1 = (msg) => {
	throw TypeError(msg);
};
var __accessCheck$1 = (obj, member, msg) => member.has(obj) || __typeError$1("Cannot " + msg);
var __privateGet$1 = (obj, member, getter) => (__accessCheck$1(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd$1 = (obj, member, value) => member.has(obj) ? __typeError$1("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet$1 = (obj, member, value, setter) => (__accessCheck$1(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var _queue, _signer$1, _cache$1, _defaultGasBudget$1, _cacheGasCoin, _buildTransaction;
var SerialTransactionExecutor = class {
	constructor({ signer, defaultGasBudget = 50000000n, ...options }) {
		__privateAdd$1(this, _queue, new SerialQueue());
		__privateAdd$1(this, _signer$1);
		__privateAdd$1(this, _cache$1);
		__privateAdd$1(this, _defaultGasBudget$1);
		__privateAdd$1(this, _cacheGasCoin, async (effects) => {
			if (!effects.V2) return;
			const gasCoin = getGasCoinFromEffects(effects).ref;
			if (gasCoin) __privateGet$1(this, _cache$1).cache.setCustom("gasCoin", gasCoin);
			else __privateGet$1(this, _cache$1).cache.deleteCustom("gasCoin");
		});
		__privateAdd$1(this, _buildTransaction, async (transaction) => {
			const gasCoin = await __privateGet$1(this, _cache$1).cache.getCustom("gasCoin");
			const copy = Transaction.from(transaction);
			if (gasCoin) copy.setGasPayment([gasCoin]);
			copy.setGasBudgetIfNotSet(__privateGet$1(this, _defaultGasBudget$1));
			copy.setSenderIfNotSet(__privateGet$1(this, _signer$1).toSuiAddress());
			return __privateGet$1(this, _cache$1).buildTransaction({ transaction: copy });
		});
		__privateSet$1(this, _signer$1, signer);
		__privateSet$1(this, _defaultGasBudget$1, defaultGasBudget);
		__privateSet$1(this, _cache$1, new CachingTransactionExecutor({
			client: options.client,
			cache: options.cache,
			onEffects: (effects) => __privateGet$1(this, _cacheGasCoin).call(this, effects)
		}));
	}
	async applyEffects(effects) {
		return __privateGet$1(this, _cache$1).applyEffects(effects);
	}
	async buildTransaction(transaction) {
		return __privateGet$1(this, _queue).runTask(() => __privateGet$1(this, _buildTransaction).call(this, transaction));
	}
	resetCache() {
		return __privateGet$1(this, _cache$1).reset();
	}
	waitForLastTransaction() {
		return __privateGet$1(this, _cache$1).waitForLastTransaction();
	}
	executeTransaction(transaction, options, additionalSignatures = []) {
		return __privateGet$1(this, _queue).runTask(async () => {
			const bytes = isTransaction(transaction) ? await __privateGet$1(this, _buildTransaction).call(this, transaction) : transaction;
			const { signature } = await __privateGet$1(this, _signer$1).signTransaction(bytes);
			const results = await __privateGet$1(this, _cache$1).executeTransaction({
				signature: [signature, ...additionalSignatures],
				transaction: bytes,
				options
			}).catch(async (error) => {
				await this.resetCache();
				throw error;
			});
			const effectsBytes = Uint8Array.from(results.rawEffects);
			return {
				digest: results.digest,
				effects: toBase64(effectsBytes),
				data: results
			};
		});
	}
};
_queue = /* @__PURE__ */ new WeakMap();
_signer$1 = /* @__PURE__ */ new WeakMap();
_cache$1 = /* @__PURE__ */ new WeakMap();
_defaultGasBudget$1 = /* @__PURE__ */ new WeakMap();
_cacheGasCoin = /* @__PURE__ */ new WeakMap();
_buildTransaction = /* @__PURE__ */ new WeakMap();
function getGasCoinFromEffects(effects) {
	if (!effects.V2) throw new Error("Unexpected effects version");
	const gasObjectChange = effects.V2.changedObjects[effects.V2.gasObjectIndex];
	if (!gasObjectChange) throw new Error("Gas object not found in effects");
	const [objectId, { outputState }] = gasObjectChange;
	if (!outputState.ObjectWrite) throw new Error("Unexpected gas object state");
	const [digest, owner] = outputState.ObjectWrite;
	return {
		ref: {
			objectId,
			digest,
			version: effects.V2.lamportVersion
		},
		owner: owner.AddressOwner || owner.ObjectOwner
	};
}

//#endregion
//#region node_modules/.pnpm/@mysten+sui@1.45.2_typescript@5.9.3/node_modules/@mysten/sui/dist/esm/transactions/executor/parallel.js
var __typeError = (msg) => {
	throw TypeError(msg);
};
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);
var __privateWrapper = (obj, member, setter, getter) => ({
	set _(value) {
		__privateSet(obj, member, value, setter);
	},
	get _() {
		return __privateGet(obj, member, getter);
	}
});
var _signer, _client, _coinBatchSize, _initialCoinBalance, _minimumCoinBalance, _epochBoundaryWindow, _defaultGasBudget, _maxPoolSize, _sourceCoins, _coinPool, _cache, _objectIdQueues, _buildQueue, _executeQueue, _lastDigest, _cacheLock, _pendingTransactions, _gasPrice, _ParallelTransactionExecutor_instances, getUsedObjects_fn, execute_fn, updateCache_fn, waitForLastDigest_fn, getGasCoin_fn, getGasPrice_fn, refillCoinPool_fn;
var PARALLEL_EXECUTOR_DEFAULTS = {
	coinBatchSize: 20,
	initialCoinBalance: 200000000n,
	minimumCoinBalance: 50000000n,
	maxPoolSize: 50,
	epochBoundaryWindow: 1e3
};
var ParallelTransactionExecutor = class {
	constructor(options) {
		__privateAdd(this, _ParallelTransactionExecutor_instances);
		__privateAdd(this, _signer);
		__privateAdd(this, _client);
		__privateAdd(this, _coinBatchSize);
		__privateAdd(this, _initialCoinBalance);
		__privateAdd(this, _minimumCoinBalance);
		__privateAdd(this, _epochBoundaryWindow);
		__privateAdd(this, _defaultGasBudget);
		__privateAdd(this, _maxPoolSize);
		__privateAdd(this, _sourceCoins);
		__privateAdd(this, _coinPool, []);
		__privateAdd(this, _cache);
		__privateAdd(this, _objectIdQueues, /* @__PURE__ */ new Map());
		__privateAdd(this, _buildQueue, new SerialQueue());
		__privateAdd(this, _executeQueue);
		__privateAdd(this, _lastDigest, null);
		__privateAdd(this, _cacheLock, null);
		__privateAdd(this, _pendingTransactions, 0);
		__privateAdd(this, _gasPrice, null);
		__privateSet(this, _signer, options.signer);
		__privateSet(this, _client, options.client);
		__privateSet(this, _coinBatchSize, options.coinBatchSize ?? PARALLEL_EXECUTOR_DEFAULTS.coinBatchSize);
		__privateSet(this, _initialCoinBalance, options.initialCoinBalance ?? PARALLEL_EXECUTOR_DEFAULTS.initialCoinBalance);
		__privateSet(this, _minimumCoinBalance, options.minimumCoinBalance ?? PARALLEL_EXECUTOR_DEFAULTS.minimumCoinBalance);
		__privateSet(this, _defaultGasBudget, options.defaultGasBudget ?? __privateGet(this, _minimumCoinBalance));
		__privateSet(this, _epochBoundaryWindow, options.epochBoundaryWindow ?? PARALLEL_EXECUTOR_DEFAULTS.epochBoundaryWindow);
		__privateSet(this, _maxPoolSize, options.maxPoolSize ?? PARALLEL_EXECUTOR_DEFAULTS.maxPoolSize);
		__privateSet(this, _cache, new CachingTransactionExecutor({
			client: options.client,
			cache: options.cache
		}));
		__privateSet(this, _executeQueue, new ParallelQueue(__privateGet(this, _maxPoolSize)));
		__privateSet(this, _sourceCoins, options.sourceCoins ? new Map(options.sourceCoins.map((id) => [id, null])) : null);
	}
	resetCache() {
		__privateSet(this, _gasPrice, null);
		return __privateMethod(this, _ParallelTransactionExecutor_instances, updateCache_fn).call(this, () => __privateGet(this, _cache).reset());
	}
	async waitForLastTransaction() {
		await __privateMethod(this, _ParallelTransactionExecutor_instances, updateCache_fn).call(this, () => __privateMethod(this, _ParallelTransactionExecutor_instances, waitForLastDigest_fn).call(this));
	}
	async executeTransaction(transaction, options, additionalSignatures = []) {
		const { promise, resolve, reject } = promiseWithResolvers();
		const usedObjects = await __privateMethod(this, _ParallelTransactionExecutor_instances, getUsedObjects_fn).call(this, transaction);
		const execute = () => {
			__privateGet(this, _executeQueue).runTask(() => {
				return __privateMethod(this, _ParallelTransactionExecutor_instances, execute_fn).call(this, transaction, usedObjects, options, additionalSignatures).then(resolve, reject);
			});
		};
		const conflicts = /* @__PURE__ */ new Set();
		usedObjects.forEach((objectId) => {
			if (__privateGet(this, _objectIdQueues).get(objectId)) {
				conflicts.add(objectId);
				__privateGet(this, _objectIdQueues).get(objectId).push(() => {
					conflicts.delete(objectId);
					if (conflicts.size === 0) execute();
				});
			} else __privateGet(this, _objectIdQueues).set(objectId, []);
		});
		if (conflicts.size === 0) execute();
		return promise;
	}
};
_signer = /* @__PURE__ */ new WeakMap();
_client = /* @__PURE__ */ new WeakMap();
_coinBatchSize = /* @__PURE__ */ new WeakMap();
_initialCoinBalance = /* @__PURE__ */ new WeakMap();
_minimumCoinBalance = /* @__PURE__ */ new WeakMap();
_epochBoundaryWindow = /* @__PURE__ */ new WeakMap();
_defaultGasBudget = /* @__PURE__ */ new WeakMap();
_maxPoolSize = /* @__PURE__ */ new WeakMap();
_sourceCoins = /* @__PURE__ */ new WeakMap();
_coinPool = /* @__PURE__ */ new WeakMap();
_cache = /* @__PURE__ */ new WeakMap();
_objectIdQueues = /* @__PURE__ */ new WeakMap();
_buildQueue = /* @__PURE__ */ new WeakMap();
_executeQueue = /* @__PURE__ */ new WeakMap();
_lastDigest = /* @__PURE__ */ new WeakMap();
_cacheLock = /* @__PURE__ */ new WeakMap();
_pendingTransactions = /* @__PURE__ */ new WeakMap();
_gasPrice = /* @__PURE__ */ new WeakMap();
_ParallelTransactionExecutor_instances = /* @__PURE__ */ new WeakSet();
getUsedObjects_fn = async function(transaction) {
	const usedObjects = /* @__PURE__ */ new Set();
	let serialized = false;
	transaction.addSerializationPlugin(async (blockData, _options, next) => {
		await next();
		if (serialized) return;
		serialized = true;
		blockData.inputs.forEach((input) => {
			if (input.Object?.ImmOrOwnedObject?.objectId) usedObjects.add(input.Object.ImmOrOwnedObject.objectId);
			else if (input.Object?.Receiving?.objectId) usedObjects.add(input.Object.Receiving.objectId);
			else if (input.UnresolvedObject?.objectId && !input.UnresolvedObject.initialSharedVersion) usedObjects.add(input.UnresolvedObject.objectId);
		});
	});
	await transaction.prepareForSerialization({ client: __privateGet(this, _client) });
	return usedObjects;
};
execute_fn = async function(transaction, usedObjects, options, additionalSignatures = []) {
	let gasCoin;
	try {
		transaction.setSenderIfNotSet(__privateGet(this, _signer).toSuiAddress());
		await __privateGet(this, _buildQueue).runTask(async () => {
			if (!transaction.getData().gasData.price) transaction.setGasPrice(await __privateMethod(this, _ParallelTransactionExecutor_instances, getGasPrice_fn).call(this));
			transaction.setGasBudgetIfNotSet(__privateGet(this, _defaultGasBudget));
			await __privateMethod(this, _ParallelTransactionExecutor_instances, updateCache_fn).call(this);
			gasCoin = await __privateMethod(this, _ParallelTransactionExecutor_instances, getGasCoin_fn).call(this);
			__privateWrapper(this, _pendingTransactions)._++;
			transaction.setGasPayment([{
				objectId: gasCoin.id,
				version: gasCoin.version,
				digest: gasCoin.digest
			}]);
			await __privateGet(this, _cache).buildTransaction({
				transaction,
				onlyTransactionKind: true
			});
		});
		const bytes = await transaction.build({ client: __privateGet(this, _client) });
		const { signature } = await __privateGet(this, _signer).signTransaction(bytes);
		const results = await __privateGet(this, _cache).executeTransaction({
			transaction: bytes,
			signature: [signature, ...additionalSignatures],
			options: {
				...options,
				showEffects: true
			}
		});
		const effectsBytes = Uint8Array.from(results.rawEffects);
		const effects = suiBcs.TransactionEffects.parse(effectsBytes);
		const gasResult = getGasCoinFromEffects(effects);
		const gasUsed = effects.V2?.gasUsed;
		if (gasCoin && gasUsed && gasResult.owner === __privateGet(this, _signer).toSuiAddress()) {
			const totalUsed = BigInt(gasUsed.computationCost) + BigInt(gasUsed.storageCost) + BigInt(gasUsed.storageCost) - BigInt(gasUsed.storageRebate);
			const remainingBalance = gasCoin.balance - totalUsed;
			let usesGasCoin = false;
			new TransactionDataBuilder(transaction.getData()).mapArguments((arg) => {
				if (arg.$kind === "GasCoin") usesGasCoin = true;
				return arg;
			});
			if (!usesGasCoin && remainingBalance >= __privateGet(this, _minimumCoinBalance)) __privateGet(this, _coinPool).push({
				id: gasResult.ref.objectId,
				version: gasResult.ref.version,
				digest: gasResult.ref.digest,
				balance: remainingBalance
			});
			else {
				if (!__privateGet(this, _sourceCoins)) __privateSet(this, _sourceCoins, /* @__PURE__ */ new Map());
				__privateGet(this, _sourceCoins).set(gasResult.ref.objectId, gasResult.ref);
			}
		}
		__privateSet(this, _lastDigest, results.digest);
		return {
			digest: results.digest,
			effects: toBase64(effectsBytes),
			data: results
		};
	} catch (error) {
		if (gasCoin) {
			if (!__privateGet(this, _sourceCoins)) __privateSet(this, _sourceCoins, /* @__PURE__ */ new Map());
			__privateGet(this, _sourceCoins).set(gasCoin.id, null);
		}
		await __privateMethod(this, _ParallelTransactionExecutor_instances, updateCache_fn).call(this, async () => {
			await Promise.all([__privateGet(this, _cache).cache.deleteObjects([...usedObjects]), __privateMethod(this, _ParallelTransactionExecutor_instances, waitForLastDigest_fn).call(this)]);
		});
		throw error;
	} finally {
		usedObjects.forEach((objectId) => {
			const queue = __privateGet(this, _objectIdQueues).get(objectId);
			if (queue && queue.length > 0) queue.shift()();
			else if (queue) __privateGet(this, _objectIdQueues).delete(objectId);
		});
		__privateWrapper(this, _pendingTransactions)._--;
	}
};
updateCache_fn = async function(fn) {
	if (__privateGet(this, _cacheLock)) await __privateGet(this, _cacheLock);
	__privateSet(this, _cacheLock, fn?.().then(() => {
		__privateSet(this, _cacheLock, null);
	}, () => {}) ?? null);
};
waitForLastDigest_fn = async function() {
	const digest = __privateGet(this, _lastDigest);
	if (digest) {
		__privateSet(this, _lastDigest, null);
		await __privateGet(this, _client).waitForTransaction({ digest });
	}
};
getGasCoin_fn = async function() {
	if (__privateGet(this, _coinPool).length === 0 && __privateGet(this, _pendingTransactions) <= __privateGet(this, _maxPoolSize)) await __privateMethod(this, _ParallelTransactionExecutor_instances, refillCoinPool_fn).call(this);
	if (__privateGet(this, _coinPool).length === 0) throw new Error("No coins available");
	return __privateGet(this, _coinPool).shift();
};
getGasPrice_fn = async function() {
	if ((__privateGet(this, _gasPrice) ? __privateGet(this, _gasPrice).expiration - __privateGet(this, _epochBoundaryWindow) - Date.now() : 0) > 0) return __privateGet(this, _gasPrice).price;
	if (__privateGet(this, _gasPrice)) {
		const timeToNextEpoch = Math.max(__privateGet(this, _gasPrice).expiration + __privateGet(this, _epochBoundaryWindow) - Date.now(), 1e3);
		await new Promise((resolve) => setTimeout(resolve, timeToNextEpoch));
	}
	const state = await __privateGet(this, _client).getLatestSuiSystemState();
	__privateSet(this, _gasPrice, {
		price: BigInt(state.referenceGasPrice),
		expiration: Number.parseInt(state.epochStartTimestampMs, 10) + Number.parseInt(state.epochDurationMs, 10)
	});
	return __privateMethod(this, _ParallelTransactionExecutor_instances, getGasPrice_fn).call(this);
};
refillCoinPool_fn = async function() {
	const batchSize = Math.min(__privateGet(this, _coinBatchSize), __privateGet(this, _maxPoolSize) - (__privateGet(this, _coinPool).length + __privateGet(this, _pendingTransactions)) + 1);
	if (batchSize === 0) return;
	const txb = new Transaction();
	const address = __privateGet(this, _signer).toSuiAddress();
	txb.setSender(address);
	if (__privateGet(this, _sourceCoins)) {
		const refs = [];
		const ids = [];
		for (const [id, ref] of __privateGet(this, _sourceCoins)) if (ref) refs.push(ref);
		else ids.push(id);
		if (ids.length > 0) {
			const coins = await __privateGet(this, _client).multiGetObjects({ ids });
			refs.push(...coins.filter((coin) => coin.data !== null).map(({ data }) => ({
				objectId: data.objectId,
				version: data.version,
				digest: data.digest
			})));
		}
		txb.setGasPayment(refs);
		__privateSet(this, _sourceCoins, /* @__PURE__ */ new Map());
	}
	const amounts = new Array(batchSize).fill(__privateGet(this, _initialCoinBalance));
	const results = txb.splitCoins(txb.gas, amounts);
	const coinResults = [];
	for (let i = 0; i < amounts.length; i++) coinResults.push(results[i]);
	txb.transferObjects(coinResults, address);
	await this.waitForLastTransaction();
	const result = await __privateGet(this, _client).signAndExecuteTransaction({
		transaction: txb,
		signer: __privateGet(this, _signer),
		options: { showRawEffects: true }
	});
	const effects = suiBcs.TransactionEffects.parse(Uint8Array.from(result.rawEffects));
	effects.V2?.changedObjects.forEach(([id, { outputState }], i) => {
		if (i === effects.V2?.gasObjectIndex || !outputState.ObjectWrite) return;
		__privateGet(this, _coinPool).push({
			id,
			version: effects.V2.lamportVersion,
			digest: outputState.ObjectWrite[0],
			balance: BigInt(__privateGet(this, _initialCoinBalance))
		});
	});
	if (!__privateGet(this, _sourceCoins)) __privateSet(this, _sourceCoins, /* @__PURE__ */ new Map());
	const gasObject = getGasCoinFromEffects(effects).ref;
	__privateGet(this, _sourceCoins).set(gasObject.objectId, gasObject);
	await __privateGet(this, _client).waitForTransaction({ digest: result.digest });
};

//#endregion
//#region node_modules/.pnpm/@mysten+sui@1.45.2_typescript@5.9.3/node_modules/@mysten/sui/dist/esm/transactions/intents/CoinWithBalance.js
var COIN_WITH_BALANCE = "CoinWithBalance";
var SUI_TYPE = normalizeStructTag("0x2::sui::SUI");
function coinWithBalance({ type = SUI_TYPE, balance, useGasCoin = true }) {
	let coinResult = null;
	return (tx) => {
		if (coinResult) return coinResult;
		tx.addIntentResolver(COIN_WITH_BALANCE, resolveCoinBalance);
		const coinType = type === "gas" ? type : normalizeStructTag(type);
		coinResult = tx.add(Commands.Intent({
			name: COIN_WITH_BALANCE,
			inputs: {},
			data: {
				type: coinType === SUI_TYPE && useGasCoin ? "gas" : coinType,
				balance: BigInt(balance)
			}
		}));
		return coinResult;
	};
}
var CoinWithBalanceData = object({
	type: string(),
	balance: bigint()
});
async function resolveCoinBalance(transactionData, buildOptions, next) {
	const coinTypes = /* @__PURE__ */ new Set();
	const totalByType = /* @__PURE__ */ new Map();
	if (!transactionData.sender) throw new Error("Sender must be set to resolve CoinWithBalance");
	for (const command of transactionData.commands) if (command.$kind === "$Intent" && command.$Intent.name === COIN_WITH_BALANCE) {
		const { type, balance } = parse(CoinWithBalanceData, command.$Intent.data);
		if (type !== "gas" && balance > 0n) coinTypes.add(type);
		totalByType.set(type, (totalByType.get(type) ?? 0n) + balance);
	}
	const usedIds = /* @__PURE__ */ new Set();
	for (const input of transactionData.inputs) {
		if (input.Object?.ImmOrOwnedObject) usedIds.add(input.Object.ImmOrOwnedObject.objectId);
		if (input.UnresolvedObject?.objectId) usedIds.add(input.UnresolvedObject.objectId);
	}
	const coinsByType = /* @__PURE__ */ new Map();
	const client = getSuiClient(buildOptions);
	await Promise.all([...coinTypes].map(async (coinType) => {
		coinsByType.set(coinType, await getCoinsOfType({
			coinType,
			balance: totalByType.get(coinType),
			client,
			owner: transactionData.sender,
			usedIds
		}));
	}));
	const mergedCoins = /* @__PURE__ */ new Map();
	mergedCoins.set("gas", {
		$kind: "GasCoin",
		GasCoin: true
	});
	for (const [index, transaction] of transactionData.commands.entries()) {
		if (transaction.$kind !== "$Intent" || transaction.$Intent.name !== COIN_WITH_BALANCE) continue;
		const { type, balance } = transaction.$Intent.data;
		if (balance === 0n && type !== "gas") {
			transactionData.replaceCommand(index, Commands.MoveCall({
				target: "0x2::coin::zero",
				typeArguments: [type]
			}));
			continue;
		}
		const commands = [];
		if (!mergedCoins.has(type)) {
			const [first, ...rest] = coinsByType.get(type).map((coin) => transactionData.addInput("object", Inputs.ObjectRef({
				objectId: coin.coinObjectId,
				digest: coin.digest,
				version: coin.version
			})));
			if (rest.length > 0) commands.push(Commands.MergeCoins(first, rest));
			mergedCoins.set(type, first);
		}
		commands.push(Commands.SplitCoins(mergedCoins.get(type), [transactionData.addInput("pure", Inputs.Pure(suiBcs.u64().serialize(balance)))]));
		transactionData.replaceCommand(index, commands);
		transactionData.mapArguments((arg) => {
			if (arg.$kind === "Result" && arg.Result === index) return {
				$kind: "NestedResult",
				NestedResult: [index + commands.length - 1, 0]
			};
			return arg;
		});
	}
	return next();
}
async function getCoinsOfType({ coinType, balance, client, owner, usedIds }) {
	let remainingBalance = balance;
	const coins = [];
	return loadMoreCoins();
	async function loadMoreCoins(cursor = null) {
		const { data, hasNextPage, nextCursor } = await client.getCoins({
			owner,
			coinType,
			cursor
		});
		const sortedCoins = data.sort((a, b) => Number(BigInt(b.balance) - BigInt(a.balance)));
		for (const coin of sortedCoins) {
			if (usedIds.has(coin.coinObjectId)) continue;
			const coinBalance = BigInt(coin.balance);
			coins.push(coin);
			remainingBalance -= coinBalance;
			if (remainingBalance <= 0) return coins;
		}
		if (hasNextPage) return loadMoreCoins(nextCursor);
		throw new Error(`Not enough coins of type ${coinType} to satisfy requested balance`);
	}
}
function getSuiClient(options) {
	const client = getClient(options);
	if (!client.jsonRpc) throw new Error(`CoinWithBalance intent currently only works with SuiClient`);
	return client;
}

//#endregion
//#region node_modules/.pnpm/@mysten+sui@1.45.2_typescript@5.9.3/node_modules/@mysten/sui/dist/esm/transactions/Arguments.js
var Arguments = {
	pure: createPure((value) => (tx) => tx.pure(value)),
	object: createObjectMethods((value) => (tx) => tx.object(value)),
	sharedObjectRef: (...args) => (tx) => tx.sharedObjectRef(...args),
	objectRef: (...args) => (tx) => tx.objectRef(...args),
	receivingRef: (...args) => (tx) => tx.receivingRef(...args)
};

//#endregion
export { AsyncCache as a, SerialTransactionExecutor as i, coinWithBalance as n, ObjectCache as o, ParallelTransactionExecutor as r, promiseWithResolvers as s, Arguments as t };
//# sourceMappingURL=transactions-xpJqUSDW.js.map