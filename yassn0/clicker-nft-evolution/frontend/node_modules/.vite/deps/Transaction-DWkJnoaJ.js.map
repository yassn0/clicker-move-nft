{"version":3,"file":"Transaction-DWkJnoaJ.js","names":["isBytes","abytes","anumber","padding","alphabet","hasHexBuiltin","base64String","chunk","array","cacheMap","vector","bigint","__typeError","__accessCheck","__privateGet","__privateAdd","__privateSet","_BcsType","hex","toBytes","variant","array","NAME_SEPARATOR","hex","array","isLE","_32n","u64.add3L","u64.add3H","u64.rotr32H","u64.rotr32L","u64.add","u64.rotrSH","u64.rotrSL","u64.rotrBH","u64.rotrBL","u64.fromBig","blake2b","b2b","CallArg","StructTag","TypeTag","Argument","ProgrammableMoveCall","Command","TransactionExpiration","GasData","bcs","option","$Intent","NormalizedCallArg","TransactionExpiration","TransactionExpiration","object","getClient","bcs","object","bcs","bcs","__typeError","__accessCheck","__privateGet","__privateAdd","__privateSet","_cache","_ClientCache","__typeError","__accessCheck","__privateGet","__privateAdd","__privateSet","__privateMethod","_Transaction"],"sources":["../../.pnpm/@scure+base@1.2.6/node_modules/@scure/base/lib/esm/index.js","../../.pnpm/@mysten+utils@0.2.0/node_modules/@mysten/utils/dist/esm/b58.js","../../.pnpm/@mysten+utils@0.2.0/node_modules/@mysten/utils/dist/esm/b64.js","../../.pnpm/@mysten+utils@0.2.0/node_modules/@mysten/utils/dist/esm/hex.js","../../.pnpm/@mysten+utils@0.2.0/node_modules/@mysten/utils/dist/esm/chunk.js","../../.pnpm/@mysten+utils@0.2.0/node_modules/@mysten/utils/dist/esm/dataloader.js","../../.pnpm/@mysten+bcs@1.9.2/node_modules/@mysten/bcs/dist/esm/uleb.js","../../.pnpm/@mysten+bcs@1.9.2/node_modules/@mysten/bcs/dist/esm/reader.js","../../.pnpm/@mysten+bcs@1.9.2/node_modules/@mysten/bcs/dist/esm/utils.js","../../.pnpm/@mysten+bcs@1.9.2/node_modules/@mysten/bcs/dist/esm/writer.js","../../.pnpm/@mysten+bcs@1.9.2/node_modules/@mysten/bcs/dist/esm/bcs-type.js","../../.pnpm/@mysten+bcs@1.9.2/node_modules/@mysten/bcs/dist/esm/bcs.js","../../.pnpm/@mysten+sui@1.45.2_typescript@5.9.3/node_modules/@mysten/sui/dist/esm/utils/suins.js","../../.pnpm/@mysten+sui@1.45.2_typescript@5.9.3/node_modules/@mysten/sui/dist/esm/utils/move-registry.js","../../.pnpm/@mysten+sui@1.45.2_typescript@5.9.3/node_modules/@mysten/sui/dist/esm/utils/sui-types.js","../../.pnpm/@mysten+sui@1.45.2_typescript@5.9.3/node_modules/@mysten/sui/dist/esm/utils/constants.js","../../.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/esm/crypto.js","../../.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/esm/utils.js","../../.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/esm/_blake.js","../../.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/esm/_md.js","../../.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/esm/_u64.js","../../.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/esm/blake2.js","../../.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/esm/blake2b.js","../../.pnpm/@mysten+sui@1.45.2_typescript@5.9.3/node_modules/@mysten/sui/dist/esm/bcs/type-tag-serializer.js","../../.pnpm/@mysten+sui@1.45.2_typescript@5.9.3/node_modules/@mysten/sui/dist/esm/bcs/bcs.js","../../.pnpm/@mysten+sui@1.45.2_typescript@5.9.3/node_modules/@mysten/sui/dist/esm/bcs/effects.js","../../.pnpm/@mysten+sui@1.45.2_typescript@5.9.3/node_modules/@mysten/sui/dist/esm/bcs/pure.js","../../.pnpm/@mysten+sui@1.45.2_typescript@5.9.3/node_modules/@mysten/sui/dist/esm/bcs/index.js","../../.pnpm/@mysten+sui@1.45.2_typescript@5.9.3/node_modules/@mysten/sui/dist/esm/transactions/serializer.js","../../.pnpm/@mysten+sui@1.45.2_typescript@5.9.3/node_modules/@mysten/sui/dist/esm/transactions/Inputs.js","../../.pnpm/valibot@1.2.0_typescript@5.9.3/node_modules/valibot/dist/index.mjs","../../.pnpm/@mysten+sui@1.45.2_typescript@5.9.3/node_modules/@mysten/sui/dist/esm/transactions/data/internal.js","../../.pnpm/@mysten+sui@1.45.2_typescript@5.9.3/node_modules/@mysten/sui/dist/esm/transactions/Commands.js","../../.pnpm/@mysten+sui@1.45.2_typescript@5.9.3/node_modules/@mysten/sui/dist/esm/transactions/data/v1.js","../../.pnpm/@mysten+sui@1.45.2_typescript@5.9.3/node_modules/@mysten/sui/dist/esm/transactions/data/v2.js","../../.pnpm/@mysten+sui@1.45.2_typescript@5.9.3/node_modules/@mysten/sui/dist/esm/jsonRpc/json-rpc-resolver.js","../../.pnpm/@mysten+sui@1.45.2_typescript@5.9.3/node_modules/@mysten/sui/dist/esm/transactions/resolve.js","../../.pnpm/@mysten+sui@1.45.2_typescript@5.9.3/node_modules/@mysten/sui/dist/esm/transactions/object.js","../../.pnpm/@mysten+sui@1.45.2_typescript@5.9.3/node_modules/@mysten/sui/dist/esm/transactions/pure.js","../../.pnpm/@mysten+sui@1.45.2_typescript@5.9.3/node_modules/@mysten/sui/dist/esm/transactions/hash.js","../../.pnpm/@mysten+sui@1.45.2_typescript@5.9.3/node_modules/@mysten/sui/dist/esm/transactions/utils.js","../../.pnpm/@mysten+sui@1.45.2_typescript@5.9.3/node_modules/@mysten/sui/dist/esm/transactions/TransactionData.js","../../.pnpm/@mysten+sui@1.45.2_typescript@5.9.3/node_modules/@mysten/sui/dist/esm/experimental/cache.js","../../.pnpm/@mysten+sui@1.45.2_typescript@5.9.3/node_modules/@mysten/sui/dist/esm/version.js","../../.pnpm/@mysten+sui@1.45.2_typescript@5.9.3/node_modules/@mysten/sui/dist/esm/experimental/mvr.js","../../.pnpm/@mysten+sui@1.45.2_typescript@5.9.3/node_modules/@mysten/sui/dist/esm/transactions/plugins/NamedPackagesPlugin.js","../../.pnpm/@mysten+sui@1.45.2_typescript@5.9.3/node_modules/@mysten/sui/dist/esm/transactions/Transaction.js"],"sourcesContent":["/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nfunction isBytes(a) {\n    return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\n/** Asserts something is Uint8Array. */\nfunction abytes(b, ...lengths) {\n    if (!isBytes(b))\n        throw new Error('Uint8Array expected');\n    if (lengths.length > 0 && !lengths.includes(b.length))\n        throw new Error('Uint8Array expected of length ' + lengths + ', got length=' + b.length);\n}\nfunction isArrayOf(isString, arr) {\n    if (!Array.isArray(arr))\n        return false;\n    if (arr.length === 0)\n        return true;\n    if (isString) {\n        return arr.every((item) => typeof item === 'string');\n    }\n    else {\n        return arr.every((item) => Number.isSafeInteger(item));\n    }\n}\n// no abytes: seems to have 10% slowdown. Why?!\nfunction afn(input) {\n    if (typeof input !== 'function')\n        throw new Error('function expected');\n    return true;\n}\nfunction astr(label, input) {\n    if (typeof input !== 'string')\n        throw new Error(`${label}: string expected`);\n    return true;\n}\nfunction anumber(n) {\n    if (!Number.isSafeInteger(n))\n        throw new Error(`invalid integer: ${n}`);\n}\nfunction aArr(input) {\n    if (!Array.isArray(input))\n        throw new Error('array expected');\n}\nfunction astrArr(label, input) {\n    if (!isArrayOf(true, input))\n        throw new Error(`${label}: array of strings expected`);\n}\nfunction anumArr(label, input) {\n    if (!isArrayOf(false, input))\n        throw new Error(`${label}: array of numbers expected`);\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction chain(...args) {\n    const id = (a) => a;\n    // Wrap call in closure so JIT can inline calls\n    const wrap = (a, b) => (c) => a(b(c));\n    // Construct chain of args[-1].encode(args[-2].encode([...]))\n    const encode = args.map((x) => x.encode).reduceRight(wrap, id);\n    // Construct chain of args[0].decode(args[1].decode(...))\n    const decode = args.map((x) => x.decode).reduce(wrap, id);\n    return { encode, decode };\n}\n/**\n * Encodes integer radix representation to array of strings using alphabet and back.\n * Could also be array of strings.\n * @__NO_SIDE_EFFECTS__\n */\nfunction alphabet(letters) {\n    // mapping 1 to \"b\"\n    const lettersA = typeof letters === 'string' ? letters.split('') : letters;\n    const len = lettersA.length;\n    astrArr('alphabet', lettersA);\n    // mapping \"b\" to 1\n    const indexes = new Map(lettersA.map((l, i) => [l, i]));\n    return {\n        encode: (digits) => {\n            aArr(digits);\n            return digits.map((i) => {\n                if (!Number.isSafeInteger(i) || i < 0 || i >= len)\n                    throw new Error(`alphabet.encode: digit index outside alphabet \"${i}\". Allowed: ${letters}`);\n                return lettersA[i];\n            });\n        },\n        decode: (input) => {\n            aArr(input);\n            return input.map((letter) => {\n                astr('alphabet.decode', letter);\n                const i = indexes.get(letter);\n                if (i === undefined)\n                    throw new Error(`Unknown letter: \"${letter}\". Allowed: ${letters}`);\n                return i;\n            });\n        },\n    };\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction join(separator = '') {\n    astr('join', separator);\n    return {\n        encode: (from) => {\n            astrArr('join.decode', from);\n            return from.join(separator);\n        },\n        decode: (to) => {\n            astr('join.decode', to);\n            return to.split(separator);\n        },\n    };\n}\n/**\n * Pad strings array so it has integer number of bits\n * @__NO_SIDE_EFFECTS__\n */\nfunction padding(bits, chr = '=') {\n    anumber(bits);\n    astr('padding', chr);\n    return {\n        encode(data) {\n            astrArr('padding.encode', data);\n            while ((data.length * bits) % 8)\n                data.push(chr);\n            return data;\n        },\n        decode(input) {\n            astrArr('padding.decode', input);\n            let end = input.length;\n            if ((end * bits) % 8)\n                throw new Error('padding: invalid, string should have whole number of bytes');\n            for (; end > 0 && input[end - 1] === chr; end--) {\n                const last = end - 1;\n                const byte = last * bits;\n                if (byte % 8 === 0)\n                    throw new Error('padding: invalid, string has too much padding');\n            }\n            return input.slice(0, end);\n        },\n    };\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction normalize(fn) {\n    afn(fn);\n    return { encode: (from) => from, decode: (to) => fn(to) };\n}\n/**\n * Slow: O(n^2) time complexity\n */\nfunction convertRadix(data, from, to) {\n    // base 1 is impossible\n    if (from < 2)\n        throw new Error(`convertRadix: invalid from=${from}, base cannot be less than 2`);\n    if (to < 2)\n        throw new Error(`convertRadix: invalid to=${to}, base cannot be less than 2`);\n    aArr(data);\n    if (!data.length)\n        return [];\n    let pos = 0;\n    const res = [];\n    const digits = Array.from(data, (d) => {\n        anumber(d);\n        if (d < 0 || d >= from)\n            throw new Error(`invalid integer: ${d}`);\n        return d;\n    });\n    const dlen = digits.length;\n    while (true) {\n        let carry = 0;\n        let done = true;\n        for (let i = pos; i < dlen; i++) {\n            const digit = digits[i];\n            const fromCarry = from * carry;\n            const digitBase = fromCarry + digit;\n            if (!Number.isSafeInteger(digitBase) ||\n                fromCarry / from !== carry ||\n                digitBase - digit !== fromCarry) {\n                throw new Error('convertRadix: carry overflow');\n            }\n            const div = digitBase / to;\n            carry = digitBase % to;\n            const rounded = Math.floor(div);\n            digits[i] = rounded;\n            if (!Number.isSafeInteger(rounded) || rounded * to + carry !== digitBase)\n                throw new Error('convertRadix: carry overflow');\n            if (!done)\n                continue;\n            else if (!rounded)\n                pos = i;\n            else\n                done = false;\n        }\n        res.push(carry);\n        if (done)\n            break;\n    }\n    for (let i = 0; i < data.length - 1 && data[i] === 0; i++)\n        res.push(0);\n    return res.reverse();\n}\nconst gcd = (a, b) => (b === 0 ? a : gcd(b, a % b));\nconst radix2carry = /* @__NO_SIDE_EFFECTS__ */ (from, to) => from + (to - gcd(from, to));\nconst powers = /* @__PURE__ */ (() => {\n    let res = [];\n    for (let i = 0; i < 40; i++)\n        res.push(2 ** i);\n    return res;\n})();\n/**\n * Implemented with numbers, because BigInt is 5x slower\n */\nfunction convertRadix2(data, from, to, padding) {\n    aArr(data);\n    if (from <= 0 || from > 32)\n        throw new Error(`convertRadix2: wrong from=${from}`);\n    if (to <= 0 || to > 32)\n        throw new Error(`convertRadix2: wrong to=${to}`);\n    if (radix2carry(from, to) > 32) {\n        throw new Error(`convertRadix2: carry overflow from=${from} to=${to} carryBits=${radix2carry(from, to)}`);\n    }\n    let carry = 0;\n    let pos = 0; // bitwise position in current element\n    const max = powers[from];\n    const mask = powers[to] - 1;\n    const res = [];\n    for (const n of data) {\n        anumber(n);\n        if (n >= max)\n            throw new Error(`convertRadix2: invalid data word=${n} from=${from}`);\n        carry = (carry << from) | n;\n        if (pos + from > 32)\n            throw new Error(`convertRadix2: carry overflow pos=${pos} from=${from}`);\n        pos += from;\n        for (; pos >= to; pos -= to)\n            res.push(((carry >> (pos - to)) & mask) >>> 0);\n        const pow = powers[pos];\n        if (pow === undefined)\n            throw new Error('invalid carry');\n        carry &= pow - 1; // clean carry, otherwise it will cause overflow\n    }\n    carry = (carry << (to - pos)) & mask;\n    if (!padding && pos >= from)\n        throw new Error('Excess padding');\n    if (!padding && carry > 0)\n        throw new Error(`Non-zero padding: ${carry}`);\n    if (padding && pos > 0)\n        res.push(carry >>> 0);\n    return res;\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction radix(num) {\n    anumber(num);\n    const _256 = 2 ** 8;\n    return {\n        encode: (bytes) => {\n            if (!isBytes(bytes))\n                throw new Error('radix.encode input should be Uint8Array');\n            return convertRadix(Array.from(bytes), _256, num);\n        },\n        decode: (digits) => {\n            anumArr('radix.decode', digits);\n            return Uint8Array.from(convertRadix(digits, num, _256));\n        },\n    };\n}\n/**\n * If both bases are power of same number (like `2**8 <-> 2**64`),\n * there is a linear algorithm. For now we have implementation for power-of-two bases only.\n * @__NO_SIDE_EFFECTS__\n */\nfunction radix2(bits, revPadding = false) {\n    anumber(bits);\n    if (bits <= 0 || bits > 32)\n        throw new Error('radix2: bits should be in (0..32]');\n    if (radix2carry(8, bits) > 32 || radix2carry(bits, 8) > 32)\n        throw new Error('radix2: carry overflow');\n    return {\n        encode: (bytes) => {\n            if (!isBytes(bytes))\n                throw new Error('radix2.encode input should be Uint8Array');\n            return convertRadix2(Array.from(bytes), 8, bits, !revPadding);\n        },\n        decode: (digits) => {\n            anumArr('radix2.decode', digits);\n            return Uint8Array.from(convertRadix2(digits, bits, 8, revPadding));\n        },\n    };\n}\nfunction unsafeWrapper(fn) {\n    afn(fn);\n    return function (...args) {\n        try {\n            return fn.apply(null, args);\n        }\n        catch (e) { }\n    };\n}\nfunction checksum(len, fn) {\n    anumber(len);\n    afn(fn);\n    return {\n        encode(data) {\n            if (!isBytes(data))\n                throw new Error('checksum.encode: input should be Uint8Array');\n            const sum = fn(data).slice(0, len);\n            const res = new Uint8Array(data.length + len);\n            res.set(data);\n            res.set(sum, data.length);\n            return res;\n        },\n        decode(data) {\n            if (!isBytes(data))\n                throw new Error('checksum.decode: input should be Uint8Array');\n            const payload = data.slice(0, -len);\n            const oldChecksum = data.slice(-len);\n            const newChecksum = fn(payload).slice(0, len);\n            for (let i = 0; i < len; i++)\n                if (newChecksum[i] !== oldChecksum[i])\n                    throw new Error('Invalid checksum');\n            return payload;\n        },\n    };\n}\n// prettier-ignore\nexport const utils = {\n    alphabet, chain, checksum, convertRadix, convertRadix2, radix, radix2, join, padding,\n};\n// RFC 4648 aka RFC 3548\n// ---------------------\n/**\n * base16 encoding from RFC 4648.\n * @example\n * ```js\n * base16.encode(Uint8Array.from([0x12, 0xab]));\n * // => '12AB'\n * ```\n */\nexport const base16 = chain(radix2(4), alphabet('0123456789ABCDEF'), join(''));\n/**\n * base32 encoding from RFC 4648. Has padding.\n * Use `base32nopad` for unpadded version.\n * Also check out `base32hex`, `base32hexnopad`, `base32crockford`.\n * @example\n * ```js\n * base32.encode(Uint8Array.from([0x12, 0xab]));\n * // => 'CKVQ===='\n * base32.decode('CKVQ====');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\nexport const base32 = chain(radix2(5), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'), padding(5), join(''));\n/**\n * base32 encoding from RFC 4648. No padding.\n * Use `base32` for padded version.\n * Also check out `base32hex`, `base32hexnopad`, `base32crockford`.\n * @example\n * ```js\n * base32nopad.encode(Uint8Array.from([0x12, 0xab]));\n * // => 'CKVQ'\n * base32nopad.decode('CKVQ');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\nexport const base32nopad = chain(radix2(5), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'), join(''));\n/**\n * base32 encoding from RFC 4648. Padded. Compared to ordinary `base32`, slightly different alphabet.\n * Use `base32hexnopad` for unpadded version.\n * @example\n * ```js\n * base32hex.encode(Uint8Array.from([0x12, 0xab]));\n * // => '2ALG===='\n * base32hex.decode('2ALG====');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\nexport const base32hex = chain(radix2(5), alphabet('0123456789ABCDEFGHIJKLMNOPQRSTUV'), padding(5), join(''));\n/**\n * base32 encoding from RFC 4648. No padding. Compared to ordinary `base32`, slightly different alphabet.\n * Use `base32hex` for padded version.\n * @example\n * ```js\n * base32hexnopad.encode(Uint8Array.from([0x12, 0xab]));\n * // => '2ALG'\n * base32hexnopad.decode('2ALG');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\nexport const base32hexnopad = chain(radix2(5), alphabet('0123456789ABCDEFGHIJKLMNOPQRSTUV'), join(''));\n/**\n * base32 encoding from RFC 4648. Doug Crockford's version.\n * https://www.crockford.com/base32.html\n * @example\n * ```js\n * base32crockford.encode(Uint8Array.from([0x12, 0xab]));\n * // => '2ANG'\n * base32crockford.decode('2ANG');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\nexport const base32crockford = chain(radix2(5), alphabet('0123456789ABCDEFGHJKMNPQRSTVWXYZ'), join(''), normalize((s) => s.toUpperCase().replace(/O/g, '0').replace(/[IL]/g, '1')));\n// Built-in base64 conversion https://caniuse.com/mdn-javascript_builtins_uint8array_frombase64\n// prettier-ignore\nconst hasBase64Builtin = /* @__PURE__ */ (() => typeof Uint8Array.from([]).toBase64 === 'function' &&\n    typeof Uint8Array.fromBase64 === 'function')();\nconst decodeBase64Builtin = (s, isUrl) => {\n    astr('base64', s);\n    const re = isUrl ? /^[A-Za-z0-9=_-]+$/ : /^[A-Za-z0-9=+/]+$/;\n    const alphabet = isUrl ? 'base64url' : 'base64';\n    if (s.length > 0 && !re.test(s))\n        throw new Error('invalid base64');\n    return Uint8Array.fromBase64(s, { alphabet, lastChunkHandling: 'strict' });\n};\n/**\n * base64 from RFC 4648. Padded.\n * Use `base64nopad` for unpadded version.\n * Also check out `base64url`, `base64urlnopad`.\n * Falls back to built-in function, when available.\n * @example\n * ```js\n * base64.encode(Uint8Array.from([0x12, 0xab]));\n * // => 'Eqs='\n * base64.decode('Eqs=');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\n// prettier-ignore\nexport const base64 = hasBase64Builtin ? {\n    encode(b) { abytes(b); return b.toBase64(); },\n    decode(s) { return decodeBase64Builtin(s, false); },\n} : chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'), padding(6), join(''));\n/**\n * base64 from RFC 4648. No padding.\n * Use `base64` for padded version.\n * @example\n * ```js\n * base64nopad.encode(Uint8Array.from([0x12, 0xab]));\n * // => 'Eqs'\n * base64nopad.decode('Eqs');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\nexport const base64nopad = chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'), join(''));\n/**\n * base64 from RFC 4648, using URL-safe alphabet. Padded.\n * Use `base64urlnopad` for unpadded version.\n * Falls back to built-in function, when available.\n * @example\n * ```js\n * base64url.encode(Uint8Array.from([0x12, 0xab]));\n * // => 'Eqs='\n * base64url.decode('Eqs=');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\n// prettier-ignore\nexport const base64url = hasBase64Builtin ? {\n    encode(b) { abytes(b); return b.toBase64({ alphabet: 'base64url' }); },\n    decode(s) { return decodeBase64Builtin(s, true); },\n} : chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'), padding(6), join(''));\n/**\n * base64 from RFC 4648, using URL-safe alphabet. No padding.\n * Use `base64url` for padded version.\n * @example\n * ```js\n * base64urlnopad.encode(Uint8Array.from([0x12, 0xab]));\n * // => 'Eqs'\n * base64urlnopad.decode('Eqs');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\nexport const base64urlnopad = chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'), join(''));\n// base58 code\n// -----------\nconst genBase58 = /* @__NO_SIDE_EFFECTS__ */ (abc) => chain(radix(58), alphabet(abc), join(''));\n/**\n * base58: base64 without ambigous characters +, /, 0, O, I, l.\n * Quadratic (O(n^2)) - so, can't be used on large inputs.\n * @example\n * ```js\n * base58.decode('01abcdef');\n * // => '3UhJW'\n * ```\n */\nexport const base58 = genBase58('123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz');\n/**\n * base58: flickr version. Check out `base58`.\n */\nexport const base58flickr = genBase58('123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ');\n/**\n * base58: XRP version. Check out `base58`.\n */\nexport const base58xrp = genBase58('rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz');\n// Data len (index) -> encoded block len\nconst XMR_BLOCK_LEN = [0, 2, 3, 5, 6, 7, 9, 10, 11];\n/**\n * base58: XMR version. Check out `base58`.\n * Done in 8-byte blocks (which equals 11 chars in decoding). Last (non-full) block padded with '1' to size in XMR_BLOCK_LEN.\n * Block encoding significantly reduces quadratic complexity of base58.\n */\nexport const base58xmr = {\n    encode(data) {\n        let res = '';\n        for (let i = 0; i < data.length; i += 8) {\n            const block = data.subarray(i, i + 8);\n            res += base58.encode(block).padStart(XMR_BLOCK_LEN[block.length], '1');\n        }\n        return res;\n    },\n    decode(str) {\n        let res = [];\n        for (let i = 0; i < str.length; i += 11) {\n            const slice = str.slice(i, i + 11);\n            const blockLen = XMR_BLOCK_LEN.indexOf(slice.length);\n            const block = base58.decode(slice);\n            for (let j = 0; j < block.length - blockLen; j++) {\n                if (block[j] !== 0)\n                    throw new Error('base58xmr: wrong padding');\n            }\n            res = res.concat(Array.from(block.slice(block.length - blockLen)));\n        }\n        return Uint8Array.from(res);\n    },\n};\n/**\n * Method, which creates base58check encoder.\n * Requires function, calculating sha256.\n */\nexport const createBase58check = (sha256) => chain(checksum(4, (data) => sha256(sha256(data))), base58);\n/**\n * Use `createBase58check` instead.\n * @deprecated\n */\nexport const base58check = createBase58check;\nconst BECH_ALPHABET = chain(alphabet('qpzry9x8gf2tvdw0s3jn54khce6mua7l'), join(''));\nconst POLYMOD_GENERATORS = [0x3b6a57b2, 0x26508e6d, 0x1ea119fa, 0x3d4233dd, 0x2a1462b3];\nfunction bech32Polymod(pre) {\n    const b = pre >> 25;\n    let chk = (pre & 0x1ffffff) << 5;\n    for (let i = 0; i < POLYMOD_GENERATORS.length; i++) {\n        if (((b >> i) & 1) === 1)\n            chk ^= POLYMOD_GENERATORS[i];\n    }\n    return chk;\n}\nfunction bechChecksum(prefix, words, encodingConst = 1) {\n    const len = prefix.length;\n    let chk = 1;\n    for (let i = 0; i < len; i++) {\n        const c = prefix.charCodeAt(i);\n        if (c < 33 || c > 126)\n            throw new Error(`Invalid prefix (${prefix})`);\n        chk = bech32Polymod(chk) ^ (c >> 5);\n    }\n    chk = bech32Polymod(chk);\n    for (let i = 0; i < len; i++)\n        chk = bech32Polymod(chk) ^ (prefix.charCodeAt(i) & 0x1f);\n    for (let v of words)\n        chk = bech32Polymod(chk) ^ v;\n    for (let i = 0; i < 6; i++)\n        chk = bech32Polymod(chk);\n    chk ^= encodingConst;\n    return BECH_ALPHABET.encode(convertRadix2([chk % powers[30]], 30, 5, false));\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction genBech32(encoding) {\n    const ENCODING_CONST = encoding === 'bech32' ? 1 : 0x2bc830a3;\n    const _words = radix2(5);\n    const fromWords = _words.decode;\n    const toWords = _words.encode;\n    const fromWordsUnsafe = unsafeWrapper(fromWords);\n    function encode(prefix, words, limit = 90) {\n        astr('bech32.encode prefix', prefix);\n        if (isBytes(words))\n            words = Array.from(words);\n        anumArr('bech32.encode', words);\n        const plen = prefix.length;\n        if (plen === 0)\n            throw new TypeError(`Invalid prefix length ${plen}`);\n        const actualLength = plen + 7 + words.length;\n        if (limit !== false && actualLength > limit)\n            throw new TypeError(`Length ${actualLength} exceeds limit ${limit}`);\n        const lowered = prefix.toLowerCase();\n        const sum = bechChecksum(lowered, words, ENCODING_CONST);\n        return `${lowered}1${BECH_ALPHABET.encode(words)}${sum}`;\n    }\n    function decode(str, limit = 90) {\n        astr('bech32.decode input', str);\n        const slen = str.length;\n        if (slen < 8 || (limit !== false && slen > limit))\n            throw new TypeError(`invalid string length: ${slen} (${str}). Expected (8..${limit})`);\n        // don't allow mixed case\n        const lowered = str.toLowerCase();\n        if (str !== lowered && str !== str.toUpperCase())\n            throw new Error(`String must be lowercase or uppercase`);\n        const sepIndex = lowered.lastIndexOf('1');\n        if (sepIndex === 0 || sepIndex === -1)\n            throw new Error(`Letter \"1\" must be present between prefix and data only`);\n        const prefix = lowered.slice(0, sepIndex);\n        const data = lowered.slice(sepIndex + 1);\n        if (data.length < 6)\n            throw new Error('Data must be at least 6 characters long');\n        const words = BECH_ALPHABET.decode(data).slice(0, -6);\n        const sum = bechChecksum(prefix, words, ENCODING_CONST);\n        if (!data.endsWith(sum))\n            throw new Error(`Invalid checksum in ${str}: expected \"${sum}\"`);\n        return { prefix, words };\n    }\n    const decodeUnsafe = unsafeWrapper(decode);\n    function decodeToBytes(str) {\n        const { prefix, words } = decode(str, false);\n        return { prefix, words, bytes: fromWords(words) };\n    }\n    function encodeFromBytes(prefix, bytes) {\n        return encode(prefix, toWords(bytes));\n    }\n    return {\n        encode,\n        decode,\n        encodeFromBytes,\n        decodeToBytes,\n        decodeUnsafe,\n        fromWords,\n        fromWordsUnsafe,\n        toWords,\n    };\n}\n/**\n * bech32 from BIP 173. Operates on words.\n * For high-level, check out scure-btc-signer:\n * https://github.com/paulmillr/scure-btc-signer.\n */\nexport const bech32 = genBech32('bech32');\n/**\n * bech32m from BIP 350. Operates on words.\n * It was to mitigate `bech32` weaknesses.\n * For high-level, check out scure-btc-signer:\n * https://github.com/paulmillr/scure-btc-signer.\n */\nexport const bech32m = genBech32('bech32m');\n/**\n * UTF-8-to-byte decoder. Uses built-in TextDecoder / TextEncoder.\n * @example\n * ```js\n * const b = utf8.decode(\"hey\"); // => new Uint8Array([ 104, 101, 121 ])\n * const str = utf8.encode(b); // \"hey\"\n * ```\n */\nexport const utf8 = {\n    encode: (data) => new TextDecoder().decode(data),\n    decode: (str) => new TextEncoder().encode(str),\n};\n// Built-in hex conversion https://caniuse.com/mdn-javascript_builtins_uint8array_fromhex\n// prettier-ignore\nconst hasHexBuiltin = /* @__PURE__ */ (() => typeof Uint8Array.from([]).toHex === 'function' &&\n    typeof Uint8Array.fromHex === 'function')();\n// prettier-ignore\nconst hexBuiltin = {\n    encode(data) { abytes(data); return data.toHex(); },\n    decode(s) { astr('hex', s); return Uint8Array.fromHex(s); },\n};\n/**\n * hex string decoder. Uses built-in function, when available.\n * @example\n * ```js\n * const b = hex.decode(\"0102ff\"); // => new Uint8Array([ 1, 2, 255 ])\n * const str = hex.encode(b); // \"0102ff\"\n * ```\n */\nexport const hex = hasHexBuiltin\n    ? hexBuiltin\n    : chain(radix2(4), alphabet('0123456789abcdef'), join(''), normalize((s) => {\n        if (typeof s !== 'string' || s.length % 2 !== 0)\n            throw new TypeError(`hex.decode: expected string, got ${typeof s} with length ${s.length}`);\n        return s.toLowerCase();\n    }));\n// prettier-ignore\nconst CODERS = {\n    utf8, hex, base16, base32, base64, base64url, base58, base58xmr\n};\nconst coderTypeError = 'Invalid encoding type. Available types: utf8, hex, base16, base32, base64, base64url, base58, base58xmr';\n/** @deprecated */\nexport const bytesToString = (type, bytes) => {\n    if (typeof type !== 'string' || !CODERS.hasOwnProperty(type))\n        throw new TypeError(coderTypeError);\n    if (!isBytes(bytes))\n        throw new TypeError('bytesToString() expects Uint8Array');\n    return CODERS[type].encode(bytes);\n};\n/** @deprecated */\nexport const str = bytesToString; // as in python, but for bytes only\n/** @deprecated */\nexport const stringToBytes = (type, str) => {\n    if (!CODERS.hasOwnProperty(type))\n        throw new TypeError(coderTypeError);\n    if (typeof str !== 'string')\n        throw new TypeError('stringToBytes() expects string');\n    return CODERS[type].decode(str);\n};\n/** @deprecated */\nexport const bytes = stringToBytes;\n//# sourceMappingURL=index.js.map","import { base58 } from \"@scure/base\";\nconst toBase58 = (buffer) => base58.encode(buffer);\nconst fromBase58 = (str) => base58.decode(str);\nexport {\n  fromBase58,\n  toBase58\n};\n//# sourceMappingURL=b58.js.map\n","function fromBase64(base64String) {\n  return Uint8Array.from(atob(base64String), (char) => char.charCodeAt(0));\n}\nconst CHUNK_SIZE = 8192;\nfunction toBase64(bytes) {\n  if (bytes.length < CHUNK_SIZE) {\n    return btoa(String.fromCharCode(...bytes));\n  }\n  let output = \"\";\n  for (var i = 0; i < bytes.length; i += CHUNK_SIZE) {\n    const chunk = bytes.slice(i, i + CHUNK_SIZE);\n    output += String.fromCharCode(...chunk);\n  }\n  return btoa(output);\n}\nexport {\n  fromBase64,\n  toBase64\n};\n//# sourceMappingURL=b64.js.map\n","function fromHex(hexStr) {\n  const normalized = hexStr.startsWith(\"0x\") ? hexStr.slice(2) : hexStr;\n  const padded = normalized.length % 2 === 0 ? normalized : `0${normalized}`;\n  const intArr = padded.match(/[0-9a-fA-F]{2}/g)?.map((byte) => parseInt(byte, 16)) ?? [];\n  if (intArr.length !== padded.length / 2) {\n    throw new Error(`Invalid hex string ${hexStr}`);\n  }\n  return Uint8Array.from(intArr);\n}\nfunction toHex(bytes) {\n  return bytes.reduce((str, byte) => str + byte.toString(16).padStart(2, \"0\"), \"\");\n}\nexport {\n  fromHex,\n  toHex\n};\n//# sourceMappingURL=hex.js.map\n","function chunk(array, size) {\n  return Array.from({ length: Math.ceil(array.length / size) }, (_, i) => {\n    return array.slice(i * size, (i + 1) * size);\n  });\n}\nexport {\n  chunk\n};\n//# sourceMappingURL=chunk.js.map\n","class DataLoader {\n  constructor(batchLoadFn, options) {\n    if (typeof batchLoadFn !== \"function\") {\n      throw new TypeError(\n        `DataLoader must be constructed with a function which accepts Array<key> and returns Promise<Array<value>>, but got: ${batchLoadFn}.`\n      );\n    }\n    this._batchLoadFn = batchLoadFn;\n    this._maxBatchSize = getValidMaxBatchSize(options);\n    this._batchScheduleFn = getValidBatchScheduleFn(options);\n    this._cacheKeyFn = getValidCacheKeyFn(options);\n    this._cacheMap = getValidCacheMap(options);\n    this._batch = null;\n    this.name = getValidName(options);\n  }\n  /**\n   * Loads a key, returning a `Promise` for the value represented by that key.\n   */\n  load(key) {\n    if (key === null || key === void 0) {\n      throw new TypeError(\n        `The loader.load() function must be called with a value, but got: ${String(key)}.`\n      );\n    }\n    const batch = getCurrentBatch(this);\n    const cacheMap = this._cacheMap;\n    let cacheKey;\n    if (cacheMap) {\n      cacheKey = this._cacheKeyFn(key);\n      const cachedPromise = cacheMap.get(cacheKey);\n      if (cachedPromise) {\n        const cacheHits = batch.cacheHits || (batch.cacheHits = []);\n        return new Promise((resolve) => {\n          cacheHits.push(() => {\n            resolve(cachedPromise);\n          });\n        });\n      }\n    }\n    batch.keys.push(key);\n    const promise = new Promise((resolve, reject) => {\n      batch.callbacks.push({ resolve, reject });\n    });\n    if (cacheMap) {\n      cacheMap.set(cacheKey, promise);\n    }\n    return promise;\n  }\n  /**\n   * Loads multiple keys, promising an array of values:\n   *\n   *     var [ a, b ] = await myLoader.loadMany([ 'a', 'b' ]);\n   *\n   * This is similar to the more verbose:\n   *\n   *     var [ a, b ] = await Promise.all([\n   *       myLoader.load('a'),\n   *       myLoader.load('b')\n   *     ]);\n   *\n   * However it is different in the case where any load fails. Where\n   * Promise.all() would reject, loadMany() always resolves, however each result\n   * is either a value or an Error instance.\n   *\n   *     var [ a, b, c ] = await myLoader.loadMany([ 'a', 'b', 'badkey' ]);\n   *     // c instanceof Error\n   *\n   */\n  loadMany(keys) {\n    if (!isArrayLike(keys)) {\n      throw new TypeError(\n        `The loader.loadMany() function must be called with Array<key>, but got: ${keys}.`\n      );\n    }\n    const loadPromises = [];\n    for (let i = 0; i < keys.length; i++) {\n      loadPromises.push(this.load(keys[i]).catch((error) => error));\n    }\n    return Promise.all(loadPromises);\n  }\n  /**\n   * Clears the value at `key` from the cache, if it exists. Returns itself for\n   * method chaining.\n   */\n  clear(key) {\n    const cacheMap = this._cacheMap;\n    if (cacheMap) {\n      const cacheKey = this._cacheKeyFn(key);\n      cacheMap.delete(cacheKey);\n    }\n    return this;\n  }\n  /**\n   * Clears the entire cache. To be used when some event results in unknown\n   * invalidations across this particular `DataLoader`. Returns itself for\n   * method chaining.\n   */\n  clearAll() {\n    const cacheMap = this._cacheMap;\n    if (cacheMap) {\n      cacheMap.clear();\n    }\n    return this;\n  }\n  /**\n   * Adds the provided key and value to the cache. If the key already\n   * exists, no change is made. Returns itself for method chaining.\n   *\n   * To prime the cache with an error at a key, provide an Error instance.\n   */\n  prime(key, value) {\n    const cacheMap = this._cacheMap;\n    if (cacheMap) {\n      const cacheKey = this._cacheKeyFn(key);\n      if (cacheMap.get(cacheKey) === void 0) {\n        let promise;\n        if (value instanceof Error) {\n          promise = Promise.reject(value);\n          promise.catch(() => {\n          });\n        } else {\n          promise = Promise.resolve(value);\n        }\n        cacheMap.set(cacheKey, promise);\n      }\n    }\n    return this;\n  }\n}\nconst enqueuePostPromiseJob = (\n  /** @ts-ignore */\n  typeof process === \"object\" && typeof process.nextTick === \"function\" ? function(fn) {\n    if (!resolvedPromise) {\n      resolvedPromise = Promise.resolve();\n    }\n    resolvedPromise.then(() => {\n      process.nextTick(fn);\n    });\n  } : (\n    // @ts-ignore\n    typeof setImmediate === \"function\" ? function(fn) {\n      setImmediate(fn);\n    } : function(fn) {\n      setTimeout(fn);\n    }\n  )\n);\nlet resolvedPromise;\nfunction getCurrentBatch(loader) {\n  const existingBatch = loader._batch;\n  if (existingBatch !== null && !existingBatch.hasDispatched && existingBatch.keys.length < loader._maxBatchSize) {\n    return existingBatch;\n  }\n  const newBatch = { hasDispatched: false, keys: [], callbacks: [] };\n  loader._batch = newBatch;\n  loader._batchScheduleFn(() => {\n    dispatchBatch(loader, newBatch);\n  });\n  return newBatch;\n}\nfunction dispatchBatch(loader, batch) {\n  batch.hasDispatched = true;\n  if (batch.keys.length === 0) {\n    resolveCacheHits(batch);\n    return;\n  }\n  let batchPromise;\n  try {\n    batchPromise = loader._batchLoadFn(batch.keys);\n  } catch (e) {\n    return failedDispatch(\n      loader,\n      batch,\n      new TypeError(\n        `DataLoader must be constructed with a function which accepts Array<key> and returns Promise<Array<value>>, but the function errored synchronously: ${String(e)}.`\n      )\n    );\n  }\n  if (!batchPromise || typeof batchPromise.then !== \"function\") {\n    return failedDispatch(\n      loader,\n      batch,\n      new TypeError(\n        `DataLoader must be constructed with a function which accepts Array<key> and returns Promise<Array<value>>, but the function did not return a Promise: ${String(batchPromise)}.`\n      )\n    );\n  }\n  Promise.resolve(batchPromise).then((values) => {\n    if (!isArrayLike(values)) {\n      throw new TypeError(\n        `DataLoader must be constructed with a function which accepts Array<key> and returns Promise<Array<value>>, but the function did not return a Promise of an Array: ${String(values)}.`\n      );\n    }\n    if (values.length !== batch.keys.length) {\n      throw new TypeError(\n        `DataLoader must be constructed with a function which accepts Array<key> and returns Promise<Array<value>>, but the function did not return a Promise of an Array of the same length as the Array of keys.\n\nKeys:\n${String(batch.keys)}\n\nValues:\n${String(values)}`\n      );\n    }\n    resolveCacheHits(batch);\n    for (let i = 0; i < batch.callbacks.length; i++) {\n      const value = values[i];\n      if (value instanceof Error) {\n        batch.callbacks[i].reject(value);\n      } else {\n        batch.callbacks[i].resolve(value);\n      }\n    }\n  }).catch((error) => {\n    failedDispatch(loader, batch, error);\n  });\n}\nfunction failedDispatch(loader, batch, error) {\n  resolveCacheHits(batch);\n  for (let i = 0; i < batch.keys.length; i++) {\n    loader.clear(batch.keys[i]);\n    batch.callbacks[i].reject(error);\n  }\n}\nfunction resolveCacheHits(batch) {\n  if (batch.cacheHits) {\n    for (let i = 0; i < batch.cacheHits.length; i++) {\n      batch.cacheHits[i]();\n    }\n  }\n}\nfunction getValidMaxBatchSize(options) {\n  const shouldBatch = !options || options.batch !== false;\n  if (!shouldBatch) {\n    return 1;\n  }\n  const maxBatchSize = options && options.maxBatchSize;\n  if (maxBatchSize === void 0) {\n    return Infinity;\n  }\n  if (typeof maxBatchSize !== \"number\" || maxBatchSize < 1) {\n    throw new TypeError(`maxBatchSize must be a positive number: ${maxBatchSize}`);\n  }\n  return maxBatchSize;\n}\nfunction getValidBatchScheduleFn(options) {\n  const batchScheduleFn = options && options.batchScheduleFn;\n  if (batchScheduleFn === void 0) {\n    return enqueuePostPromiseJob;\n  }\n  if (typeof batchScheduleFn !== \"function\") {\n    throw new TypeError(`batchScheduleFn must be a function: ${batchScheduleFn}`);\n  }\n  return batchScheduleFn;\n}\nfunction getValidCacheKeyFn(options) {\n  const cacheKeyFn = options && options.cacheKeyFn;\n  if (cacheKeyFn === void 0) {\n    return (key) => key;\n  }\n  if (typeof cacheKeyFn !== \"function\") {\n    throw new TypeError(`cacheKeyFn must be a function: ${cacheKeyFn}`);\n  }\n  return cacheKeyFn;\n}\nfunction getValidCacheMap(options) {\n  const shouldCache = !options || options.cache !== false;\n  if (!shouldCache) {\n    return null;\n  }\n  const cacheMap = options && options.cacheMap;\n  if (cacheMap === void 0) {\n    return /* @__PURE__ */ new Map();\n  }\n  if (cacheMap !== null) {\n    const cacheFunctions = [\"get\", \"set\", \"delete\", \"clear\"];\n    const missingFunctions = cacheFunctions.filter(\n      (fnName) => cacheMap && typeof cacheMap[fnName] !== \"function\"\n    );\n    if (missingFunctions.length !== 0) {\n      throw new TypeError(\"Custom cacheMap missing methods: \" + missingFunctions.join(\", \"));\n    }\n  }\n  return cacheMap;\n}\nfunction getValidName(options) {\n  if (options && options.name) {\n    return options.name;\n  }\n  return null;\n}\nfunction isArrayLike(x) {\n  return typeof x === \"object\" && x !== null && \"length\" in x && typeof x.length === \"number\" && (x.length === 0 || x.length > 0 && Object.prototype.hasOwnProperty.call(x, x.length - 1));\n}\nexport {\n  DataLoader\n};\n//# sourceMappingURL=dataloader.js.map\n","function ulebEncode(num) {\n  let bigNum = BigInt(num);\n  const arr = [];\n  let len = 0;\n  if (bigNum === 0n) {\n    return [0];\n  }\n  while (bigNum > 0) {\n    arr[len] = Number(bigNum & 0x7fn);\n    bigNum >>= 7n;\n    if (bigNum > 0n) {\n      arr[len] |= 128;\n    }\n    len += 1;\n  }\n  return arr;\n}\nfunction ulebDecode(arr) {\n  let total = 0n;\n  let shift = 0n;\n  let len = 0;\n  while (true) {\n    if (len >= arr.length) {\n      throw new Error(\"ULEB decode error: buffer overflow\");\n    }\n    const byte = arr[len];\n    len += 1;\n    total += BigInt(byte & 127) << shift;\n    if ((byte & 128) === 0) {\n      break;\n    }\n    shift += 7n;\n  }\n  if (total > BigInt(Number.MAX_SAFE_INTEGER)) {\n    throw new Error(\"ULEB decode error: value exceeds MAX_SAFE_INTEGER\");\n  }\n  return {\n    value: Number(total),\n    length: len\n  };\n}\nexport {\n  ulebDecode,\n  ulebEncode\n};\n//# sourceMappingURL=uleb.js.map\n","import { ulebDecode } from \"./uleb.js\";\nclass BcsReader {\n  /**\n   * @param {Uint8Array} data Data to use as a buffer.\n   */\n  constructor(data) {\n    this.bytePosition = 0;\n    this.dataView = new DataView(data.buffer, data.byteOffset, data.byteLength);\n  }\n  /**\n   * Shift current cursor position by `bytes`.\n   *\n   * @param {Number} bytes Number of bytes to\n   * @returns {this} Self for possible chaining.\n   */\n  shift(bytes) {\n    this.bytePosition += bytes;\n    return this;\n  }\n  /**\n   * Read U8 value from the buffer and shift cursor by 1.\n   * @returns\n   */\n  read8() {\n    const value = this.dataView.getUint8(this.bytePosition);\n    this.shift(1);\n    return value;\n  }\n  /**\n   * Read U16 value from the buffer and shift cursor by 2.\n   * @returns\n   */\n  read16() {\n    const value = this.dataView.getUint16(this.bytePosition, true);\n    this.shift(2);\n    return value;\n  }\n  /**\n   * Read U32 value from the buffer and shift cursor by 4.\n   * @returns\n   */\n  read32() {\n    const value = this.dataView.getUint32(this.bytePosition, true);\n    this.shift(4);\n    return value;\n  }\n  /**\n   * Read U64 value from the buffer and shift cursor by 8.\n   * @returns\n   */\n  read64() {\n    const value1 = this.read32();\n    const value2 = this.read32();\n    const result = value2.toString(16) + value1.toString(16).padStart(8, \"0\");\n    return BigInt(\"0x\" + result).toString(10);\n  }\n  /**\n   * Read U128 value from the buffer and shift cursor by 16.\n   */\n  read128() {\n    const value1 = BigInt(this.read64());\n    const value2 = BigInt(this.read64());\n    const result = value2.toString(16) + value1.toString(16).padStart(16, \"0\");\n    return BigInt(\"0x\" + result).toString(10);\n  }\n  /**\n   * Read U128 value from the buffer and shift cursor by 32.\n   * @returns\n   */\n  read256() {\n    const value1 = BigInt(this.read128());\n    const value2 = BigInt(this.read128());\n    const result = value2.toString(16) + value1.toString(16).padStart(32, \"0\");\n    return BigInt(\"0x\" + result).toString(10);\n  }\n  /**\n   * Read `num` number of bytes from the buffer and shift cursor by `num`.\n   * @param num Number of bytes to read.\n   */\n  readBytes(num) {\n    const start = this.bytePosition + this.dataView.byteOffset;\n    const value = new Uint8Array(this.dataView.buffer, start, num);\n    this.shift(num);\n    return value;\n  }\n  /**\n   * Read ULEB value - an integer of varying size. Used for enum indexes and\n   * vector lengths.\n   * @returns {Number} The ULEB value.\n   */\n  readULEB() {\n    const start = this.bytePosition + this.dataView.byteOffset;\n    const buffer = new Uint8Array(this.dataView.buffer, start);\n    const { value, length } = ulebDecode(buffer);\n    this.shift(length);\n    return value;\n  }\n  /**\n   * Read a BCS vector: read a length and then apply function `cb` X times\n   * where X is the length of the vector, defined as ULEB in BCS bytes.\n   * @param cb Callback to process elements of vector.\n   * @returns {Array<Any>} Array of the resulting values, returned by callback.\n   */\n  readVec(cb) {\n    const length = this.readULEB();\n    const result = [];\n    for (let i = 0; i < length; i++) {\n      result.push(cb(this, i, length));\n    }\n    return result;\n  }\n}\nexport {\n  BcsReader\n};\n//# sourceMappingURL=reader.js.map\n","import { fromBase58, fromBase64, fromHex, toBase58, toBase64, toHex } from \"@mysten/utils\";\nfunction encodeStr(data, encoding) {\n  switch (encoding) {\n    case \"base58\":\n      return toBase58(data);\n    case \"base64\":\n      return toBase64(data);\n    case \"hex\":\n      return toHex(data);\n    default:\n      throw new Error(\"Unsupported encoding, supported values are: base64, hex\");\n  }\n}\nfunction decodeStr(data, encoding) {\n  switch (encoding) {\n    case \"base58\":\n      return fromBase58(data);\n    case \"base64\":\n      return fromBase64(data);\n    case \"hex\":\n      return fromHex(data);\n    default:\n      throw new Error(\"Unsupported encoding, supported values are: base64, hex\");\n  }\n}\nfunction splitGenericParameters(str, genericSeparators = [\"<\", \">\"]) {\n  const [left, right] = genericSeparators;\n  const tok = [];\n  let word = \"\";\n  let nestedAngleBrackets = 0;\n  for (let i = 0; i < str.length; i++) {\n    const char = str[i];\n    if (char === left) {\n      nestedAngleBrackets++;\n    }\n    if (char === right) {\n      nestedAngleBrackets--;\n    }\n    if (nestedAngleBrackets === 0 && char === \",\") {\n      tok.push(word.trim());\n      word = \"\";\n      continue;\n    }\n    word += char;\n  }\n  tok.push(word.trim());\n  return tok;\n}\nexport {\n  decodeStr,\n  encodeStr,\n  splitGenericParameters\n};\n//# sourceMappingURL=utils.js.map\n","import { ulebEncode } from \"./uleb.js\";\nimport { encodeStr } from \"./utils.js\";\nclass BcsWriter {\n  constructor({\n    initialSize = 1024,\n    maxSize = Infinity,\n    allocateSize = 1024\n  } = {}) {\n    this.bytePosition = 0;\n    this.size = initialSize;\n    this.maxSize = maxSize;\n    this.allocateSize = allocateSize;\n    this.dataView = new DataView(new ArrayBuffer(initialSize));\n  }\n  ensureSizeOrGrow(bytes) {\n    const requiredSize = this.bytePosition + bytes;\n    if (requiredSize > this.size) {\n      const nextSize = Math.min(\n        this.maxSize,\n        Math.max(this.size + requiredSize, this.size + this.allocateSize)\n      );\n      if (requiredSize > nextSize) {\n        throw new Error(\n          `Attempting to serialize to BCS, but buffer does not have enough size. Allocated size: ${this.size}, Max size: ${this.maxSize}, Required size: ${requiredSize}`\n        );\n      }\n      this.size = nextSize;\n      const nextBuffer = new ArrayBuffer(this.size);\n      new Uint8Array(nextBuffer).set(new Uint8Array(this.dataView.buffer));\n      this.dataView = new DataView(nextBuffer);\n    }\n  }\n  /**\n   * Shift current cursor position by `bytes`.\n   *\n   * @param {Number} bytes Number of bytes to\n   * @returns {this} Self for possible chaining.\n   */\n  shift(bytes) {\n    this.bytePosition += bytes;\n    return this;\n  }\n  /**\n   * Write a U8 value into a buffer and shift cursor position by 1.\n   * @param {Number} value Value to write.\n   * @returns {this}\n   */\n  write8(value) {\n    this.ensureSizeOrGrow(1);\n    this.dataView.setUint8(this.bytePosition, Number(value));\n    return this.shift(1);\n  }\n  /**\n   * Write a U8 value into a buffer and shift cursor position by 1.\n   * @param {Number} value Value to write.\n   * @returns {this}\n   */\n  writeBytes(bytes) {\n    this.ensureSizeOrGrow(bytes.length);\n    for (let i = 0; i < bytes.length; i++) {\n      this.dataView.setUint8(this.bytePosition + i, bytes[i]);\n    }\n    return this.shift(bytes.length);\n  }\n  /**\n   * Write a U16 value into a buffer and shift cursor position by 2.\n   * @param {Number} value Value to write.\n   * @returns {this}\n   */\n  write16(value) {\n    this.ensureSizeOrGrow(2);\n    this.dataView.setUint16(this.bytePosition, Number(value), true);\n    return this.shift(2);\n  }\n  /**\n   * Write a U32 value into a buffer and shift cursor position by 4.\n   * @param {Number} value Value to write.\n   * @returns {this}\n   */\n  write32(value) {\n    this.ensureSizeOrGrow(4);\n    this.dataView.setUint32(this.bytePosition, Number(value), true);\n    return this.shift(4);\n  }\n  /**\n   * Write a U64 value into a buffer and shift cursor position by 8.\n   * @param {bigint} value Value to write.\n   * @returns {this}\n   */\n  write64(value) {\n    toLittleEndian(BigInt(value), 8).forEach((el) => this.write8(el));\n    return this;\n  }\n  /**\n   * Write a U128 value into a buffer and shift cursor position by 16.\n   *\n   * @param {bigint} value Value to write.\n   * @returns {this}\n   */\n  write128(value) {\n    toLittleEndian(BigInt(value), 16).forEach((el) => this.write8(el));\n    return this;\n  }\n  /**\n   * Write a U256 value into a buffer and shift cursor position by 16.\n   *\n   * @param {bigint} value Value to write.\n   * @returns {this}\n   */\n  write256(value) {\n    toLittleEndian(BigInt(value), 32).forEach((el) => this.write8(el));\n    return this;\n  }\n  /**\n   * Write a ULEB value into a buffer and shift cursor position by number of bytes\n   * written.\n   * @param {Number} value Value to write.\n   * @returns {this}\n   */\n  writeULEB(value) {\n    ulebEncode(value).forEach((el) => this.write8(el));\n    return this;\n  }\n  /**\n   * Write a vector into a buffer by first writing the vector length and then calling\n   * a callback on each passed value.\n   *\n   * @param {Array<Any>} vector Array of elements to write.\n   * @param {WriteVecCb} cb Callback to call on each element of the vector.\n   * @returns {this}\n   */\n  writeVec(vector, cb) {\n    this.writeULEB(vector.length);\n    Array.from(vector).forEach((el, i) => cb(this, el, i, vector.length));\n    return this;\n  }\n  /**\n   * Adds support for iterations over the object.\n   * @returns {Uint8Array}\n   */\n  // oxlint-disable-next-line require-yields\n  *[Symbol.iterator]() {\n    for (let i = 0; i < this.bytePosition; i++) {\n      yield this.dataView.getUint8(i);\n    }\n    return this.toBytes();\n  }\n  /**\n   * Get underlying buffer taking only value bytes (in case initial buffer size was bigger).\n   * @returns {Uint8Array} Resulting bcs.\n   */\n  toBytes() {\n    return new Uint8Array(this.dataView.buffer.slice(0, this.bytePosition));\n  }\n  /**\n   * Represent data as 'hex' or 'base64'\n   * @param encoding Encoding to use: 'base64' or 'hex'\n   */\n  toString(encoding) {\n    return encodeStr(this.toBytes(), encoding);\n  }\n}\nfunction toLittleEndian(bigint, size) {\n  const result = new Uint8Array(size);\n  let i = 0;\n  while (bigint > 0) {\n    result[i] = Number(bigint % BigInt(256));\n    bigint = bigint / BigInt(256);\n    i += 1;\n  }\n  return result;\n}\nexport {\n  BcsWriter\n};\n//# sourceMappingURL=writer.js.map\n","var __typeError = (msg) => {\n  throw TypeError(msg);\n};\nvar __accessCheck = (obj, member, msg) => member.has(obj) || __typeError(\"Cannot \" + msg);\nvar __privateGet = (obj, member, getter) => (__accessCheck(obj, member, \"read from private field\"), getter ? getter.call(obj) : member.get(obj));\nvar __privateAdd = (obj, member, value) => member.has(obj) ? __typeError(\"Cannot add the same private member more than once\") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\nvar __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, \"write to private field\"), setter ? setter.call(obj, value) : member.set(obj, value), value);\nvar _write, _serialize, _schema, _bytes;\nimport { fromBase58, fromBase64, toBase58, toBase64, fromHex, toHex } from \"@mysten/utils\";\nimport { BcsReader } from \"./reader.js\";\nimport { ulebEncode } from \"./uleb.js\";\nimport { BcsWriter } from \"./writer.js\";\nconst _BcsType = class _BcsType {\n  constructor(options) {\n    __privateAdd(this, _write);\n    __privateAdd(this, _serialize);\n    this.name = options.name;\n    this.read = options.read;\n    this.serializedSize = options.serializedSize ?? (() => null);\n    __privateSet(this, _write, options.write);\n    __privateSet(this, _serialize, options.serialize ?? ((value, options2) => {\n      const writer = new BcsWriter({\n        initialSize: this.serializedSize(value) ?? void 0,\n        ...options2\n      });\n      __privateGet(this, _write).call(this, value, writer);\n      return writer.toBytes();\n    }));\n    this.validate = options.validate ?? (() => {\n    });\n  }\n  write(value, writer) {\n    this.validate(value);\n    __privateGet(this, _write).call(this, value, writer);\n  }\n  serialize(value, options) {\n    this.validate(value);\n    return new SerializedBcs(this, __privateGet(this, _serialize).call(this, value, options));\n  }\n  parse(bytes) {\n    const reader = new BcsReader(bytes);\n    return this.read(reader);\n  }\n  fromHex(hex) {\n    return this.parse(fromHex(hex));\n  }\n  fromBase58(b64) {\n    return this.parse(fromBase58(b64));\n  }\n  fromBase64(b64) {\n    return this.parse(fromBase64(b64));\n  }\n  transform({\n    name,\n    input,\n    output,\n    validate\n  }) {\n    return new _BcsType({\n      name: name ?? this.name,\n      read: (reader) => output ? output(this.read(reader)) : this.read(reader),\n      write: (value, writer) => __privateGet(this, _write).call(this, input ? input(value) : value, writer),\n      serializedSize: (value) => this.serializedSize(input ? input(value) : value),\n      serialize: (value, options) => __privateGet(this, _serialize).call(this, input ? input(value) : value, options),\n      validate: (value) => {\n        validate?.(value);\n        this.validate(input ? input(value) : value);\n      }\n    });\n  }\n};\n_write = new WeakMap();\n_serialize = new WeakMap();\nlet BcsType = _BcsType;\nconst SERIALIZED_BCS_BRAND = Symbol.for(\"@mysten/serialized-bcs\");\nfunction isSerializedBcs(obj) {\n  return !!obj && typeof obj === \"object\" && obj[SERIALIZED_BCS_BRAND] === true;\n}\nclass SerializedBcs {\n  constructor(schema, bytes) {\n    __privateAdd(this, _schema);\n    __privateAdd(this, _bytes);\n    __privateSet(this, _schema, schema);\n    __privateSet(this, _bytes, bytes);\n  }\n  // Used to brand SerializedBcs so that they can be identified, even between multiple copies\n  // of the @mysten/bcs package are installed\n  get [SERIALIZED_BCS_BRAND]() {\n    return true;\n  }\n  toBytes() {\n    return __privateGet(this, _bytes);\n  }\n  toHex() {\n    return toHex(__privateGet(this, _bytes));\n  }\n  toBase64() {\n    return toBase64(__privateGet(this, _bytes));\n  }\n  toBase58() {\n    return toBase58(__privateGet(this, _bytes));\n  }\n  parse() {\n    return __privateGet(this, _schema).parse(__privateGet(this, _bytes));\n  }\n}\n_schema = new WeakMap();\n_bytes = new WeakMap();\nfunction fixedSizeBcsType({\n  size,\n  ...options\n}) {\n  return new BcsType({\n    ...options,\n    serializedSize: () => size\n  });\n}\nfunction uIntBcsType({\n  readMethod,\n  writeMethod,\n  ...options\n}) {\n  return fixedSizeBcsType({\n    ...options,\n    read: (reader) => reader[readMethod](),\n    write: (value, writer) => writer[writeMethod](value),\n    validate: (value) => {\n      if (value < 0 || value > options.maxValue) {\n        throw new TypeError(\n          `Invalid ${options.name} value: ${value}. Expected value in range 0-${options.maxValue}`\n        );\n      }\n      options.validate?.(value);\n    }\n  });\n}\nfunction bigUIntBcsType({\n  readMethod,\n  writeMethod,\n  ...options\n}) {\n  return fixedSizeBcsType({\n    ...options,\n    read: (reader) => reader[readMethod](),\n    write: (value, writer) => writer[writeMethod](BigInt(value)),\n    validate: (val) => {\n      const value = BigInt(val);\n      if (value < 0 || value > options.maxValue) {\n        throw new TypeError(\n          `Invalid ${options.name} value: ${value}. Expected value in range 0-${options.maxValue}`\n        );\n      }\n      options.validate?.(value);\n    }\n  });\n}\nfunction dynamicSizeBcsType({\n  serialize,\n  ...options\n}) {\n  const type = new BcsType({\n    ...options,\n    serialize,\n    write: (value, writer) => {\n      for (const byte of type.serialize(value).toBytes()) {\n        writer.write8(byte);\n      }\n    }\n  });\n  return type;\n}\nfunction stringLikeBcsType({\n  toBytes,\n  fromBytes,\n  ...options\n}) {\n  return new BcsType({\n    ...options,\n    read: (reader) => {\n      const length = reader.readULEB();\n      const bytes = reader.readBytes(length);\n      return fromBytes(bytes);\n    },\n    write: (hex, writer) => {\n      const bytes = toBytes(hex);\n      writer.writeULEB(bytes.length);\n      for (let i = 0; i < bytes.length; i++) {\n        writer.write8(bytes[i]);\n      }\n    },\n    serialize: (value) => {\n      const bytes = toBytes(value);\n      const size = ulebEncode(bytes.length);\n      const result = new Uint8Array(size.length + bytes.length);\n      result.set(size, 0);\n      result.set(bytes, size.length);\n      return result;\n    },\n    validate: (value) => {\n      if (typeof value !== \"string\") {\n        throw new TypeError(`Invalid ${options.name} value: ${value}. Expected string`);\n      }\n      options.validate?.(value);\n    }\n  });\n}\nfunction lazyBcsType(cb) {\n  let lazyType = null;\n  function getType() {\n    if (!lazyType) {\n      lazyType = cb();\n    }\n    return lazyType;\n  }\n  return new BcsType({\n    name: \"lazy\",\n    read: (data) => getType().read(data),\n    serializedSize: (value) => getType().serializedSize(value),\n    write: (value, writer) => getType().write(value, writer),\n    serialize: (value, options) => getType().serialize(value, options).toBytes()\n  });\n}\nclass BcsStruct extends BcsType {\n  constructor({ name, fields, ...options }) {\n    const canonicalOrder = Object.entries(fields);\n    super({\n      name,\n      serializedSize: (values) => {\n        let total = 0;\n        for (const [field, type] of canonicalOrder) {\n          const size = type.serializedSize(values[field]);\n          if (size == null) {\n            return null;\n          }\n          total += size;\n        }\n        return total;\n      },\n      read: (reader) => {\n        const result = {};\n        for (const [field, type] of canonicalOrder) {\n          result[field] = type.read(reader);\n        }\n        return result;\n      },\n      write: (value, writer) => {\n        for (const [field, type] of canonicalOrder) {\n          type.write(value[field], writer);\n        }\n      },\n      ...options,\n      validate: (value) => {\n        options?.validate?.(value);\n        if (typeof value !== \"object\" || value == null) {\n          throw new TypeError(`Expected object, found ${typeof value}`);\n        }\n      }\n    });\n  }\n}\nclass BcsEnum extends BcsType {\n  constructor({ fields, ...options }) {\n    const canonicalOrder = Object.entries(fields);\n    super({\n      read: (reader) => {\n        const index = reader.readULEB();\n        const enumEntry = canonicalOrder[index];\n        if (!enumEntry) {\n          throw new TypeError(`Unknown value ${index} for enum ${options.name}`);\n        }\n        const [kind, type] = enumEntry;\n        return {\n          [kind]: type?.read(reader) ?? true,\n          $kind: kind\n        };\n      },\n      write: (value, writer) => {\n        const [name, val] = Object.entries(value).filter(\n          ([name2]) => Object.hasOwn(fields, name2)\n        )[0];\n        for (let i = 0; i < canonicalOrder.length; i++) {\n          const [optionName, optionType] = canonicalOrder[i];\n          if (optionName === name) {\n            writer.writeULEB(i);\n            optionType?.write(val, writer);\n            return;\n          }\n        }\n      },\n      ...options,\n      validate: (value) => {\n        options?.validate?.(value);\n        if (typeof value !== \"object\" || value == null) {\n          throw new TypeError(`Expected object, found ${typeof value}`);\n        }\n        const keys = Object.keys(value).filter(\n          (k) => value[k] !== void 0 && Object.hasOwn(fields, k)\n        );\n        if (keys.length !== 1) {\n          throw new TypeError(\n            `Expected object with one key, but found ${keys.length} for type ${options.name}}`\n          );\n        }\n        const [variant] = keys;\n        if (!Object.hasOwn(fields, variant)) {\n          throw new TypeError(`Invalid enum variant ${variant}`);\n        }\n      }\n    });\n  }\n}\nclass BcsTuple extends BcsType {\n  constructor({ fields, name, ...options }) {\n    super({\n      name: name ?? `(${fields.map((t) => t.name).join(\", \")})`,\n      serializedSize: (values) => {\n        let total = 0;\n        for (let i = 0; i < fields.length; i++) {\n          const size = fields[i].serializedSize(values[i]);\n          if (size == null) {\n            return null;\n          }\n          total += size;\n        }\n        return total;\n      },\n      read: (reader) => {\n        const result = [];\n        for (const field of fields) {\n          result.push(field.read(reader));\n        }\n        return result;\n      },\n      write: (value, writer) => {\n        for (let i = 0; i < fields.length; i++) {\n          fields[i].write(value[i], writer);\n        }\n      },\n      ...options,\n      validate: (value) => {\n        options?.validate?.(value);\n        if (!Array.isArray(value)) {\n          throw new TypeError(`Expected array, found ${typeof value}`);\n        }\n        if (value.length !== fields.length) {\n          throw new TypeError(`Expected array of length ${fields.length}, found ${value.length}`);\n        }\n      }\n    });\n  }\n}\nexport {\n  BcsEnum,\n  BcsStruct,\n  BcsTuple,\n  BcsType,\n  SerializedBcs,\n  bigUIntBcsType,\n  dynamicSizeBcsType,\n  fixedSizeBcsType,\n  isSerializedBcs,\n  lazyBcsType,\n  stringLikeBcsType,\n  uIntBcsType\n};\n//# sourceMappingURL=bcs-type.js.map\n","import {\n  BcsEnum,\n  BcsStruct,\n  BcsTuple,\n  BcsType,\n  bigUIntBcsType,\n  dynamicSizeBcsType,\n  fixedSizeBcsType,\n  lazyBcsType,\n  stringLikeBcsType,\n  uIntBcsType\n} from \"./bcs-type.js\";\nimport { ulebEncode } from \"./uleb.js\";\nfunction fixedArray(size, type, options) {\n  return new BcsType({\n    read: (reader) => {\n      const result = new Array(size);\n      for (let i = 0; i < size; i++) {\n        result[i] = type.read(reader);\n      }\n      return result;\n    },\n    write: (value, writer) => {\n      for (const item of value) {\n        type.write(item, writer);\n      }\n    },\n    ...options,\n    name: options?.name ?? `${type.name}[${size}]`,\n    validate: (value) => {\n      options?.validate?.(value);\n      if (!value || typeof value !== \"object\" || !(\"length\" in value)) {\n        throw new TypeError(`Expected array, found ${typeof value}`);\n      }\n      if (value.length !== size) {\n        throw new TypeError(`Expected array of length ${size}, found ${value.length}`);\n      }\n    }\n  });\n}\nfunction option(type) {\n  return bcs.enum(`Option<${type.name}>`, {\n    None: null,\n    Some: type\n  }).transform({\n    input: (value) => {\n      if (value == null) {\n        return { None: true };\n      }\n      return { Some: value };\n    },\n    output: (value) => {\n      if (value.$kind === \"Some\") {\n        return value.Some;\n      }\n      return null;\n    }\n  });\n}\nfunction vector(type, options) {\n  return new BcsType({\n    read: (reader) => {\n      const length = reader.readULEB();\n      const result = new Array(length);\n      for (let i = 0; i < length; i++) {\n        result[i] = type.read(reader);\n      }\n      return result;\n    },\n    write: (value, writer) => {\n      writer.writeULEB(value.length);\n      for (const item of value) {\n        type.write(item, writer);\n      }\n    },\n    ...options,\n    name: options?.name ?? `vector<${type.name}>`,\n    validate: (value) => {\n      options?.validate?.(value);\n      if (!value || typeof value !== \"object\" || !(\"length\" in value)) {\n        throw new TypeError(`Expected array, found ${typeof value}`);\n      }\n    }\n  });\n}\nfunction map(keyType, valueType) {\n  return bcs.vector(bcs.tuple([keyType, valueType])).transform({\n    name: `Map<${keyType.name}, ${valueType.name}>`,\n    input: (value) => {\n      return [...value.entries()];\n    },\n    output: (value) => {\n      const result = /* @__PURE__ */ new Map();\n      for (const [key, val] of value) {\n        result.set(key, val);\n      }\n      return result;\n    }\n  });\n}\nconst bcs = {\n  /**\n   * Creates a BcsType that can be used to read and write an 8-bit unsigned integer.\n   * @example\n   * bcs.u8().serialize(255).toBytes() // Uint8Array [ 255 ]\n   */\n  u8(options) {\n    return uIntBcsType({\n      readMethod: \"read8\",\n      writeMethod: \"write8\",\n      size: 1,\n      maxValue: 2 ** 8 - 1,\n      ...options,\n      name: options?.name ?? \"u8\"\n    });\n  },\n  /**\n   * Creates a BcsType that can be used to read and write a 16-bit unsigned integer.\n   * @example\n   * bcs.u16().serialize(65535).toBytes() // Uint8Array [ 255, 255 ]\n   */\n  u16(options) {\n    return uIntBcsType({\n      readMethod: \"read16\",\n      writeMethod: \"write16\",\n      size: 2,\n      maxValue: 2 ** 16 - 1,\n      ...options,\n      name: options?.name ?? \"u16\"\n    });\n  },\n  /**\n   * Creates a BcsType that can be used to read and write a 32-bit unsigned integer.\n   * @example\n   * bcs.u32().serialize(4294967295).toBytes() // Uint8Array [ 255, 255, 255, 255 ]\n   */\n  u32(options) {\n    return uIntBcsType({\n      readMethod: \"read32\",\n      writeMethod: \"write32\",\n      size: 4,\n      maxValue: 2 ** 32 - 1,\n      ...options,\n      name: options?.name ?? \"u32\"\n    });\n  },\n  /**\n   * Creates a BcsType that can be used to read and write a 64-bit unsigned integer.\n   * @example\n   * bcs.u64().serialize(1).toBytes() // Uint8Array [ 1, 0, 0, 0, 0, 0, 0, 0 ]\n   */\n  u64(options) {\n    return bigUIntBcsType({\n      readMethod: \"read64\",\n      writeMethod: \"write64\",\n      size: 8,\n      maxValue: 2n ** 64n - 1n,\n      ...options,\n      name: options?.name ?? \"u64\"\n    });\n  },\n  /**\n   * Creates a BcsType that can be used to read and write a 128-bit unsigned integer.\n   * @example\n   * bcs.u128().serialize(1).toBytes() // Uint8Array [ 1, ..., 0 ]\n   */\n  u128(options) {\n    return bigUIntBcsType({\n      readMethod: \"read128\",\n      writeMethod: \"write128\",\n      size: 16,\n      maxValue: 2n ** 128n - 1n,\n      ...options,\n      name: options?.name ?? \"u128\"\n    });\n  },\n  /**\n   * Creates a BcsType that can be used to read and write a 256-bit unsigned integer.\n   * @example\n   * bcs.u256().serialize(1).toBytes() // Uint8Array [ 1, ..., 0 ]\n   */\n  u256(options) {\n    return bigUIntBcsType({\n      readMethod: \"read256\",\n      writeMethod: \"write256\",\n      size: 32,\n      maxValue: 2n ** 256n - 1n,\n      ...options,\n      name: options?.name ?? \"u256\"\n    });\n  },\n  /**\n   * Creates a BcsType that can be used to read and write boolean values.\n   * @example\n   * bcs.bool().serialize(true).toBytes() // Uint8Array [ 1 ]\n   */\n  bool(options) {\n    return fixedSizeBcsType({\n      size: 1,\n      read: (reader) => reader.read8() === 1,\n      write: (value, writer) => writer.write8(value ? 1 : 0),\n      ...options,\n      name: options?.name ?? \"bool\",\n      validate: (value) => {\n        options?.validate?.(value);\n        if (typeof value !== \"boolean\") {\n          throw new TypeError(`Expected boolean, found ${typeof value}`);\n        }\n      }\n    });\n  },\n  /**\n   * Creates a BcsType that can be used to read and write unsigned LEB encoded integers\n   * @example\n   *\n   */\n  uleb128(options) {\n    return dynamicSizeBcsType({\n      read: (reader) => reader.readULEB(),\n      serialize: (value) => {\n        return Uint8Array.from(ulebEncode(value));\n      },\n      ...options,\n      name: options?.name ?? \"uleb128\"\n    });\n  },\n  /**\n   * Creates a BcsType representing a fixed length byte array\n   * @param size The number of bytes this types represents\n   * @example\n   * bcs.bytes(3).serialize(new Uint8Array([1, 2, 3])).toBytes() // Uint8Array [1, 2, 3]\n   */\n  bytes(size, options) {\n    return fixedSizeBcsType({\n      size,\n      read: (reader) => reader.readBytes(size),\n      write: (value, writer) => {\n        writer.writeBytes(new Uint8Array(value));\n      },\n      ...options,\n      name: options?.name ?? `bytes[${size}]`,\n      validate: (value) => {\n        options?.validate?.(value);\n        if (!value || typeof value !== \"object\" || !(\"length\" in value)) {\n          throw new TypeError(`Expected array, found ${typeof value}`);\n        }\n        if (value.length !== size) {\n          throw new TypeError(`Expected array of length ${size}, found ${value.length}`);\n        }\n      }\n    });\n  },\n  /**\n   * Creates a BcsType representing a variable length byte array\n   *\n   * @example\n   * bcs.byteVector().serialize([1, 2, 3]).toBytes() // Uint8Array [3, 1, 2, 3]\n   */\n  byteVector(options) {\n    return new BcsType({\n      read: (reader) => {\n        const length = reader.readULEB();\n        return reader.readBytes(length);\n      },\n      write: (value, writer) => {\n        const array = new Uint8Array(value);\n        writer.writeULEB(array.length);\n        writer.writeBytes(array);\n      },\n      ...options,\n      name: options?.name ?? \"vector<u8>\",\n      serializedSize: (value) => {\n        const length = \"length\" in value ? value.length : null;\n        return length == null ? null : ulebEncode(length).length + length;\n      },\n      validate: (value) => {\n        options?.validate?.(value);\n        if (!value || typeof value !== \"object\" || !(\"length\" in value)) {\n          throw new TypeError(`Expected array, found ${typeof value}`);\n        }\n      }\n    });\n  },\n  /**\n   * Creates a BcsType that can ser/de string values.  Strings will be UTF-8 encoded\n   * @example\n   * bcs.string().serialize('a').toBytes() // Uint8Array [ 1, 97 ]\n   */\n  string(options) {\n    return stringLikeBcsType({\n      toBytes: (value) => new TextEncoder().encode(value),\n      fromBytes: (bytes) => new TextDecoder().decode(bytes),\n      ...options,\n      name: options?.name ?? \"string\"\n    });\n  },\n  /**\n   * Creates a BcsType that represents a fixed length array of a given type\n   * @param size The number of elements in the array\n   * @param type The BcsType of each element in the array\n   * @example\n   * bcs.fixedArray(3, bcs.u8()).serialize([1, 2, 3]).toBytes() // Uint8Array [ 1, 2, 3 ]\n   */\n  fixedArray,\n  /**\n   * Creates a BcsType representing an optional value\n   * @param type The BcsType of the optional value\n   * @example\n   * bcs.option(bcs.u8()).serialize(null).toBytes() // Uint8Array [ 0 ]\n   * bcs.option(bcs.u8()).serialize(1).toBytes() // Uint8Array [ 1, 1 ]\n   */\n  option,\n  /**\n   * Creates a BcsType representing a variable length vector of a given type\n   * @param type The BcsType of each element in the vector\n   *\n   * @example\n   * bcs.vector(bcs.u8()).toBytes([1, 2, 3]) // Uint8Array [ 3, 1, 2, 3 ]\n   */\n  vector,\n  /**\n   * Creates a BcsType representing a tuple of a given set of types\n   * @param types The BcsTypes for each element in the tuple\n   *\n   * @example\n   * const tuple = bcs.tuple([bcs.u8(), bcs.string(), bcs.bool()])\n   * tuple.serialize([1, 'a', true]).toBytes() // Uint8Array [ 1, 1, 97, 1 ]\n   */\n  tuple(fields, options) {\n    return new BcsTuple({\n      fields,\n      ...options\n    });\n  },\n  /**\n   * Creates a BcsType representing a struct of a given set of fields\n   * @param name The name of the struct\n   * @param fields The fields of the struct. The order of the fields affects how data is serialized and deserialized\n   *\n   * @example\n   * const struct = bcs.struct('MyStruct', {\n   *  a: bcs.u8(),\n   *  b: bcs.string(),\n   * })\n   * struct.serialize({ a: 1, b: 'a' }).toBytes() // Uint8Array [ 1, 1, 97 ]\n   */\n  struct(name, fields, options) {\n    return new BcsStruct({\n      name,\n      fields,\n      ...options\n    });\n  },\n  /**\n   * Creates a BcsType representing an enum of a given set of options\n   * @param name The name of the enum\n   * @param values The values of the enum. The order of the values affects how data is serialized and deserialized.\n   * null can be used to represent a variant with no data.\n   *\n   * @example\n   * const enum = bcs.enum('MyEnum', {\n   *   A: bcs.u8(),\n   *   B: bcs.string(),\n   *   C: null,\n   * })\n   * enum.serialize({ A: 1 }).toBytes() // Uint8Array [ 0, 1 ]\n   * enum.serialize({ B: 'a' }).toBytes() // Uint8Array [ 1, 1, 97 ]\n   * enum.serialize({ C: true }).toBytes() // Uint8Array [ 2 ]\n   */\n  enum(name, fields, options) {\n    return new BcsEnum({\n      name,\n      fields,\n      ...options\n    });\n  },\n  /**\n   * Creates a BcsType representing a map of a given key and value type\n   * @param keyType The BcsType of the key\n   * @param valueType The BcsType of the value\n   * @example\n   * const map = bcs.map(bcs.u8(), bcs.string())\n   * map.serialize(new Map([[2, 'a']])).toBytes() // Uint8Array [ 1, 2, 1, 97 ]\n   */\n  map,\n  /**\n   * Creates a BcsType that wraps another BcsType which is lazily evaluated. This is useful for creating recursive types.\n   * @param cb A callback that returns the BcsType\n   */\n  lazy(cb) {\n    return lazyBcsType(cb);\n  }\n};\nexport {\n  bcs\n};\n//# sourceMappingURL=bcs.js.map\n","const SUI_NS_NAME_REGEX = /^(?!.*(^(?!@)|[-.@])($|[-.@]))(?:[a-z0-9-]{0,63}(?:\\.[a-z0-9-]{0,63})*)?@[a-z0-9-]{0,63}$/i;\nconst SUI_NS_DOMAIN_REGEX = /^(?!.*(^|[-.])($|[-.]))(?:[a-z0-9-]{0,63}\\.)+sui$/i;\nconst MAX_SUI_NS_NAME_LENGTH = 235;\nfunction isValidSuiNSName(name) {\n  if (name.length > MAX_SUI_NS_NAME_LENGTH) {\n    return false;\n  }\n  if (name.includes(\"@\")) {\n    return SUI_NS_NAME_REGEX.test(name);\n  }\n  return SUI_NS_DOMAIN_REGEX.test(name);\n}\nfunction normalizeSuiNSName(name, format = \"at\") {\n  const lowerCase = name.toLowerCase();\n  let parts;\n  if (lowerCase.includes(\"@\")) {\n    if (!SUI_NS_NAME_REGEX.test(lowerCase)) {\n      throw new Error(`Invalid SuiNS name ${name}`);\n    }\n    const [labels, domain] = lowerCase.split(\"@\");\n    parts = [...labels ? labels.split(\".\") : [], domain];\n  } else {\n    if (!SUI_NS_DOMAIN_REGEX.test(lowerCase)) {\n      throw new Error(`Invalid SuiNS name ${name}`);\n    }\n    parts = lowerCase.split(\".\").slice(0, -1);\n  }\n  if (format === \"dot\") {\n    return `${parts.join(\".\")}.sui`;\n  }\n  return `${parts.slice(0, -1).join(\".\")}@${parts[parts.length - 1]}`;\n}\nexport {\n  isValidSuiNSName,\n  normalizeSuiNSName\n};\n//# sourceMappingURL=suins.js.map\n","import { isValidSuiNSName } from \"./suins.js\";\nconst NAME_PATTERN = /^([a-z0-9]+(?:-[a-z0-9]+)*)$/;\nconst VERSION_REGEX = /^\\d+$/;\nconst MAX_APP_SIZE = 64;\nconst NAME_SEPARATOR = \"/\";\nconst isValidNamedPackage = (name) => {\n  const parts = name.split(NAME_SEPARATOR);\n  if (parts.length < 2 || parts.length > 3) return false;\n  const [org, app, version] = parts;\n  if (version !== void 0 && !VERSION_REGEX.test(version)) return false;\n  if (!isValidSuiNSName(org)) return false;\n  return NAME_PATTERN.test(app) && app.length < MAX_APP_SIZE;\n};\nconst isValidNamedType = (type) => {\n  const splitType = type.split(/::|<|>|,/);\n  for (const t of splitType) {\n    if (t.includes(NAME_SEPARATOR) && !isValidNamedPackage(t)) return false;\n  }\n  return true;\n};\nexport {\n  isValidNamedPackage,\n  isValidNamedType\n};\n//# sourceMappingURL=move-registry.js.map\n","import { fromBase58, splitGenericParameters } from \"@mysten/bcs\";\nimport { isValidNamedPackage } from \"./move-registry.js\";\nconst TX_DIGEST_LENGTH = 32;\nfunction isValidTransactionDigest(value) {\n  try {\n    const buffer = fromBase58(value);\n    return buffer.length === TX_DIGEST_LENGTH;\n  } catch {\n    return false;\n  }\n}\nconst SUI_ADDRESS_LENGTH = 32;\nfunction isValidSuiAddress(value) {\n  return isHex(value) && getHexByteLength(value) === SUI_ADDRESS_LENGTH;\n}\nfunction isValidSuiObjectId(value) {\n  return isValidSuiAddress(value);\n}\nfunction parseTypeTag(type) {\n  if (!type.includes(\"::\")) return type;\n  return parseStructTag(type);\n}\nfunction parseStructTag(type) {\n  const [address, module] = type.split(\"::\");\n  const isMvrPackage = isValidNamedPackage(address);\n  const rest = type.slice(address.length + module.length + 4);\n  const name = rest.includes(\"<\") ? rest.slice(0, rest.indexOf(\"<\")) : rest;\n  const typeParams = rest.includes(\"<\") ? splitGenericParameters(rest.slice(rest.indexOf(\"<\") + 1, rest.lastIndexOf(\">\"))).map(\n    (typeParam) => parseTypeTag(typeParam.trim())\n  ) : [];\n  return {\n    address: isMvrPackage ? address : normalizeSuiAddress(address),\n    module,\n    name,\n    typeParams\n  };\n}\nfunction normalizeStructTag(type) {\n  const { address, module, name, typeParams } = typeof type === \"string\" ? parseStructTag(type) : type;\n  const formattedTypeParams = typeParams?.length > 0 ? `<${typeParams.map(\n    (typeParam) => typeof typeParam === \"string\" ? typeParam : normalizeStructTag(typeParam)\n  ).join(\",\")}>` : \"\";\n  return `${address}::${module}::${name}${formattedTypeParams}`;\n}\nfunction normalizeSuiAddress(value, forceAdd0x = false) {\n  let address = value.toLowerCase();\n  if (!forceAdd0x && address.startsWith(\"0x\")) {\n    address = address.slice(2);\n  }\n  return `0x${address.padStart(SUI_ADDRESS_LENGTH * 2, \"0\")}`;\n}\nfunction normalizeSuiObjectId(value, forceAdd0x = false) {\n  return normalizeSuiAddress(value, forceAdd0x);\n}\nfunction isHex(value) {\n  return /^(0x|0X)?[a-fA-F0-9]+$/.test(value) && value.length % 2 === 0;\n}\nfunction getHexByteLength(value) {\n  return /^(0x|0X)/.test(value) ? (value.length - 2) / 2 : value.length / 2;\n}\nexport {\n  SUI_ADDRESS_LENGTH,\n  isValidSuiAddress,\n  isValidSuiObjectId,\n  isValidTransactionDigest,\n  normalizeStructTag,\n  normalizeSuiAddress,\n  normalizeSuiObjectId,\n  parseStructTag\n};\n//# sourceMappingURL=sui-types.js.map\n","import { normalizeSuiObjectId } from \"./sui-types.js\";\nconst SUI_DECIMALS = 9;\nconst MIST_PER_SUI = BigInt(1e9);\nconst MOVE_STDLIB_ADDRESS = \"0x1\";\nconst SUI_FRAMEWORK_ADDRESS = \"0x2\";\nconst SUI_SYSTEM_ADDRESS = \"0x3\";\nconst SUI_CLOCK_OBJECT_ID = normalizeSuiObjectId(\"0x6\");\nconst SUI_SYSTEM_MODULE_NAME = \"sui_system\";\nconst SUI_TYPE_ARG = `${SUI_FRAMEWORK_ADDRESS}::sui::SUI`;\nconst SUI_SYSTEM_STATE_OBJECT_ID = normalizeSuiObjectId(\"0x5\");\nconst SUI_RANDOM_OBJECT_ID = normalizeSuiObjectId(\"0x8\");\nexport {\n  MIST_PER_SUI,\n  MOVE_STDLIB_ADDRESS,\n  SUI_CLOCK_OBJECT_ID,\n  SUI_DECIMALS,\n  SUI_FRAMEWORK_ADDRESS,\n  SUI_RANDOM_OBJECT_ID,\n  SUI_SYSTEM_ADDRESS,\n  SUI_SYSTEM_MODULE_NAME,\n  SUI_SYSTEM_STATE_OBJECT_ID,\n  SUI_TYPE_ARG\n};\n//# sourceMappingURL=constants.js.map\n","export const crypto = typeof globalThis === 'object' && 'crypto' in globalThis ? globalThis.crypto : undefined;\n//# sourceMappingURL=crypto.js.map","/**\n * Utilities for hex, bytes, CSPRNG.\n * @module\n */\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.\nimport { crypto } from '@noble/hashes/crypto';\n/** Checks if something is Uint8Array. Be careful: nodejs Buffer will return true. */\nexport function isBytes(a) {\n    return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\n/** Asserts something is positive integer. */\nexport function anumber(n) {\n    if (!Number.isSafeInteger(n) || n < 0)\n        throw new Error('positive integer expected, got ' + n);\n}\n/** Asserts something is Uint8Array. */\nexport function abytes(b, ...lengths) {\n    if (!isBytes(b))\n        throw new Error('Uint8Array expected');\n    if (lengths.length > 0 && !lengths.includes(b.length))\n        throw new Error('Uint8Array expected of length ' + lengths + ', got length=' + b.length);\n}\n/** Asserts something is hash */\nexport function ahash(h) {\n    if (typeof h !== 'function' || typeof h.create !== 'function')\n        throw new Error('Hash should be wrapped by utils.createHasher');\n    anumber(h.outputLen);\n    anumber(h.blockLen);\n}\n/** Asserts a hash instance has not been destroyed / finished */\nexport function aexists(instance, checkFinished = true) {\n    if (instance.destroyed)\n        throw new Error('Hash instance has been destroyed');\n    if (checkFinished && instance.finished)\n        throw new Error('Hash#digest() has already been called');\n}\n/** Asserts output is properly-sized byte array */\nexport function aoutput(out, instance) {\n    abytes(out);\n    const min = instance.outputLen;\n    if (out.length < min) {\n        throw new Error('digestInto() expects output buffer of length at least ' + min);\n    }\n}\n/** Cast u8 / u16 / u32 to u8. */\nexport function u8(arr) {\n    return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\n}\n/** Cast u8 / u16 / u32 to u32. */\nexport function u32(arr) {\n    return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n}\n/** Zeroize a byte array. Warning: JS provides no guarantees. */\nexport function clean(...arrays) {\n    for (let i = 0; i < arrays.length; i++) {\n        arrays[i].fill(0);\n    }\n}\n/** Create DataView of an array for easy byte-level manipulation. */\nexport function createView(arr) {\n    return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n}\n/** The rotate right (circular right shift) operation for uint32 */\nexport function rotr(word, shift) {\n    return (word << (32 - shift)) | (word >>> shift);\n}\n/** The rotate left (circular left shift) operation for uint32 */\nexport function rotl(word, shift) {\n    return (word << shift) | ((word >>> (32 - shift)) >>> 0);\n}\n/** Is current platform little-endian? Most are. Big-Endian platform: IBM */\nexport const isLE = /* @__PURE__ */ (() => new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44)();\n/** The byte swap operation for uint32 */\nexport function byteSwap(word) {\n    return (((word << 24) & 0xff000000) |\n        ((word << 8) & 0xff0000) |\n        ((word >>> 8) & 0xff00) |\n        ((word >>> 24) & 0xff));\n}\n/** Conditionally byte swap if on a big-endian platform */\nexport const swap8IfBE = isLE\n    ? (n) => n\n    : (n) => byteSwap(n);\n/** @deprecated */\nexport const byteSwapIfBE = swap8IfBE;\n/** In place byte swap for Uint32Array */\nexport function byteSwap32(arr) {\n    for (let i = 0; i < arr.length; i++) {\n        arr[i] = byteSwap(arr[i]);\n    }\n    return arr;\n}\nexport const swap32IfBE = isLE\n    ? (u) => u\n    : byteSwap32;\n// Built-in hex conversion https://caniuse.com/mdn-javascript_builtins_uint8array_fromhex\nconst hasHexBuiltin = /* @__PURE__ */ (() => \n// @ts-ignore\ntypeof Uint8Array.from([]).toHex === 'function' && typeof Uint8Array.fromHex === 'function')();\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\n/**\n * Convert byte array to hex string. Uses built-in function, when available.\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nexport function bytesToHex(bytes) {\n    abytes(bytes);\n    // @ts-ignore\n    if (hasHexBuiltin)\n        return bytes.toHex();\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };\nfunction asciiToBase16(ch) {\n    if (ch >= asciis._0 && ch <= asciis._9)\n        return ch - asciis._0; // '2' => 50-48\n    if (ch >= asciis.A && ch <= asciis.F)\n        return ch - (asciis.A - 10); // 'B' => 66-(65-10)\n    if (ch >= asciis.a && ch <= asciis.f)\n        return ch - (asciis.a - 10); // 'b' => 98-(97-10)\n    return;\n}\n/**\n * Convert hex string to byte array. Uses built-in function, when available.\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nexport function hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    // @ts-ignore\n    if (hasHexBuiltin)\n        return Uint8Array.fromHex(hex);\n    const hl = hex.length;\n    const al = hl / 2;\n    if (hl % 2)\n        throw new Error('hex string expected, got unpadded hex of length ' + hl);\n    const array = new Uint8Array(al);\n    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n        const n1 = asciiToBase16(hex.charCodeAt(hi));\n        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n        if (n1 === undefined || n2 === undefined) {\n            const char = hex[hi] + hex[hi + 1];\n            throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n        }\n        array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163\n    }\n    return array;\n}\n/**\n * There is no setImmediate in browser and setTimeout is slow.\n * Call of async fn will return Promise, which will be fullfiled only on\n * next scheduler queue processing step and this is exactly what we need.\n */\nexport const nextTick = async () => { };\n/** Returns control to thread each 'tick' ms to avoid blocking. */\nexport async function asyncLoop(iters, tick, cb) {\n    let ts = Date.now();\n    for (let i = 0; i < iters; i++) {\n        cb(i);\n        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n        const diff = Date.now() - ts;\n        if (diff >= 0 && diff < tick)\n            continue;\n        await nextTick();\n        ts += diff;\n    }\n}\n/**\n * Converts string to bytes using UTF8 encoding.\n * @example utf8ToBytes('abc') // Uint8Array.from([97, 98, 99])\n */\nexport function utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error('string expected');\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n/**\n * Converts bytes to string using UTF8 encoding.\n * @example bytesToUtf8(Uint8Array.from([97, 98, 99])) // 'abc'\n */\nexport function bytesToUtf8(bytes) {\n    return new TextDecoder().decode(bytes);\n}\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nexport function toBytes(data) {\n    if (typeof data === 'string')\n        data = utf8ToBytes(data);\n    abytes(data);\n    return data;\n}\n/**\n * Helper for KDFs: consumes uint8array or string.\n * When string is passed, does utf8 decoding, using TextDecoder.\n */\nexport function kdfInputToBytes(data) {\n    if (typeof data === 'string')\n        data = utf8ToBytes(data);\n    abytes(data);\n    return data;\n}\n/** Copies several Uint8Arrays into one. */\nexport function concatBytes(...arrays) {\n    let sum = 0;\n    for (let i = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        abytes(a);\n        sum += a.length;\n    }\n    const res = new Uint8Array(sum);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        res.set(a, pad);\n        pad += a.length;\n    }\n    return res;\n}\nexport function checkOpts(defaults, opts) {\n    if (opts !== undefined && {}.toString.call(opts) !== '[object Object]')\n        throw new Error('options should be object or undefined');\n    const merged = Object.assign(defaults, opts);\n    return merged;\n}\n/** For runtime check if class implements interface */\nexport class Hash {\n}\n/** Wraps hash function, creating an interface on top of it */\nexport function createHasher(hashCons) {\n    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();\n    const tmp = hashCons();\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = () => hashCons();\n    return hashC;\n}\nexport function createOptHasher(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\nexport function createXOFer(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\nexport const wrapConstructor = createHasher;\nexport const wrapConstructorWithOpts = createOptHasher;\nexport const wrapXOFConstructorWithOpts = createXOFer;\n/** Cryptographically secure PRNG. Uses internal OS-level `crypto.getRandomValues`. */\nexport function randomBytes(bytesLength = 32) {\n    if (crypto && typeof crypto.getRandomValues === 'function') {\n        return crypto.getRandomValues(new Uint8Array(bytesLength));\n    }\n    // Legacy Node.js compatibility\n    if (crypto && typeof crypto.randomBytes === 'function') {\n        return Uint8Array.from(crypto.randomBytes(bytesLength));\n    }\n    throw new Error('crypto.getRandomValues must be defined');\n}\n//# sourceMappingURL=utils.js.map","/**\n * Internal helpers for blake hash.\n * @module\n */\nimport { rotr } from \"./utils.js\";\n/**\n * Internal blake variable.\n * For BLAKE2b, the two extra permutations for rounds 10 and 11 are SIGMA[10..11] = SIGMA[0..1].\n */\n// prettier-ignore\nexport const BSIGMA = /* @__PURE__ */ Uint8Array.from([\n    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n    14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3,\n    11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4,\n    7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8,\n    9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13,\n    2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9,\n    12, 5, 1, 15, 14, 13, 4, 10, 0, 7, 6, 3, 9, 2, 8, 11,\n    13, 11, 7, 14, 12, 1, 3, 9, 5, 0, 15, 4, 8, 6, 2, 10,\n    6, 15, 14, 9, 11, 3, 0, 8, 12, 2, 13, 7, 1, 4, 10, 5,\n    10, 2, 8, 4, 7, 6, 1, 5, 15, 11, 9, 14, 3, 12, 13, 0,\n    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n    14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3,\n    // Blake1, unused in others\n    11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4,\n    7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8,\n    9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13,\n    2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9,\n]);\n// Mixing function G splitted in two halfs\nexport function G1s(a, b, c, d, x) {\n    a = (a + b + x) | 0;\n    d = rotr(d ^ a, 16);\n    c = (c + d) | 0;\n    b = rotr(b ^ c, 12);\n    return { a, b, c, d };\n}\nexport function G2s(a, b, c, d, x) {\n    a = (a + b + x) | 0;\n    d = rotr(d ^ a, 8);\n    c = (c + d) | 0;\n    b = rotr(b ^ c, 7);\n    return { a, b, c, d };\n}\n//# sourceMappingURL=_blake.js.map","/**\n * Internal Merkle-Damgard hash utils.\n * @module\n */\nimport { Hash, abytes, aexists, aoutput, clean, createView, toBytes } from \"./utils.js\";\n/** Polyfill for Safari 14. https://caniuse.com/mdn-javascript_builtins_dataview_setbiguint64 */\nexport function setBigUint64(view, byteOffset, value, isLE) {\n    if (typeof view.setBigUint64 === 'function')\n        return view.setBigUint64(byteOffset, value, isLE);\n    const _32n = BigInt(32);\n    const _u32_max = BigInt(0xffffffff);\n    const wh = Number((value >> _32n) & _u32_max);\n    const wl = Number(value & _u32_max);\n    const h = isLE ? 4 : 0;\n    const l = isLE ? 0 : 4;\n    view.setUint32(byteOffset + h, wh, isLE);\n    view.setUint32(byteOffset + l, wl, isLE);\n}\n/** Choice: a ? b : c */\nexport function Chi(a, b, c) {\n    return (a & b) ^ (~a & c);\n}\n/** Majority function, true if any two inputs is true. */\nexport function Maj(a, b, c) {\n    return (a & b) ^ (a & c) ^ (b & c);\n}\n/**\n * Merkle-Damgard hash construction base class.\n * Could be used to create MD5, RIPEMD, SHA1, SHA2.\n */\nexport class HashMD extends Hash {\n    constructor(blockLen, outputLen, padOffset, isLE) {\n        super();\n        this.finished = false;\n        this.length = 0;\n        this.pos = 0;\n        this.destroyed = false;\n        this.blockLen = blockLen;\n        this.outputLen = outputLen;\n        this.padOffset = padOffset;\n        this.isLE = isLE;\n        this.buffer = new Uint8Array(blockLen);\n        this.view = createView(this.buffer);\n    }\n    update(data) {\n        aexists(this);\n        data = toBytes(data);\n        abytes(data);\n        const { view, buffer, blockLen } = this;\n        const len = data.length;\n        for (let pos = 0; pos < len;) {\n            const take = Math.min(blockLen - this.pos, len - pos);\n            // Fast path: we have at least one block in input, cast it to view and process\n            if (take === blockLen) {\n                const dataView = createView(data);\n                for (; blockLen <= len - pos; pos += blockLen)\n                    this.process(dataView, pos);\n                continue;\n            }\n            buffer.set(data.subarray(pos, pos + take), this.pos);\n            this.pos += take;\n            pos += take;\n            if (this.pos === blockLen) {\n                this.process(view, 0);\n                this.pos = 0;\n            }\n        }\n        this.length += data.length;\n        this.roundClean();\n        return this;\n    }\n    digestInto(out) {\n        aexists(this);\n        aoutput(out, this);\n        this.finished = true;\n        // Padding\n        // We can avoid allocation of buffer for padding completely if it\n        // was previously not allocated here. But it won't change performance.\n        const { buffer, view, blockLen, isLE } = this;\n        let { pos } = this;\n        // append the bit '1' to the message\n        buffer[pos++] = 0b10000000;\n        clean(this.buffer.subarray(pos));\n        // we have less than padOffset left in buffer, so we cannot put length in\n        // current block, need process it and pad again\n        if (this.padOffset > blockLen - pos) {\n            this.process(view, 0);\n            pos = 0;\n        }\n        // Pad until full block byte with zeros\n        for (let i = pos; i < blockLen; i++)\n            buffer[i] = 0;\n        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n        // So we just write lowest 64 bits of that value.\n        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n        this.process(view, 0);\n        const oview = createView(out);\n        const len = this.outputLen;\n        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n        if (len % 4)\n            throw new Error('_sha2: outputLen should be aligned to 32bit');\n        const outLen = len / 4;\n        const state = this.get();\n        if (outLen > state.length)\n            throw new Error('_sha2: outputLen bigger than state');\n        for (let i = 0; i < outLen; i++)\n            oview.setUint32(4 * i, state[i], isLE);\n    }\n    digest() {\n        const { buffer, outputLen } = this;\n        this.digestInto(buffer);\n        const res = buffer.slice(0, outputLen);\n        this.destroy();\n        return res;\n    }\n    _cloneInto(to) {\n        to || (to = new this.constructor());\n        to.set(...this.get());\n        const { blockLen, buffer, length, finished, destroyed, pos } = this;\n        to.destroyed = destroyed;\n        to.finished = finished;\n        to.length = length;\n        to.pos = pos;\n        if (length % blockLen)\n            to.buffer.set(buffer);\n        return to;\n    }\n    clone() {\n        return this._cloneInto();\n    }\n}\n/**\n * Initial SHA-2 state: fractional parts of square roots of first 16 primes 2..53.\n * Check out `test/misc/sha2-gen-iv.js` for recomputation guide.\n */\n/** Initial SHA256 state. Bits 0..32 of frac part of sqrt of primes 2..19 */\nexport const SHA256_IV = /* @__PURE__ */ Uint32Array.from([\n    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19,\n]);\n/** Initial SHA224 state. Bits 32..64 of frac part of sqrt of primes 23..53 */\nexport const SHA224_IV = /* @__PURE__ */ Uint32Array.from([\n    0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939, 0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4,\n]);\n/** Initial SHA384 state. Bits 0..64 of frac part of sqrt of primes 23..53 */\nexport const SHA384_IV = /* @__PURE__ */ Uint32Array.from([\n    0xcbbb9d5d, 0xc1059ed8, 0x629a292a, 0x367cd507, 0x9159015a, 0x3070dd17, 0x152fecd8, 0xf70e5939,\n    0x67332667, 0xffc00b31, 0x8eb44a87, 0x68581511, 0xdb0c2e0d, 0x64f98fa7, 0x47b5481d, 0xbefa4fa4,\n]);\n/** Initial SHA512 state. Bits 0..64 of frac part of sqrt of primes 2..19 */\nexport const SHA512_IV = /* @__PURE__ */ Uint32Array.from([\n    0x6a09e667, 0xf3bcc908, 0xbb67ae85, 0x84caa73b, 0x3c6ef372, 0xfe94f82b, 0xa54ff53a, 0x5f1d36f1,\n    0x510e527f, 0xade682d1, 0x9b05688c, 0x2b3e6c1f, 0x1f83d9ab, 0xfb41bd6b, 0x5be0cd19, 0x137e2179,\n]);\n//# sourceMappingURL=_md.js.map","/**\n * Internal helpers for u64. BigUint64Array is too slow as per 2025, so we implement it using Uint32Array.\n * @todo re-check https://issues.chromium.org/issues/42212588\n * @module\n */\nconst U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);\nconst _32n = /* @__PURE__ */ BigInt(32);\nfunction fromBig(n, le = false) {\n    if (le)\n        return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };\n    return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };\n}\nfunction split(lst, le = false) {\n    const len = lst.length;\n    let Ah = new Uint32Array(len);\n    let Al = new Uint32Array(len);\n    for (let i = 0; i < len; i++) {\n        const { h, l } = fromBig(lst[i], le);\n        [Ah[i], Al[i]] = [h, l];\n    }\n    return [Ah, Al];\n}\nconst toBig = (h, l) => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);\n// for Shift in [0, 32)\nconst shrSH = (h, _l, s) => h >>> s;\nconst shrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in [1, 32)\nconst rotrSH = (h, l, s) => (h >>> s) | (l << (32 - s));\nconst rotrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotrBH = (h, l, s) => (h << (64 - s)) | (l >>> (s - 32));\nconst rotrBL = (h, l, s) => (h >>> (s - 32)) | (l << (64 - s));\n// Right rotate for shift===32 (just swaps l&h)\nconst rotr32H = (_h, l) => l;\nconst rotr32L = (h, _l) => h;\n// Left rotate for Shift in [1, 32)\nconst rotlSH = (h, l, s) => (h << s) | (l >>> (32 - s));\nconst rotlSL = (h, l, s) => (l << s) | (h >>> (32 - s));\n// Left rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotlBH = (h, l, s) => (l << (s - 32)) | (h >>> (64 - s));\nconst rotlBL = (h, l, s) => (h << (s - 32)) | (l >>> (64 - s));\n// JS uses 32-bit signed integers for bitwise operations which means we cannot\n// simple take carry out of low bit sum by shift, we need to use division.\nfunction add(Ah, Al, Bh, Bl) {\n    const l = (Al >>> 0) + (Bl >>> 0);\n    return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };\n}\n// Addition with more than 2 elements\nconst add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);\nconst add3H = (low, Ah, Bh, Ch) => (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;\nconst add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);\nconst add4H = (low, Ah, Bh, Ch, Dh) => (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;\nconst add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);\nconst add5H = (low, Ah, Bh, Ch, Dh, Eh) => (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;\n// prettier-ignore\nexport { add, add3H, add3L, add4H, add4L, add5H, add5L, fromBig, rotlBH, rotlBL, rotlSH, rotlSL, rotr32H, rotr32L, rotrBH, rotrBL, rotrSH, rotrSL, shrSH, shrSL, split, toBig };\n// prettier-ignore\nconst u64 = {\n    fromBig, split, toBig,\n    shrSH, shrSL,\n    rotrSH, rotrSL, rotrBH, rotrBL,\n    rotr32H, rotr32L,\n    rotlSH, rotlSL, rotlBH, rotlBL,\n    add, add3L, add3H, add4L, add4H, add5H, add5L,\n};\nexport default u64;\n//# sourceMappingURL=_u64.js.map","/**\n * blake2b (64-bit) & blake2s (8 to 32-bit) hash functions.\n * b could have been faster, but there is no fast u64 in js, so s is 1.5x faster.\n * @module\n */\nimport { BSIGMA, G1s, G2s } from \"./_blake.js\";\nimport { SHA256_IV } from \"./_md.js\";\nimport * as u64 from \"./_u64.js\";\n// prettier-ignore\nimport { abytes, aexists, anumber, aoutput, clean, createOptHasher, Hash, swap32IfBE, swap8IfBE, toBytes, u32 } from \"./utils.js\";\n// Same as SHA512_IV, but swapped endianness: LE instead of BE. iv[1] is iv[0], etc.\nconst B2B_IV = /* @__PURE__ */ Uint32Array.from([\n    0xf3bcc908, 0x6a09e667, 0x84caa73b, 0xbb67ae85, 0xfe94f82b, 0x3c6ef372, 0x5f1d36f1, 0xa54ff53a,\n    0xade682d1, 0x510e527f, 0x2b3e6c1f, 0x9b05688c, 0xfb41bd6b, 0x1f83d9ab, 0x137e2179, 0x5be0cd19,\n]);\n// Temporary buffer\nconst BBUF = /* @__PURE__ */ new Uint32Array(32);\n// Mixing function G splitted in two halfs\nfunction G1b(a, b, c, d, msg, x) {\n    // NOTE: V is LE here\n    const Xl = msg[x], Xh = msg[x + 1]; // prettier-ignore\n    let Al = BBUF[2 * a], Ah = BBUF[2 * a + 1]; // prettier-ignore\n    let Bl = BBUF[2 * b], Bh = BBUF[2 * b + 1]; // prettier-ignore\n    let Cl = BBUF[2 * c], Ch = BBUF[2 * c + 1]; // prettier-ignore\n    let Dl = BBUF[2 * d], Dh = BBUF[2 * d + 1]; // prettier-ignore\n    // v[a] = (v[a] + v[b] + x) | 0;\n    let ll = u64.add3L(Al, Bl, Xl);\n    Ah = u64.add3H(ll, Ah, Bh, Xh);\n    Al = ll | 0;\n    // v[d] = rotr(v[d] ^ v[a], 32)\n    ({ Dh, Dl } = { Dh: Dh ^ Ah, Dl: Dl ^ Al });\n    ({ Dh, Dl } = { Dh: u64.rotr32H(Dh, Dl), Dl: u64.rotr32L(Dh, Dl) });\n    // v[c] = (v[c] + v[d]) | 0;\n    ({ h: Ch, l: Cl } = u64.add(Ch, Cl, Dh, Dl));\n    // v[b] = rotr(v[b] ^ v[c], 24)\n    ({ Bh, Bl } = { Bh: Bh ^ Ch, Bl: Bl ^ Cl });\n    ({ Bh, Bl } = { Bh: u64.rotrSH(Bh, Bl, 24), Bl: u64.rotrSL(Bh, Bl, 24) });\n    (BBUF[2 * a] = Al), (BBUF[2 * a + 1] = Ah);\n    (BBUF[2 * b] = Bl), (BBUF[2 * b + 1] = Bh);\n    (BBUF[2 * c] = Cl), (BBUF[2 * c + 1] = Ch);\n    (BBUF[2 * d] = Dl), (BBUF[2 * d + 1] = Dh);\n}\nfunction G2b(a, b, c, d, msg, x) {\n    // NOTE: V is LE here\n    const Xl = msg[x], Xh = msg[x + 1]; // prettier-ignore\n    let Al = BBUF[2 * a], Ah = BBUF[2 * a + 1]; // prettier-ignore\n    let Bl = BBUF[2 * b], Bh = BBUF[2 * b + 1]; // prettier-ignore\n    let Cl = BBUF[2 * c], Ch = BBUF[2 * c + 1]; // prettier-ignore\n    let Dl = BBUF[2 * d], Dh = BBUF[2 * d + 1]; // prettier-ignore\n    // v[a] = (v[a] + v[b] + x) | 0;\n    let ll = u64.add3L(Al, Bl, Xl);\n    Ah = u64.add3H(ll, Ah, Bh, Xh);\n    Al = ll | 0;\n    // v[d] = rotr(v[d] ^ v[a], 16)\n    ({ Dh, Dl } = { Dh: Dh ^ Ah, Dl: Dl ^ Al });\n    ({ Dh, Dl } = { Dh: u64.rotrSH(Dh, Dl, 16), Dl: u64.rotrSL(Dh, Dl, 16) });\n    // v[c] = (v[c] + v[d]) | 0;\n    ({ h: Ch, l: Cl } = u64.add(Ch, Cl, Dh, Dl));\n    // v[b] = rotr(v[b] ^ v[c], 63)\n    ({ Bh, Bl } = { Bh: Bh ^ Ch, Bl: Bl ^ Cl });\n    ({ Bh, Bl } = { Bh: u64.rotrBH(Bh, Bl, 63), Bl: u64.rotrBL(Bh, Bl, 63) });\n    (BBUF[2 * a] = Al), (BBUF[2 * a + 1] = Ah);\n    (BBUF[2 * b] = Bl), (BBUF[2 * b + 1] = Bh);\n    (BBUF[2 * c] = Cl), (BBUF[2 * c + 1] = Ch);\n    (BBUF[2 * d] = Dl), (BBUF[2 * d + 1] = Dh);\n}\nfunction checkBlake2Opts(outputLen, opts = {}, keyLen, saltLen, persLen) {\n    anumber(keyLen);\n    if (outputLen < 0 || outputLen > keyLen)\n        throw new Error('outputLen bigger than keyLen');\n    const { key, salt, personalization } = opts;\n    if (key !== undefined && (key.length < 1 || key.length > keyLen))\n        throw new Error('key length must be undefined or 1..' + keyLen);\n    if (salt !== undefined && salt.length !== saltLen)\n        throw new Error('salt must be undefined or ' + saltLen);\n    if (personalization !== undefined && personalization.length !== persLen)\n        throw new Error('personalization must be undefined or ' + persLen);\n}\n/** Class, from which others are subclassed. */\nexport class BLAKE2 extends Hash {\n    constructor(blockLen, outputLen) {\n        super();\n        this.finished = false;\n        this.destroyed = false;\n        this.length = 0;\n        this.pos = 0;\n        anumber(blockLen);\n        anumber(outputLen);\n        this.blockLen = blockLen;\n        this.outputLen = outputLen;\n        this.buffer = new Uint8Array(blockLen);\n        this.buffer32 = u32(this.buffer);\n    }\n    update(data) {\n        aexists(this);\n        data = toBytes(data);\n        abytes(data);\n        // Main difference with other hashes: there is flag for last block,\n        // so we cannot process current block before we know that there\n        // is the next one. This significantly complicates logic and reduces ability\n        // to do zero-copy processing\n        const { blockLen, buffer, buffer32 } = this;\n        const len = data.length;\n        const offset = data.byteOffset;\n        const buf = data.buffer;\n        for (let pos = 0; pos < len;) {\n            // If buffer is full and we still have input (don't process last block, same as blake2s)\n            if (this.pos === blockLen) {\n                swap32IfBE(buffer32);\n                this.compress(buffer32, 0, false);\n                swap32IfBE(buffer32);\n                this.pos = 0;\n            }\n            const take = Math.min(blockLen - this.pos, len - pos);\n            const dataOffset = offset + pos;\n            // full block && aligned to 4 bytes && not last in input\n            if (take === blockLen && !(dataOffset % 4) && pos + take < len) {\n                const data32 = new Uint32Array(buf, dataOffset, Math.floor((len - pos) / 4));\n                swap32IfBE(data32);\n                for (let pos32 = 0; pos + blockLen < len; pos32 += buffer32.length, pos += blockLen) {\n                    this.length += blockLen;\n                    this.compress(data32, pos32, false);\n                }\n                swap32IfBE(data32);\n                continue;\n            }\n            buffer.set(data.subarray(pos, pos + take), this.pos);\n            this.pos += take;\n            this.length += take;\n            pos += take;\n        }\n        return this;\n    }\n    digestInto(out) {\n        aexists(this);\n        aoutput(out, this);\n        const { pos, buffer32 } = this;\n        this.finished = true;\n        // Padding\n        clean(this.buffer.subarray(pos));\n        swap32IfBE(buffer32);\n        this.compress(buffer32, 0, true);\n        swap32IfBE(buffer32);\n        const out32 = u32(out);\n        this.get().forEach((v, i) => (out32[i] = swap8IfBE(v)));\n    }\n    digest() {\n        const { buffer, outputLen } = this;\n        this.digestInto(buffer);\n        const res = buffer.slice(0, outputLen);\n        this.destroy();\n        return res;\n    }\n    _cloneInto(to) {\n        const { buffer, length, finished, destroyed, outputLen, pos } = this;\n        to || (to = new this.constructor({ dkLen: outputLen }));\n        to.set(...this.get());\n        to.buffer.set(buffer);\n        to.destroyed = destroyed;\n        to.finished = finished;\n        to.length = length;\n        to.pos = pos;\n        // @ts-ignore\n        to.outputLen = outputLen;\n        return to;\n    }\n    clone() {\n        return this._cloneInto();\n    }\n}\nexport class BLAKE2b extends BLAKE2 {\n    constructor(opts = {}) {\n        const olen = opts.dkLen === undefined ? 64 : opts.dkLen;\n        super(128, olen);\n        // Same as SHA-512, but LE\n        this.v0l = B2B_IV[0] | 0;\n        this.v0h = B2B_IV[1] | 0;\n        this.v1l = B2B_IV[2] | 0;\n        this.v1h = B2B_IV[3] | 0;\n        this.v2l = B2B_IV[4] | 0;\n        this.v2h = B2B_IV[5] | 0;\n        this.v3l = B2B_IV[6] | 0;\n        this.v3h = B2B_IV[7] | 0;\n        this.v4l = B2B_IV[8] | 0;\n        this.v4h = B2B_IV[9] | 0;\n        this.v5l = B2B_IV[10] | 0;\n        this.v5h = B2B_IV[11] | 0;\n        this.v6l = B2B_IV[12] | 0;\n        this.v6h = B2B_IV[13] | 0;\n        this.v7l = B2B_IV[14] | 0;\n        this.v7h = B2B_IV[15] | 0;\n        checkBlake2Opts(olen, opts, 64, 16, 16);\n        let { key, personalization, salt } = opts;\n        let keyLength = 0;\n        if (key !== undefined) {\n            key = toBytes(key);\n            keyLength = key.length;\n        }\n        this.v0l ^= this.outputLen | (keyLength << 8) | (0x01 << 16) | (0x01 << 24);\n        if (salt !== undefined) {\n            salt = toBytes(salt);\n            const slt = u32(salt);\n            this.v4l ^= swap8IfBE(slt[0]);\n            this.v4h ^= swap8IfBE(slt[1]);\n            this.v5l ^= swap8IfBE(slt[2]);\n            this.v5h ^= swap8IfBE(slt[3]);\n        }\n        if (personalization !== undefined) {\n            personalization = toBytes(personalization);\n            const pers = u32(personalization);\n            this.v6l ^= swap8IfBE(pers[0]);\n            this.v6h ^= swap8IfBE(pers[1]);\n            this.v7l ^= swap8IfBE(pers[2]);\n            this.v7h ^= swap8IfBE(pers[3]);\n        }\n        if (key !== undefined) {\n            // Pad to blockLen and update\n            const tmp = new Uint8Array(this.blockLen);\n            tmp.set(key);\n            this.update(tmp);\n        }\n    }\n    // prettier-ignore\n    get() {\n        let { v0l, v0h, v1l, v1h, v2l, v2h, v3l, v3h, v4l, v4h, v5l, v5h, v6l, v6h, v7l, v7h } = this;\n        return [v0l, v0h, v1l, v1h, v2l, v2h, v3l, v3h, v4l, v4h, v5l, v5h, v6l, v6h, v7l, v7h];\n    }\n    // prettier-ignore\n    set(v0l, v0h, v1l, v1h, v2l, v2h, v3l, v3h, v4l, v4h, v5l, v5h, v6l, v6h, v7l, v7h) {\n        this.v0l = v0l | 0;\n        this.v0h = v0h | 0;\n        this.v1l = v1l | 0;\n        this.v1h = v1h | 0;\n        this.v2l = v2l | 0;\n        this.v2h = v2h | 0;\n        this.v3l = v3l | 0;\n        this.v3h = v3h | 0;\n        this.v4l = v4l | 0;\n        this.v4h = v4h | 0;\n        this.v5l = v5l | 0;\n        this.v5h = v5h | 0;\n        this.v6l = v6l | 0;\n        this.v6h = v6h | 0;\n        this.v7l = v7l | 0;\n        this.v7h = v7h | 0;\n    }\n    compress(msg, offset, isLast) {\n        this.get().forEach((v, i) => (BBUF[i] = v)); // First half from state.\n        BBUF.set(B2B_IV, 16); // Second half from IV.\n        let { h, l } = u64.fromBig(BigInt(this.length));\n        BBUF[24] = B2B_IV[8] ^ l; // Low word of the offset.\n        BBUF[25] = B2B_IV[9] ^ h; // High word.\n        // Invert all bits for last block\n        if (isLast) {\n            BBUF[28] = ~BBUF[28];\n            BBUF[29] = ~BBUF[29];\n        }\n        let j = 0;\n        const s = BSIGMA;\n        for (let i = 0; i < 12; i++) {\n            G1b(0, 4, 8, 12, msg, offset + 2 * s[j++]);\n            G2b(0, 4, 8, 12, msg, offset + 2 * s[j++]);\n            G1b(1, 5, 9, 13, msg, offset + 2 * s[j++]);\n            G2b(1, 5, 9, 13, msg, offset + 2 * s[j++]);\n            G1b(2, 6, 10, 14, msg, offset + 2 * s[j++]);\n            G2b(2, 6, 10, 14, msg, offset + 2 * s[j++]);\n            G1b(3, 7, 11, 15, msg, offset + 2 * s[j++]);\n            G2b(3, 7, 11, 15, msg, offset + 2 * s[j++]);\n            G1b(0, 5, 10, 15, msg, offset + 2 * s[j++]);\n            G2b(0, 5, 10, 15, msg, offset + 2 * s[j++]);\n            G1b(1, 6, 11, 12, msg, offset + 2 * s[j++]);\n            G2b(1, 6, 11, 12, msg, offset + 2 * s[j++]);\n            G1b(2, 7, 8, 13, msg, offset + 2 * s[j++]);\n            G2b(2, 7, 8, 13, msg, offset + 2 * s[j++]);\n            G1b(3, 4, 9, 14, msg, offset + 2 * s[j++]);\n            G2b(3, 4, 9, 14, msg, offset + 2 * s[j++]);\n        }\n        this.v0l ^= BBUF[0] ^ BBUF[16];\n        this.v0h ^= BBUF[1] ^ BBUF[17];\n        this.v1l ^= BBUF[2] ^ BBUF[18];\n        this.v1h ^= BBUF[3] ^ BBUF[19];\n        this.v2l ^= BBUF[4] ^ BBUF[20];\n        this.v2h ^= BBUF[5] ^ BBUF[21];\n        this.v3l ^= BBUF[6] ^ BBUF[22];\n        this.v3h ^= BBUF[7] ^ BBUF[23];\n        this.v4l ^= BBUF[8] ^ BBUF[24];\n        this.v4h ^= BBUF[9] ^ BBUF[25];\n        this.v5l ^= BBUF[10] ^ BBUF[26];\n        this.v5h ^= BBUF[11] ^ BBUF[27];\n        this.v6l ^= BBUF[12] ^ BBUF[28];\n        this.v6h ^= BBUF[13] ^ BBUF[29];\n        this.v7l ^= BBUF[14] ^ BBUF[30];\n        this.v7h ^= BBUF[15] ^ BBUF[31];\n        clean(BBUF);\n    }\n    destroy() {\n        this.destroyed = true;\n        clean(this.buffer32);\n        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n    }\n}\n/**\n * Blake2b hash function. 64-bit. 1.5x slower than blake2s in JS.\n * @param msg - message that would be hashed\n * @param opts - dkLen output length, key for MAC mode, salt, personalization\n */\nexport const blake2b = /* @__PURE__ */ createOptHasher((opts) => new BLAKE2b(opts));\n// prettier-ignore\nexport function compress(s, offset, msg, rounds, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15) {\n    let j = 0;\n    for (let i = 0; i < rounds; i++) {\n        ({ a: v0, b: v4, c: v8, d: v12 } = G1s(v0, v4, v8, v12, msg[offset + s[j++]]));\n        ({ a: v0, b: v4, c: v8, d: v12 } = G2s(v0, v4, v8, v12, msg[offset + s[j++]]));\n        ({ a: v1, b: v5, c: v9, d: v13 } = G1s(v1, v5, v9, v13, msg[offset + s[j++]]));\n        ({ a: v1, b: v5, c: v9, d: v13 } = G2s(v1, v5, v9, v13, msg[offset + s[j++]]));\n        ({ a: v2, b: v6, c: v10, d: v14 } = G1s(v2, v6, v10, v14, msg[offset + s[j++]]));\n        ({ a: v2, b: v6, c: v10, d: v14 } = G2s(v2, v6, v10, v14, msg[offset + s[j++]]));\n        ({ a: v3, b: v7, c: v11, d: v15 } = G1s(v3, v7, v11, v15, msg[offset + s[j++]]));\n        ({ a: v3, b: v7, c: v11, d: v15 } = G2s(v3, v7, v11, v15, msg[offset + s[j++]]));\n        ({ a: v0, b: v5, c: v10, d: v15 } = G1s(v0, v5, v10, v15, msg[offset + s[j++]]));\n        ({ a: v0, b: v5, c: v10, d: v15 } = G2s(v0, v5, v10, v15, msg[offset + s[j++]]));\n        ({ a: v1, b: v6, c: v11, d: v12 } = G1s(v1, v6, v11, v12, msg[offset + s[j++]]));\n        ({ a: v1, b: v6, c: v11, d: v12 } = G2s(v1, v6, v11, v12, msg[offset + s[j++]]));\n        ({ a: v2, b: v7, c: v8, d: v13 } = G1s(v2, v7, v8, v13, msg[offset + s[j++]]));\n        ({ a: v2, b: v7, c: v8, d: v13 } = G2s(v2, v7, v8, v13, msg[offset + s[j++]]));\n        ({ a: v3, b: v4, c: v9, d: v14 } = G1s(v3, v4, v9, v14, msg[offset + s[j++]]));\n        ({ a: v3, b: v4, c: v9, d: v14 } = G2s(v3, v4, v9, v14, msg[offset + s[j++]]));\n    }\n    return { v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15 };\n}\nconst B2S_IV = SHA256_IV;\nexport class BLAKE2s extends BLAKE2 {\n    constructor(opts = {}) {\n        const olen = opts.dkLen === undefined ? 32 : opts.dkLen;\n        super(64, olen);\n        // Internal state, same as SHA-256\n        this.v0 = B2S_IV[0] | 0;\n        this.v1 = B2S_IV[1] | 0;\n        this.v2 = B2S_IV[2] | 0;\n        this.v3 = B2S_IV[3] | 0;\n        this.v4 = B2S_IV[4] | 0;\n        this.v5 = B2S_IV[5] | 0;\n        this.v6 = B2S_IV[6] | 0;\n        this.v7 = B2S_IV[7] | 0;\n        checkBlake2Opts(olen, opts, 32, 8, 8);\n        let { key, personalization, salt } = opts;\n        let keyLength = 0;\n        if (key !== undefined) {\n            key = toBytes(key);\n            keyLength = key.length;\n        }\n        this.v0 ^= this.outputLen | (keyLength << 8) | (0x01 << 16) | (0x01 << 24);\n        if (salt !== undefined) {\n            salt = toBytes(salt);\n            const slt = u32(salt);\n            this.v4 ^= swap8IfBE(slt[0]);\n            this.v5 ^= swap8IfBE(slt[1]);\n        }\n        if (personalization !== undefined) {\n            personalization = toBytes(personalization);\n            const pers = u32(personalization);\n            this.v6 ^= swap8IfBE(pers[0]);\n            this.v7 ^= swap8IfBE(pers[1]);\n        }\n        if (key !== undefined) {\n            // Pad to blockLen and update\n            abytes(key);\n            const tmp = new Uint8Array(this.blockLen);\n            tmp.set(key);\n            this.update(tmp);\n        }\n    }\n    get() {\n        const { v0, v1, v2, v3, v4, v5, v6, v7 } = this;\n        return [v0, v1, v2, v3, v4, v5, v6, v7];\n    }\n    // prettier-ignore\n    set(v0, v1, v2, v3, v4, v5, v6, v7) {\n        this.v0 = v0 | 0;\n        this.v1 = v1 | 0;\n        this.v2 = v2 | 0;\n        this.v3 = v3 | 0;\n        this.v4 = v4 | 0;\n        this.v5 = v5 | 0;\n        this.v6 = v6 | 0;\n        this.v7 = v7 | 0;\n    }\n    compress(msg, offset, isLast) {\n        const { h, l } = u64.fromBig(BigInt(this.length));\n        // prettier-ignore\n        const { v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15 } = compress(BSIGMA, offset, msg, 10, this.v0, this.v1, this.v2, this.v3, this.v4, this.v5, this.v6, this.v7, B2S_IV[0], B2S_IV[1], B2S_IV[2], B2S_IV[3], l ^ B2S_IV[4], h ^ B2S_IV[5], isLast ? ~B2S_IV[6] : B2S_IV[6], B2S_IV[7]);\n        this.v0 ^= v0 ^ v8;\n        this.v1 ^= v1 ^ v9;\n        this.v2 ^= v2 ^ v10;\n        this.v3 ^= v3 ^ v11;\n        this.v4 ^= v4 ^ v12;\n        this.v5 ^= v5 ^ v13;\n        this.v6 ^= v6 ^ v14;\n        this.v7 ^= v7 ^ v15;\n    }\n    destroy() {\n        this.destroyed = true;\n        clean(this.buffer32);\n        this.set(0, 0, 0, 0, 0, 0, 0, 0);\n    }\n}\n/**\n * Blake2s hash function. Focuses on 8-bit to 32-bit platforms. 1.5x faster than blake2b in JS.\n * @param msg - message that would be hashed\n * @param opts - dkLen output length, key for MAC mode, salt, personalization\n */\nexport const blake2s = /* @__PURE__ */ createOptHasher((opts) => new BLAKE2s(opts));\n//# sourceMappingURL=blake2.js.map","/**\n * Blake2b hash function. Focuses on 64-bit platforms, but in JS speed different from Blake2s is negligible.\n * @module\n * @deprecated\n */\nimport { BLAKE2b as B2B, blake2b as b2b } from \"./blake2.js\";\n/** @deprecated Use import from `noble/hashes/blake2` module */\nexport const BLAKE2b = B2B;\n/** @deprecated Use import from `noble/hashes/blake2` module */\nexport const blake2b = b2b;\n//# sourceMappingURL=blake2b.js.map","import { splitGenericParameters } from \"@mysten/bcs\";\nimport { normalizeSuiAddress } from \"../utils/sui-types.js\";\nconst VECTOR_REGEX = /^vector<(.+)>$/;\nconst STRUCT_REGEX = /^([^:]+)::([^:]+)::([^<]+)(<(.+)>)?/;\nclass TypeTagSerializer {\n  static parseFromStr(str, normalizeAddress = false) {\n    if (str === \"address\") {\n      return { address: null };\n    } else if (str === \"bool\") {\n      return { bool: null };\n    } else if (str === \"u8\") {\n      return { u8: null };\n    } else if (str === \"u16\") {\n      return { u16: null };\n    } else if (str === \"u32\") {\n      return { u32: null };\n    } else if (str === \"u64\") {\n      return { u64: null };\n    } else if (str === \"u128\") {\n      return { u128: null };\n    } else if (str === \"u256\") {\n      return { u256: null };\n    } else if (str === \"signer\") {\n      return { signer: null };\n    }\n    const vectorMatch = str.match(VECTOR_REGEX);\n    if (vectorMatch) {\n      return {\n        vector: TypeTagSerializer.parseFromStr(vectorMatch[1], normalizeAddress)\n      };\n    }\n    const structMatch = str.match(STRUCT_REGEX);\n    if (structMatch) {\n      const address = normalizeAddress ? normalizeSuiAddress(structMatch[1]) : structMatch[1];\n      return {\n        struct: {\n          address,\n          module: structMatch[2],\n          name: structMatch[3],\n          typeParams: structMatch[5] === void 0 ? [] : TypeTagSerializer.parseStructTypeArgs(structMatch[5], normalizeAddress)\n        }\n      };\n    }\n    throw new Error(`Encountered unexpected token when parsing type args for ${str}`);\n  }\n  static parseStructTypeArgs(str, normalizeAddress = false) {\n    return splitGenericParameters(str).map(\n      (tok) => TypeTagSerializer.parseFromStr(tok, normalizeAddress)\n    );\n  }\n  static tagToString(tag) {\n    if (\"bool\" in tag) {\n      return \"bool\";\n    }\n    if (\"u8\" in tag) {\n      return \"u8\";\n    }\n    if (\"u16\" in tag) {\n      return \"u16\";\n    }\n    if (\"u32\" in tag) {\n      return \"u32\";\n    }\n    if (\"u64\" in tag) {\n      return \"u64\";\n    }\n    if (\"u128\" in tag) {\n      return \"u128\";\n    }\n    if (\"u256\" in tag) {\n      return \"u256\";\n    }\n    if (\"address\" in tag) {\n      return \"address\";\n    }\n    if (\"signer\" in tag) {\n      return \"signer\";\n    }\n    if (\"vector\" in tag) {\n      return `vector<${TypeTagSerializer.tagToString(tag.vector)}>`;\n    }\n    if (\"struct\" in tag) {\n      const struct = tag.struct;\n      const typeParams = struct.typeParams.map(TypeTagSerializer.tagToString).join(\", \");\n      return `${struct.address}::${struct.module}::${struct.name}${typeParams ? `<${typeParams}>` : \"\"}`;\n    }\n    throw new Error(\"Invalid TypeTag\");\n  }\n}\nfunction normalizeTypeTag(type) {\n  return TypeTagSerializer.tagToString(TypeTagSerializer.parseFromStr(type));\n}\nexport {\n  TypeTagSerializer,\n  normalizeTypeTag\n};\n//# sourceMappingURL=type-tag-serializer.js.map\n","import { bcs, fromBase58, fromBase64, fromHex, toBase58, toBase64, toHex } from \"@mysten/bcs\";\nimport { isValidSuiAddress, normalizeSuiAddress, SUI_ADDRESS_LENGTH } from \"../utils/sui-types.js\";\nimport { TypeTagSerializer } from \"./type-tag-serializer.js\";\nfunction unsafe_u64(options) {\n  return bcs.u64({\n    name: \"unsafe_u64\",\n    ...options\n  }).transform({\n    input: (val) => val,\n    output: (val) => Number(val)\n  });\n}\nfunction optionEnum(type) {\n  return bcs.enum(\"Option\", {\n    None: null,\n    Some: type\n  });\n}\nconst Address = bcs.bytes(SUI_ADDRESS_LENGTH).transform({\n  validate: (val) => {\n    const address = typeof val === \"string\" ? val : toHex(val);\n    if (!address || !isValidSuiAddress(normalizeSuiAddress(address))) {\n      throw new Error(`Invalid Sui address ${address}`);\n    }\n  },\n  input: (val) => typeof val === \"string\" ? fromHex(normalizeSuiAddress(val)) : val,\n  output: (val) => normalizeSuiAddress(toHex(val))\n});\nconst ObjectDigest = bcs.byteVector().transform({\n  name: \"ObjectDigest\",\n  input: (value) => fromBase58(value),\n  output: (value) => toBase58(new Uint8Array(value)),\n  validate: (value) => {\n    if (fromBase58(value).length !== 32) {\n      throw new Error(\"ObjectDigest must be 32 bytes\");\n    }\n  }\n});\nconst SuiObjectRef = bcs.struct(\"SuiObjectRef\", {\n  objectId: Address,\n  version: bcs.u64(),\n  digest: ObjectDigest\n});\nconst SharedObjectRef = bcs.struct(\"SharedObjectRef\", {\n  objectId: Address,\n  initialSharedVersion: bcs.u64(),\n  mutable: bcs.bool()\n});\nconst ObjectArg = bcs.enum(\"ObjectArg\", {\n  ImmOrOwnedObject: SuiObjectRef,\n  SharedObject: SharedObjectRef,\n  Receiving: SuiObjectRef\n});\nconst Owner = bcs.enum(\"Owner\", {\n  AddressOwner: Address,\n  ObjectOwner: Address,\n  Shared: bcs.struct(\"Shared\", {\n    initialSharedVersion: bcs.u64()\n  }),\n  Immutable: null,\n  ConsensusAddressOwner: bcs.struct(\"ConsensusAddressOwner\", {\n    owner: Address,\n    startVersion: bcs.u64()\n  })\n});\nconst CallArg = bcs.enum(\"CallArg\", {\n  Pure: bcs.struct(\"Pure\", {\n    bytes: bcs.byteVector().transform({\n      input: (val) => typeof val === \"string\" ? fromBase64(val) : val,\n      output: (val) => toBase64(new Uint8Array(val))\n    })\n  }),\n  Object: ObjectArg\n});\nconst InnerTypeTag = bcs.enum(\"TypeTag\", {\n  bool: null,\n  u8: null,\n  u64: null,\n  u128: null,\n  address: null,\n  signer: null,\n  vector: bcs.lazy(() => InnerTypeTag),\n  struct: bcs.lazy(() => StructTag),\n  u16: null,\n  u32: null,\n  u256: null\n});\nconst TypeTag = InnerTypeTag.transform({\n  input: (typeTag) => typeof typeTag === \"string\" ? TypeTagSerializer.parseFromStr(typeTag, true) : typeTag,\n  output: (typeTag) => TypeTagSerializer.tagToString(typeTag)\n});\nconst Argument = bcs.enum(\"Argument\", {\n  GasCoin: null,\n  Input: bcs.u16(),\n  Result: bcs.u16(),\n  NestedResult: bcs.tuple([bcs.u16(), bcs.u16()])\n});\nconst ProgrammableMoveCall = bcs.struct(\"ProgrammableMoveCall\", {\n  package: Address,\n  module: bcs.string(),\n  function: bcs.string(),\n  typeArguments: bcs.vector(TypeTag),\n  arguments: bcs.vector(Argument)\n});\nconst Command = bcs.enum(\"Command\", {\n  /**\n   * A Move Call - any public Move function can be called via\n   * this transaction. The results can be used that instant to pass\n   * into the next transaction.\n   */\n  MoveCall: ProgrammableMoveCall,\n  /**\n   * Transfer vector of objects to a receiver.\n   */\n  TransferObjects: bcs.struct(\"TransferObjects\", {\n    objects: bcs.vector(Argument),\n    address: Argument\n  }),\n  // /**\n  //  * Split `amount` from a `coin`.\n  //  */\n  SplitCoins: bcs.struct(\"SplitCoins\", {\n    coin: Argument,\n    amounts: bcs.vector(Argument)\n  }),\n  // /**\n  //  * Merge Vector of Coins (`sources`) into a `destination`.\n  //  */\n  MergeCoins: bcs.struct(\"MergeCoins\", {\n    destination: Argument,\n    sources: bcs.vector(Argument)\n  }),\n  // /**\n  //  * Publish a Move module.\n  //  */\n  Publish: bcs.struct(\"Publish\", {\n    modules: bcs.vector(\n      bcs.byteVector().transform({\n        input: (val) => typeof val === \"string\" ? fromBase64(val) : val,\n        output: (val) => toBase64(new Uint8Array(val))\n      })\n    ),\n    dependencies: bcs.vector(Address)\n  }),\n  // /**\n  //  * Build a vector of objects using the input arguments.\n  //  * It is impossible to export construct a `vector<T: key>` otherwise,\n  //  * so this call serves a utility function.\n  //  */\n  MakeMoveVec: bcs.struct(\"MakeMoveVec\", {\n    type: optionEnum(TypeTag).transform({\n      input: (val) => val === null ? {\n        None: true\n      } : {\n        Some: val\n      },\n      output: (val) => val.Some ?? null\n    }),\n    elements: bcs.vector(Argument)\n  }),\n  Upgrade: bcs.struct(\"Upgrade\", {\n    modules: bcs.vector(\n      bcs.byteVector().transform({\n        input: (val) => typeof val === \"string\" ? fromBase64(val) : val,\n        output: (val) => toBase64(new Uint8Array(val))\n      })\n    ),\n    dependencies: bcs.vector(Address),\n    package: Address,\n    ticket: Argument\n  })\n});\nconst ProgrammableTransaction = bcs.struct(\"ProgrammableTransaction\", {\n  inputs: bcs.vector(CallArg),\n  commands: bcs.vector(Command)\n});\nconst TransactionKind = bcs.enum(\"TransactionKind\", {\n  ProgrammableTransaction,\n  ChangeEpoch: null,\n  Genesis: null,\n  ConsensusCommitPrologue: null\n});\nconst TransactionExpiration = bcs.enum(\"TransactionExpiration\", {\n  None: null,\n  Epoch: unsafe_u64()\n});\nconst StructTag = bcs.struct(\"StructTag\", {\n  address: Address,\n  module: bcs.string(),\n  name: bcs.string(),\n  typeParams: bcs.vector(InnerTypeTag)\n});\nconst GasData = bcs.struct(\"GasData\", {\n  payment: bcs.vector(SuiObjectRef),\n  owner: Address,\n  price: bcs.u64(),\n  budget: bcs.u64()\n});\nconst TransactionDataV1 = bcs.struct(\"TransactionDataV1\", {\n  kind: TransactionKind,\n  sender: Address,\n  gasData: GasData,\n  expiration: TransactionExpiration\n});\nconst TransactionData = bcs.enum(\"TransactionData\", {\n  V1: TransactionDataV1\n});\nconst IntentScope = bcs.enum(\"IntentScope\", {\n  TransactionData: null,\n  TransactionEffects: null,\n  CheckpointSummary: null,\n  PersonalMessage: null\n});\nconst IntentVersion = bcs.enum(\"IntentVersion\", {\n  V0: null\n});\nconst AppId = bcs.enum(\"AppId\", {\n  Sui: null\n});\nconst Intent = bcs.struct(\"Intent\", {\n  scope: IntentScope,\n  version: IntentVersion,\n  appId: AppId\n});\nfunction IntentMessage(T) {\n  return bcs.struct(`IntentMessage<${T.name}>`, {\n    intent: Intent,\n    value: T\n  });\n}\nconst CompressedSignature = bcs.enum(\"CompressedSignature\", {\n  ED25519: bcs.bytes(64),\n  Secp256k1: bcs.bytes(64),\n  Secp256r1: bcs.bytes(64),\n  ZkLogin: bcs.byteVector(),\n  Passkey: bcs.byteVector()\n});\nconst PublicKey = bcs.enum(\"PublicKey\", {\n  ED25519: bcs.bytes(32),\n  Secp256k1: bcs.bytes(33),\n  Secp256r1: bcs.bytes(33),\n  ZkLogin: bcs.byteVector(),\n  Passkey: bcs.bytes(33)\n});\nconst MultiSigPkMap = bcs.struct(\"MultiSigPkMap\", {\n  pubKey: PublicKey,\n  weight: bcs.u8()\n});\nconst MultiSigPublicKey = bcs.struct(\"MultiSigPublicKey\", {\n  pk_map: bcs.vector(MultiSigPkMap),\n  threshold: bcs.u16()\n});\nconst MultiSig = bcs.struct(\"MultiSig\", {\n  sigs: bcs.vector(CompressedSignature),\n  bitmap: bcs.u16(),\n  multisig_pk: MultiSigPublicKey\n});\nconst base64String = bcs.byteVector().transform({\n  input: (val) => typeof val === \"string\" ? fromBase64(val) : val,\n  output: (val) => toBase64(new Uint8Array(val))\n});\nconst SenderSignedTransaction = bcs.struct(\"SenderSignedTransaction\", {\n  intentMessage: IntentMessage(TransactionData),\n  txSignatures: bcs.vector(base64String)\n});\nconst SenderSignedData = bcs.vector(SenderSignedTransaction, {\n  name: \"SenderSignedData\"\n});\nconst PasskeyAuthenticator = bcs.struct(\"PasskeyAuthenticator\", {\n  authenticatorData: bcs.byteVector(),\n  clientDataJson: bcs.string(),\n  userSignature: bcs.byteVector()\n});\nexport {\n  Address,\n  AppId,\n  Argument,\n  CallArg,\n  Command,\n  CompressedSignature,\n  GasData,\n  Intent,\n  IntentMessage,\n  IntentScope,\n  IntentVersion,\n  MultiSig,\n  MultiSigPkMap,\n  MultiSigPublicKey,\n  ObjectArg,\n  ObjectDigest,\n  Owner,\n  PasskeyAuthenticator,\n  ProgrammableMoveCall,\n  ProgrammableTransaction,\n  PublicKey,\n  SenderSignedData,\n  SenderSignedTransaction,\n  SharedObjectRef,\n  StructTag,\n  SuiObjectRef,\n  TransactionData,\n  TransactionDataV1,\n  TransactionExpiration,\n  TransactionKind,\n  TypeTag,\n  base64String\n};\n//# sourceMappingURL=bcs.js.map\n","import { bcs } from \"@mysten/bcs\";\nimport { Address, ObjectDigest, Owner, SuiObjectRef } from \"./bcs.js\";\nconst PackageUpgradeError = bcs.enum(\"PackageUpgradeError\", {\n  UnableToFetchPackage: bcs.struct(\"UnableToFetchPackage\", { packageId: Address }),\n  NotAPackage: bcs.struct(\"NotAPackage\", { objectId: Address }),\n  IncompatibleUpgrade: null,\n  DigestDoesNotMatch: bcs.struct(\"DigestDoesNotMatch\", { digest: bcs.byteVector() }),\n  UnknownUpgradePolicy: bcs.struct(\"UnknownUpgradePolicy\", { policy: bcs.u8() }),\n  PackageIDDoesNotMatch: bcs.struct(\"PackageIDDoesNotMatch\", {\n    packageId: Address,\n    ticketId: Address\n  })\n});\nconst ModuleId = bcs.struct(\"ModuleId\", {\n  address: Address,\n  name: bcs.string()\n});\nconst MoveLocation = bcs.struct(\"MoveLocation\", {\n  module: ModuleId,\n  function: bcs.u16(),\n  instruction: bcs.u16(),\n  functionName: bcs.option(bcs.string())\n});\nconst CommandArgumentError = bcs.enum(\"CommandArgumentError\", {\n  TypeMismatch: null,\n  InvalidBCSBytes: null,\n  InvalidUsageOfPureArg: null,\n  InvalidArgumentToPrivateEntryFunction: null,\n  IndexOutOfBounds: bcs.struct(\"IndexOutOfBounds\", { idx: bcs.u16() }),\n  SecondaryIndexOutOfBounds: bcs.struct(\"SecondaryIndexOutOfBounds\", {\n    resultIdx: bcs.u16(),\n    secondaryIdx: bcs.u16()\n  }),\n  InvalidResultArity: bcs.struct(\"InvalidResultArity\", { resultIdx: bcs.u16() }),\n  InvalidGasCoinUsage: null,\n  InvalidValueUsage: null,\n  InvalidObjectByValue: null,\n  InvalidObjectByMutRef: null,\n  SharedObjectOperationNotAllowed: null\n});\nconst TypeArgumentError = bcs.enum(\"TypeArgumentError\", {\n  TypeNotFound: null,\n  ConstraintNotSatisfied: null\n});\nconst ExecutionFailureStatus = bcs.enum(\"ExecutionFailureStatus\", {\n  InsufficientGas: null,\n  InvalidGasObject: null,\n  InvariantViolation: null,\n  FeatureNotYetSupported: null,\n  MoveObjectTooBig: bcs.struct(\"MoveObjectTooBig\", {\n    objectSize: bcs.u64(),\n    maxObjectSize: bcs.u64()\n  }),\n  MovePackageTooBig: bcs.struct(\"MovePackageTooBig\", {\n    objectSize: bcs.u64(),\n    maxObjectSize: bcs.u64()\n  }),\n  CircularObjectOwnership: bcs.struct(\"CircularObjectOwnership\", { object: Address }),\n  InsufficientCoinBalance: null,\n  CoinBalanceOverflow: null,\n  PublishErrorNonZeroAddress: null,\n  SuiMoveVerificationError: null,\n  MovePrimitiveRuntimeError: bcs.option(MoveLocation),\n  MoveAbort: bcs.tuple([MoveLocation, bcs.u64()]),\n  VMVerificationOrDeserializationError: null,\n  VMInvariantViolation: null,\n  FunctionNotFound: null,\n  ArityMismatch: null,\n  TypeArityMismatch: null,\n  NonEntryFunctionInvoked: null,\n  CommandArgumentError: bcs.struct(\"CommandArgumentError\", {\n    argIdx: bcs.u16(),\n    kind: CommandArgumentError\n  }),\n  TypeArgumentError: bcs.struct(\"TypeArgumentError\", {\n    argumentIdx: bcs.u16(),\n    kind: TypeArgumentError\n  }),\n  UnusedValueWithoutDrop: bcs.struct(\"UnusedValueWithoutDrop\", {\n    resultIdx: bcs.u16(),\n    secondaryIdx: bcs.u16()\n  }),\n  InvalidPublicFunctionReturnType: bcs.struct(\"InvalidPublicFunctionReturnType\", {\n    idx: bcs.u16()\n  }),\n  InvalidTransferObject: null,\n  EffectsTooLarge: bcs.struct(\"EffectsTooLarge\", { currentSize: bcs.u64(), maxSize: bcs.u64() }),\n  PublishUpgradeMissingDependency: null,\n  PublishUpgradeDependencyDowngrade: null,\n  PackageUpgradeError: bcs.struct(\"PackageUpgradeError\", { upgradeError: PackageUpgradeError }),\n  WrittenObjectsTooLarge: bcs.struct(\"WrittenObjectsTooLarge\", {\n    currentSize: bcs.u64(),\n    maxSize: bcs.u64()\n  }),\n  CertificateDenied: null,\n  SuiMoveVerificationTimedout: null,\n  SharedObjectOperationNotAllowed: null,\n  InputObjectDeleted: null,\n  ExecutionCancelledDueToSharedObjectCongestion: bcs.struct(\n    \"ExecutionCancelledDueToSharedObjectCongestion\",\n    {\n      congestedObjects: bcs.vector(Address)\n    }\n  ),\n  AddressDeniedForCoin: bcs.struct(\"AddressDeniedForCoin\", {\n    address: Address,\n    coinType: bcs.string()\n  }),\n  CoinTypeGlobalPause: bcs.struct(\"CoinTypeGlobalPause\", { coinType: bcs.string() }),\n  ExecutionCancelledDueToRandomnessUnavailable: null\n});\nconst ExecutionStatus = bcs.enum(\"ExecutionStatus\", {\n  Success: null,\n  Failed: bcs.struct(\"ExecutionFailed\", {\n    error: ExecutionFailureStatus,\n    command: bcs.option(bcs.u64())\n  })\n});\nconst GasCostSummary = bcs.struct(\"GasCostSummary\", {\n  computationCost: bcs.u64(),\n  storageCost: bcs.u64(),\n  storageRebate: bcs.u64(),\n  nonRefundableStorageFee: bcs.u64()\n});\nconst TransactionEffectsV1 = bcs.struct(\"TransactionEffectsV1\", {\n  status: ExecutionStatus,\n  executedEpoch: bcs.u64(),\n  gasUsed: GasCostSummary,\n  modifiedAtVersions: bcs.vector(bcs.tuple([Address, bcs.u64()])),\n  sharedObjects: bcs.vector(SuiObjectRef),\n  transactionDigest: ObjectDigest,\n  created: bcs.vector(bcs.tuple([SuiObjectRef, Owner])),\n  mutated: bcs.vector(bcs.tuple([SuiObjectRef, Owner])),\n  unwrapped: bcs.vector(bcs.tuple([SuiObjectRef, Owner])),\n  deleted: bcs.vector(SuiObjectRef),\n  unwrappedThenDeleted: bcs.vector(SuiObjectRef),\n  wrapped: bcs.vector(SuiObjectRef),\n  gasObject: bcs.tuple([SuiObjectRef, Owner]),\n  eventsDigest: bcs.option(ObjectDigest),\n  dependencies: bcs.vector(ObjectDigest)\n});\nconst VersionDigest = bcs.tuple([bcs.u64(), ObjectDigest]);\nconst ObjectIn = bcs.enum(\"ObjectIn\", {\n  NotExist: null,\n  Exist: bcs.tuple([VersionDigest, Owner])\n});\nconst ObjectOut = bcs.enum(\"ObjectOut\", {\n  NotExist: null,\n  ObjectWrite: bcs.tuple([ObjectDigest, Owner]),\n  PackageWrite: VersionDigest\n});\nconst IDOperation = bcs.enum(\"IDOperation\", {\n  None: null,\n  Created: null,\n  Deleted: null\n});\nconst EffectsObjectChange = bcs.struct(\"EffectsObjectChange\", {\n  inputState: ObjectIn,\n  outputState: ObjectOut,\n  idOperation: IDOperation\n});\nconst UnchangedSharedKind = bcs.enum(\"UnchangedSharedKind\", {\n  ReadOnlyRoot: VersionDigest,\n  // TODO: these have been renamed to MutateConsensusStreamEnded and ReadConsensusStreamEnded\n  MutateDeleted: bcs.u64(),\n  ReadDeleted: bcs.u64(),\n  Cancelled: bcs.u64(),\n  PerEpochConfig: null\n});\nconst TransactionEffectsV2 = bcs.struct(\"TransactionEffectsV2\", {\n  status: ExecutionStatus,\n  executedEpoch: bcs.u64(),\n  gasUsed: GasCostSummary,\n  transactionDigest: ObjectDigest,\n  gasObjectIndex: bcs.option(bcs.u32()),\n  eventsDigest: bcs.option(ObjectDigest),\n  dependencies: bcs.vector(ObjectDigest),\n  lamportVersion: bcs.u64(),\n  changedObjects: bcs.vector(bcs.tuple([Address, EffectsObjectChange])),\n  unchangedSharedObjects: bcs.vector(bcs.tuple([Address, UnchangedSharedKind])),\n  auxDataDigest: bcs.option(ObjectDigest)\n});\nconst TransactionEffects = bcs.enum(\"TransactionEffects\", {\n  V1: TransactionEffectsV1,\n  V2: TransactionEffectsV2\n});\nexport {\n  TransactionEffects\n};\n//# sourceMappingURL=effects.js.map\n","import { bcs } from \"@mysten/bcs\";\nimport { Address } from \"./bcs.js\";\nfunction pureBcsSchemaFromTypeName(name) {\n  switch (name) {\n    case \"u8\":\n      return bcs.u8();\n    case \"u16\":\n      return bcs.u16();\n    case \"u32\":\n      return bcs.u32();\n    case \"u64\":\n      return bcs.u64();\n    case \"u128\":\n      return bcs.u128();\n    case \"u256\":\n      return bcs.u256();\n    case \"bool\":\n      return bcs.bool();\n    case \"string\":\n      return bcs.string();\n    case \"id\":\n    case \"address\":\n      return Address;\n  }\n  const generic = name.match(/^(vector|option)<(.+)>$/);\n  if (generic) {\n    const [kind, inner] = generic.slice(1);\n    if (kind === \"vector\") {\n      return bcs.vector(pureBcsSchemaFromTypeName(inner));\n    } else {\n      return bcs.option(pureBcsSchemaFromTypeName(inner));\n    }\n  }\n  throw new Error(`Invalid Pure type name: ${name}`);\n}\nexport {\n  pureBcsSchemaFromTypeName\n};\n//# sourceMappingURL=pure.js.map\n","import { bcs } from \"@mysten/bcs\";\nimport {\n  Address,\n  AppId,\n  Argument,\n  CallArg,\n  Command,\n  CompressedSignature,\n  GasData,\n  Intent,\n  IntentMessage,\n  IntentScope,\n  IntentVersion,\n  MultiSig,\n  MultiSigPkMap,\n  MultiSigPublicKey,\n  ObjectArg,\n  ObjectDigest,\n  Owner,\n  PasskeyAuthenticator,\n  ProgrammableMoveCall,\n  ProgrammableTransaction,\n  PublicKey,\n  SenderSignedData,\n  SenderSignedTransaction,\n  SharedObjectRef,\n  StructTag,\n  SuiObjectRef,\n  TransactionData,\n  TransactionDataV1,\n  TransactionExpiration,\n  TransactionKind,\n  TypeTag\n} from \"./bcs.js\";\nimport { TransactionEffects } from \"./effects.js\";\nimport { TypeTagSerializer } from \"./type-tag-serializer.js\";\nimport { BcsType, BcsStruct, BcsEnum, BcsTuple } from \"@mysten/bcs\";\nconst suiBcs = {\n  ...bcs,\n  U8: bcs.u8(),\n  U16: bcs.u16(),\n  U32: bcs.u32(),\n  U64: bcs.u64(),\n  U128: bcs.u128(),\n  U256: bcs.u256(),\n  ULEB128: bcs.uleb128(),\n  Bool: bcs.bool(),\n  String: bcs.string(),\n  Address,\n  AppId,\n  Argument,\n  CallArg,\n  Command,\n  CompressedSignature,\n  GasData,\n  Intent,\n  IntentMessage,\n  IntentScope,\n  IntentVersion,\n  MultiSig,\n  MultiSigPkMap,\n  MultiSigPublicKey,\n  ObjectArg,\n  ObjectDigest,\n  Owner,\n  PasskeyAuthenticator,\n  ProgrammableMoveCall,\n  ProgrammableTransaction,\n  PublicKey,\n  SenderSignedData,\n  SenderSignedTransaction,\n  SharedObjectRef,\n  StructTag,\n  SuiObjectRef,\n  TransactionData,\n  TransactionDataV1,\n  TransactionEffects,\n  TransactionExpiration,\n  TransactionKind,\n  TypeTag\n};\nimport {\n  pureBcsSchemaFromTypeName\n} from \"./pure.js\";\nexport {\n  BcsEnum,\n  BcsStruct,\n  BcsTuple,\n  BcsType,\n  TypeTagSerializer,\n  suiBcs as bcs,\n  pureBcsSchemaFromTypeName\n};\n//# sourceMappingURL=index.js.map\n","import { bcs } from \"../bcs/index.js\";\nimport { MOVE_STDLIB_ADDRESS, SUI_FRAMEWORK_ADDRESS } from \"../utils/index.js\";\nimport { normalizeSuiAddress } from \"../utils/sui-types.js\";\nconst OBJECT_MODULE_NAME = \"object\";\nconst ID_STRUCT_NAME = \"ID\";\nconst STD_ASCII_MODULE_NAME = \"ascii\";\nconst STD_ASCII_STRUCT_NAME = \"String\";\nconst STD_UTF8_MODULE_NAME = \"string\";\nconst STD_UTF8_STRUCT_NAME = \"String\";\nconst STD_OPTION_MODULE_NAME = \"option\";\nconst STD_OPTION_STRUCT_NAME = \"Option\";\nfunction isTxContext(param) {\n  const struct = typeof param.body === \"object\" && \"datatype\" in param.body ? param.body.datatype : null;\n  return !!struct && normalizeSuiAddress(struct.package) === normalizeSuiAddress(\"0x2\") && struct.module === \"tx_context\" && struct.type === \"TxContext\";\n}\nfunction getPureBcsSchema(typeSignature) {\n  if (typeof typeSignature === \"string\") {\n    switch (typeSignature) {\n      case \"address\":\n        return bcs.Address;\n      case \"bool\":\n        return bcs.Bool;\n      case \"u8\":\n        return bcs.U8;\n      case \"u16\":\n        return bcs.U16;\n      case \"u32\":\n        return bcs.U32;\n      case \"u64\":\n        return bcs.U64;\n      case \"u128\":\n        return bcs.U128;\n      case \"u256\":\n        return bcs.U256;\n      default:\n        throw new Error(`Unknown type signature ${typeSignature}`);\n    }\n  }\n  if (\"vector\" in typeSignature) {\n    if (typeSignature.vector === \"u8\") {\n      return bcs.byteVector().transform({\n        input: (val) => typeof val === \"string\" ? new TextEncoder().encode(val) : val,\n        output: (val) => val\n      });\n    }\n    const type = getPureBcsSchema(typeSignature.vector);\n    return type ? bcs.vector(type) : null;\n  }\n  if (\"datatype\" in typeSignature) {\n    const pkg = normalizeSuiAddress(typeSignature.datatype.package);\n    if (pkg === normalizeSuiAddress(MOVE_STDLIB_ADDRESS)) {\n      if (typeSignature.datatype.module === STD_ASCII_MODULE_NAME && typeSignature.datatype.type === STD_ASCII_STRUCT_NAME) {\n        return bcs.String;\n      }\n      if (typeSignature.datatype.module === STD_UTF8_MODULE_NAME && typeSignature.datatype.type === STD_UTF8_STRUCT_NAME) {\n        return bcs.String;\n      }\n      if (typeSignature.datatype.module === STD_OPTION_MODULE_NAME && typeSignature.datatype.type === STD_OPTION_STRUCT_NAME) {\n        const type = getPureBcsSchema(typeSignature.datatype.typeParameters[0]);\n        return type ? bcs.vector(type) : null;\n      }\n    }\n    if (pkg === normalizeSuiAddress(SUI_FRAMEWORK_ADDRESS) && typeSignature.datatype.module === OBJECT_MODULE_NAME && typeSignature.datatype.type === ID_STRUCT_NAME) {\n      return bcs.Address;\n    }\n  }\n  return null;\n}\nfunction normalizedTypeToMoveTypeSignature(type) {\n  if (typeof type === \"object\" && \"Reference\" in type) {\n    return {\n      ref: \"&\",\n      body: normalizedTypeToMoveTypeSignatureBody(type.Reference)\n    };\n  }\n  if (typeof type === \"object\" && \"MutableReference\" in type) {\n    return {\n      ref: \"&mut\",\n      body: normalizedTypeToMoveTypeSignatureBody(type.MutableReference)\n    };\n  }\n  return {\n    ref: null,\n    body: normalizedTypeToMoveTypeSignatureBody(type)\n  };\n}\nfunction normalizedTypeToMoveTypeSignatureBody(type) {\n  if (typeof type === \"string\") {\n    switch (type) {\n      case \"Address\":\n        return \"address\";\n      case \"Bool\":\n        return \"bool\";\n      case \"U8\":\n        return \"u8\";\n      case \"U16\":\n        return \"u16\";\n      case \"U32\":\n        return \"u32\";\n      case \"U64\":\n        return \"u64\";\n      case \"U128\":\n        return \"u128\";\n      case \"U256\":\n        return \"u256\";\n      default:\n        throw new Error(`Unexpected type ${type}`);\n    }\n  }\n  if (\"Vector\" in type) {\n    return { vector: normalizedTypeToMoveTypeSignatureBody(type.Vector) };\n  }\n  if (\"Struct\" in type) {\n    return {\n      datatype: {\n        package: type.Struct.address,\n        module: type.Struct.module,\n        type: type.Struct.name,\n        typeParameters: type.Struct.typeArguments.map(normalizedTypeToMoveTypeSignatureBody)\n      }\n    };\n  }\n  if (\"TypeParameter\" in type) {\n    return { typeParameter: type.TypeParameter };\n  }\n  throw new Error(`Unexpected type ${JSON.stringify(type)}`);\n}\nfunction pureBcsSchemaFromOpenMoveTypeSignatureBody(typeSignature) {\n  if (typeof typeSignature === \"string\") {\n    switch (typeSignature) {\n      case \"address\":\n        return bcs.Address;\n      case \"bool\":\n        return bcs.Bool;\n      case \"u8\":\n        return bcs.U8;\n      case \"u16\":\n        return bcs.U16;\n      case \"u32\":\n        return bcs.U32;\n      case \"u64\":\n        return bcs.U64;\n      case \"u128\":\n        return bcs.U128;\n      case \"u256\":\n        return bcs.U256;\n      default:\n        throw new Error(`Unknown type signature ${typeSignature}`);\n    }\n  }\n  if (\"vector\" in typeSignature) {\n    return bcs.vector(pureBcsSchemaFromOpenMoveTypeSignatureBody(typeSignature.vector));\n  }\n  throw new Error(`Expected pure typeSignature, but got ${JSON.stringify(typeSignature)}`);\n}\nexport {\n  getPureBcsSchema,\n  isTxContext,\n  normalizedTypeToMoveTypeSignature,\n  pureBcsSchemaFromOpenMoveTypeSignatureBody\n};\n//# sourceMappingURL=serializer.js.map\n","import { toBase64 } from \"@mysten/bcs\";\nimport { normalizeSuiAddress } from \"../utils/sui-types.js\";\nfunction Pure(data) {\n  return {\n    $kind: \"Pure\",\n    Pure: {\n      bytes: data instanceof Uint8Array ? toBase64(data) : data.toBase64()\n    }\n  };\n}\nconst Inputs = {\n  Pure,\n  ObjectRef({ objectId, digest, version }) {\n    return {\n      $kind: \"Object\",\n      Object: {\n        $kind: \"ImmOrOwnedObject\",\n        ImmOrOwnedObject: {\n          digest,\n          version,\n          objectId: normalizeSuiAddress(objectId)\n        }\n      }\n    };\n  },\n  SharedObjectRef({\n    objectId,\n    mutable,\n    initialSharedVersion\n  }) {\n    return {\n      $kind: \"Object\",\n      Object: {\n        $kind: \"SharedObject\",\n        SharedObject: {\n          mutable,\n          initialSharedVersion,\n          objectId: normalizeSuiAddress(objectId)\n        }\n      }\n    };\n  },\n  ReceivingRef({ objectId, digest, version }) {\n    return {\n      $kind: \"Object\",\n      Object: {\n        $kind: \"Receiving\",\n        Receiving: {\n          digest,\n          version,\n          objectId: normalizeSuiAddress(objectId)\n        }\n      }\n    };\n  }\n};\nexport {\n  Inputs\n};\n//# sourceMappingURL=Inputs.js.map\n","//#region src/storages/globalConfig/globalConfig.ts\nlet store$4;\n/**\n* Sets the global configuration.\n*\n* @param config The configuration.\n*/\nfunction setGlobalConfig(config$1) {\n\tstore$4 = {\n\t\t...store$4,\n\t\t...config$1\n\t};\n}\n/**\n* Returns the global configuration.\n*\n* @param config The config to merge.\n*\n* @returns The configuration.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction getGlobalConfig(config$1) {\n\treturn {\n\t\tlang: config$1?.lang ?? store$4?.lang,\n\t\tmessage: config$1?.message,\n\t\tabortEarly: config$1?.abortEarly ?? store$4?.abortEarly,\n\t\tabortPipeEarly: config$1?.abortPipeEarly ?? store$4?.abortPipeEarly\n\t};\n}\n/**\n* Deletes the global configuration.\n*/\nfunction deleteGlobalConfig() {\n\tstore$4 = void 0;\n}\n\n//#endregion\n//#region src/storages/globalMessage/globalMessage.ts\nlet store$3;\n/**\n* Sets a global error message.\n*\n* @param message The error message.\n* @param lang The language of the message.\n*/\nfunction setGlobalMessage(message$1, lang) {\n\tif (!store$3) store$3 = /* @__PURE__ */ new Map();\n\tstore$3.set(lang, message$1);\n}\n/**\n* Returns a global error message.\n*\n* @param lang The language of the message.\n*\n* @returns The error message.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction getGlobalMessage(lang) {\n\treturn store$3?.get(lang);\n}\n/**\n* Deletes a global error message.\n*\n* @param lang The language of the message.\n*/\nfunction deleteGlobalMessage(lang) {\n\tstore$3?.delete(lang);\n}\n\n//#endregion\n//#region src/storages/schemaMessage/schemaMessage.ts\nlet store$2;\n/**\n* Sets a schema error message.\n*\n* @param message The error message.\n* @param lang The language of the message.\n*/\nfunction setSchemaMessage(message$1, lang) {\n\tif (!store$2) store$2 = /* @__PURE__ */ new Map();\n\tstore$2.set(lang, message$1);\n}\n/**\n* Returns a schema error message.\n*\n* @param lang The language of the message.\n*\n* @returns The error message.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction getSchemaMessage(lang) {\n\treturn store$2?.get(lang);\n}\n/**\n* Deletes a schema error message.\n*\n* @param lang The language of the message.\n*/\nfunction deleteSchemaMessage(lang) {\n\tstore$2?.delete(lang);\n}\n\n//#endregion\n//#region src/storages/specificMessage/specificMessage.ts\nlet store$1;\n/**\n* Sets a specific error message.\n*\n* @param reference The identifier reference.\n* @param message The error message.\n* @param lang The language of the message.\n*/\nfunction setSpecificMessage(reference, message$1, lang) {\n\tif (!store$1) store$1 = /* @__PURE__ */ new Map();\n\tif (!store$1.get(reference)) store$1.set(reference, /* @__PURE__ */ new Map());\n\tstore$1.get(reference).set(lang, message$1);\n}\n/**\n* Returns a specific error message.\n*\n* @param reference The identifier reference.\n* @param lang The language of the message.\n*\n* @returns The error message.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction getSpecificMessage(reference, lang) {\n\treturn store$1?.get(reference)?.get(lang);\n}\n/**\n* Deletes a specific error message.\n*\n* @param reference The identifier reference.\n* @param lang The language of the message.\n*/\nfunction deleteSpecificMessage(reference, lang) {\n\tstore$1?.get(reference)?.delete(lang);\n}\n\n//#endregion\n//#region src/utils/_stringify/_stringify.ts\n/**\n* Stringifies an unknown input to a literal or type string.\n*\n* @param input The unknown input.\n*\n* @returns A literal or type string.\n*\n* @internal\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction _stringify(input) {\n\tconst type = typeof input;\n\tif (type === \"string\") return `\"${input}\"`;\n\tif (type === \"number\" || type === \"bigint\" || type === \"boolean\") return `${input}`;\n\tif (type === \"object\" || type === \"function\") return (input && Object.getPrototypeOf(input)?.constructor?.name) ?? \"null\";\n\treturn type;\n}\n\n//#endregion\n//#region src/utils/_addIssue/_addIssue.ts\n/**\n* Adds an issue to the dataset.\n*\n* @param context The issue context.\n* @param label The issue label.\n* @param dataset The input dataset.\n* @param config The configuration.\n* @param other The optional props.\n*\n* @internal\n*/\nfunction _addIssue(context, label, dataset, config$1, other) {\n\tconst input = other && \"input\" in other ? other.input : dataset.value;\n\tconst expected = other?.expected ?? context.expects ?? null;\n\tconst received = other?.received ?? /* @__PURE__ */ _stringify(input);\n\tconst issue = {\n\t\tkind: context.kind,\n\t\ttype: context.type,\n\t\tinput,\n\t\texpected,\n\t\treceived,\n\t\tmessage: `Invalid ${label}: ${expected ? `Expected ${expected} but r` : \"R\"}eceived ${received}`,\n\t\trequirement: context.requirement,\n\t\tpath: other?.path,\n\t\tissues: other?.issues,\n\t\tlang: config$1.lang,\n\t\tabortEarly: config$1.abortEarly,\n\t\tabortPipeEarly: config$1.abortPipeEarly\n\t};\n\tconst isSchema = context.kind === \"schema\";\n\tconst message$1 = other?.message ?? context.message ?? /* @__PURE__ */ getSpecificMessage(context.reference, issue.lang) ?? (isSchema ? /* @__PURE__ */ getSchemaMessage(issue.lang) : null) ?? config$1.message ?? /* @__PURE__ */ getGlobalMessage(issue.lang);\n\tif (message$1 !== void 0) issue.message = typeof message$1 === \"function\" ? message$1(issue) : message$1;\n\tif (isSchema) dataset.typed = false;\n\tif (dataset.issues) dataset.issues.push(issue);\n\telse dataset.issues = [issue];\n}\n\n//#endregion\n//#region src/utils/_getByteCount/_getByteCount.ts\nlet textEncoder;\n/**\n* Returns the byte count of the input.\n*\n* @param input The input to be measured.\n*\n* @returns The byte count.\n*\n* @internal\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction _getByteCount(input) {\n\tif (!textEncoder) textEncoder = new TextEncoder();\n\treturn textEncoder.encode(input).length;\n}\n\n//#endregion\n//#region src/utils/_getGraphemeCount/_getGraphemeCount.ts\nlet segmenter;\n/**\n* Returns the grapheme count of the input.\n*\n* @param input The input to be measured.\n*\n* @returns The grapheme count.\n*\n* @internal\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction _getGraphemeCount(input) {\n\tif (!segmenter) segmenter = new Intl.Segmenter();\n\tconst segments = segmenter.segment(input);\n\tlet count = 0;\n\tfor (const _ of segments) count++;\n\treturn count;\n}\n\n//#endregion\n//#region src/utils/_getLastMetadata/_getLastMetadata.ts\n/**\n* Returns the last top-level value of a given metadata type from a schema\n* using a breadth-first search that starts with the last item in the pipeline.\n*\n* @param schema The schema to search.\n* @param type The metadata type.\n*\n* @returns The value, if any.\n*\n* @internal\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction _getLastMetadata(schema, type) {\n\tif (\"pipe\" in schema) {\n\t\tconst nestedSchemas = [];\n\t\tfor (let index = schema.pipe.length - 1; index >= 0; index--) {\n\t\t\tconst item = schema.pipe[index];\n\t\t\tif (item.kind === \"schema\" && \"pipe\" in item) nestedSchemas.push(item);\n\t\t\telse if (item.kind === \"metadata\" && item.type === type) return item[type];\n\t\t}\n\t\tfor (const nestedSchema of nestedSchemas) {\n\t\t\tconst result = /* @__PURE__ */ _getLastMetadata(nestedSchema, type);\n\t\t\tif (result !== void 0) return result;\n\t\t}\n\t}\n}\n\n//#endregion\n//#region src/utils/_getStandardProps/_getStandardProps.ts\n/**\n* Returns the Standard Schema properties.\n*\n* @param context The schema context.\n*\n* @returns The Standard Schema properties.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction _getStandardProps(context) {\n\treturn {\n\t\tversion: 1,\n\t\tvendor: \"valibot\",\n\t\tvalidate(value$1) {\n\t\t\treturn context[\"~run\"]({ value: value$1 }, /* @__PURE__ */ getGlobalConfig());\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/utils/_getWordCount/_getWordCount.ts\nlet store;\n/**\n* Returns the word count of the input.\n*\n* @param locales The locales to be used.\n* @param input The input to be measured.\n*\n* @returns The word count.\n*\n* @internal\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction _getWordCount(locales, input) {\n\tif (!store) store = /* @__PURE__ */ new Map();\n\tif (!store.get(locales)) store.set(locales, new Intl.Segmenter(locales, { granularity: \"word\" }));\n\tconst segments = store.get(locales).segment(input);\n\tlet count = 0;\n\tfor (const segment of segments) if (segment.isWordLike) count++;\n\treturn count;\n}\n\n//#endregion\n//#region src/utils/_isLuhnAlgo/_isLuhnAlgo.ts\n/**\n* Non-digit regex.\n*/\nconst NON_DIGIT_REGEX = /\\D/gu;\n/**\n* Checks whether a string with numbers corresponds to the luhn algorithm.\n*\n* @param input The input to be checked.\n*\n* @returns Whether input is valid.\n*\n* @internal\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction _isLuhnAlgo(input) {\n\tconst number$1 = input.replace(NON_DIGIT_REGEX, \"\");\n\tlet length$1 = number$1.length;\n\tlet bit = 1;\n\tlet sum = 0;\n\twhile (length$1) {\n\t\tconst value$1 = +number$1[--length$1];\n\t\tbit ^= 1;\n\t\tsum += bit ? [\n\t\t\t0,\n\t\t\t2,\n\t\t\t4,\n\t\t\t6,\n\t\t\t8,\n\t\t\t1,\n\t\t\t3,\n\t\t\t5,\n\t\t\t7,\n\t\t\t9\n\t\t][value$1] : value$1;\n\t}\n\treturn sum % 10 === 0;\n}\n\n//#endregion\n//#region src/utils/_isValidObjectKey/_isValidObjectKey.ts\n/**\n* Disallows inherited object properties and prevents object prototype\n* pollution by disallowing certain keys.\n*\n* @param object The object to check.\n* @param key The key to check.\n*\n* @returns Whether the key is allowed.\n*\n* @internal\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction _isValidObjectKey(object$1, key) {\n\treturn Object.hasOwn(object$1, key) && key !== \"__proto__\" && key !== \"prototype\" && key !== \"constructor\";\n}\n\n//#endregion\n//#region src/utils/_joinExpects/_joinExpects.ts\n/**\n* Joins multiple `expects` values with the given separator.\n*\n* @param values The `expects` values.\n* @param separator The separator.\n*\n* @returns The joined `expects` property.\n*\n* @internal\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction _joinExpects(values$1, separator) {\n\tconst list = [...new Set(values$1)];\n\tif (list.length > 1) return `(${list.join(` ${separator} `)})`;\n\treturn list[0] ?? \"never\";\n}\n\n//#endregion\n//#region src/utils/entriesFromList/entriesFromList.ts\n/**\n* Creates an object entries definition from a list of keys and a schema.\n*\n* @param list A list of keys.\n* @param schema The schema of the keys.\n*\n* @returns The object entries.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction entriesFromList(list, schema) {\n\tconst entries$1 = {};\n\tfor (const key of list) entries$1[key] = schema;\n\treturn entries$1;\n}\n\n//#endregion\n//#region src/utils/entriesFromObjects/entriesFromObjects.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction entriesFromObjects(schemas) {\n\tconst entries$1 = {};\n\tfor (const schema of schemas) Object.assign(entries$1, schema.entries);\n\treturn entries$1;\n}\n\n//#endregion\n//#region src/utils/getDotPath/getDotPath.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction getDotPath(issue) {\n\tif (issue.path) {\n\t\tlet key = \"\";\n\t\tfor (const item of issue.path) if (typeof item.key === \"string\" || typeof item.key === \"number\") if (key) key += `.${item.key}`;\n\t\telse key += item.key;\n\t\telse return null;\n\t\treturn key;\n\t}\n\treturn null;\n}\n\n//#endregion\n//#region src/utils/isOfKind/isOfKind.ts\n/**\n* A generic type guard to check the kind of an object.\n*\n* @param kind The kind to check for.\n* @param object The object to check.\n*\n* @returns Whether it matches.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction isOfKind(kind, object$1) {\n\treturn object$1.kind === kind;\n}\n\n//#endregion\n//#region src/utils/isOfType/isOfType.ts\n/**\n* A generic type guard to check the type of an object.\n*\n* @param type The type to check for.\n* @param object The object to check.\n*\n* @returns Whether it matches.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction isOfType(type, object$1) {\n\treturn object$1.type === type;\n}\n\n//#endregion\n//#region src/utils/isValiError/isValiError.ts\n/**\n* A type guard to check if an error is a ValiError.\n*\n* @param error The error to check.\n*\n* @returns Whether its a ValiError.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction isValiError(error) {\n\treturn error instanceof ValiError;\n}\n\n//#endregion\n//#region src/utils/ValiError/ValiError.ts\n/**\n* A Valibot error with useful information.\n*/\nvar ValiError = class extends Error {\n\t/**\n\t* Creates a Valibot error with useful information.\n\t*\n\t* @param issues The error issues.\n\t*/\n\tconstructor(issues) {\n\t\tsuper(issues[0].message);\n\t\tthis.name = \"ValiError\";\n\t\tthis.issues = issues;\n\t}\n};\n\n//#endregion\n//#region src/actions/args/args.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction args(schema) {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"args\",\n\t\treference: args,\n\t\tasync: false,\n\t\tschema,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tconst func = dataset.value;\n\t\t\tdataset.value = (...args_) => {\n\t\t\t\tconst argsDataset = this.schema[\"~run\"]({ value: args_ }, config$1);\n\t\t\t\tif (argsDataset.issues) throw new ValiError(argsDataset.issues);\n\t\t\t\treturn func(...argsDataset.value);\n\t\t\t};\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/args/argsAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction argsAsync(schema) {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"args\",\n\t\treference: argsAsync,\n\t\tasync: false,\n\t\tschema,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tconst func = dataset.value;\n\t\t\tdataset.value = async (...args$1) => {\n\t\t\t\tconst argsDataset = await schema[\"~run\"]({ value: args$1 }, config$1);\n\t\t\t\tif (argsDataset.issues) throw new ValiError(argsDataset.issues);\n\t\t\t\treturn func(...argsDataset.value);\n\t\t\t};\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/await/awaitAsync.ts\n/**\n* Creates an await transformation action.\n*\n* @returns An await action.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction awaitAsync() {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"await\",\n\t\treference: awaitAsync,\n\t\tasync: true,\n\t\tasync \"~run\"(dataset) {\n\t\t\tdataset.value = await dataset.value;\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/regex.ts\n/**\n* [Base64](https://en.wikipedia.org/wiki/Base64) regex.\n*/\nconst BASE64_REGEX = /^(?:[\\da-z+/]{4})*(?:[\\da-z+/]{2}==|[\\da-z+/]{3}=)?$/iu;\n/**\n* [BIC](https://en.wikipedia.org/wiki/ISO_9362) regex.\n*/\nconst BIC_REGEX = /^[A-Z]{6}(?!00)[\\dA-Z]{2}(?:[\\dA-Z]{3})?$/u;\n/**\n* [Cuid2](https://github.com/paralleldrive/cuid2) regex.\n*/\nconst CUID2_REGEX = /^[a-z][\\da-z]*$/u;\n/**\n* [Decimal](https://en.wikipedia.org/wiki/Decimal) regex.\n*/\nconst DECIMAL_REGEX = /^[+-]?(?:\\d*\\.)?\\d+$/u;\n/**\n* [Digits](https://en.wikipedia.org/wiki/Numerical_digit) regex.\n*/\nconst DIGITS_REGEX = /^\\d+$/u;\n/**\n* [Email address](https://en.wikipedia.org/wiki/Email_address) regex.\n*/\nconst EMAIL_REGEX = /^[\\w+-]+(?:\\.[\\w+-]+)*@[\\da-z]+(?:[.-][\\da-z]+)*\\.[a-z]{2,}$/iu;\n/**\n* Emoji regex from [emoji-regex-xs](https://github.com/slevithan/emoji-regex-xs) v1.0.0 (MIT license).\n*\n* Hint: We decided against the newer `/^\\p{RGI_Emoji}+$/v` regex because it is\n* not supported in older runtimes and does not match all emoji.\n*/\nconst EMOJI_REGEX = /^(?:[\\u{1F1E6}-\\u{1F1FF}]{2}|\\u{1F3F4}[\\u{E0061}-\\u{E007A}]{2}[\\u{E0030}-\\u{E0039}\\u{E0061}-\\u{E007A}]{1,3}\\u{E007F}|(?:\\p{Emoji}\\uFE0F\\u20E3?|\\p{Emoji_Modifier_Base}\\p{Emoji_Modifier}?|(?![\\p{Emoji_Modifier_Base}\\u{1F1E6}-\\u{1F1FF}])\\p{Emoji_Presentation})(?:\\u200D(?:\\p{Emoji}\\uFE0F\\u20E3?|\\p{Emoji_Modifier_Base}\\p{Emoji_Modifier}?|(?![\\p{Emoji_Modifier_Base}\\u{1F1E6}-\\u{1F1FF}])\\p{Emoji_Presentation}))*)+$/u;\n/**\n* [Hexadecimal](https://en.wikipedia.org/wiki/Hexadecimal) regex.\n*\n* Hint: We decided against the `i` flag for better JSON Schema compatibility.\n*/\nconst HEXADECIMAL_REGEX = /^(?:0[hx])?[\\da-fA-F]+$/u;\n/**\n* [Hex color](https://en.wikipedia.org/wiki/Web_colors#Hex_triplet) regex.\n*\n* Hint: We decided against the `i` flag for better JSON Schema compatibility.\n*/\nconst HEX_COLOR_REGEX = /^#(?:[\\da-fA-F]{3,4}|[\\da-fA-F]{6}|[\\da-fA-F]{8})$/u;\n/**\n* [IMEI](https://en.wikipedia.org/wiki/International_Mobile_Equipment_Identity) regex.\n*/\nconst IMEI_REGEX = /^\\d{15}$|^\\d{2}-\\d{6}-\\d{6}-\\d$/u;\n/**\n* [IPv4](https://en.wikipedia.org/wiki/IPv4) regex.\n*/\nconst IPV4_REGEX = /^(?:(?:[1-9]|1\\d|2[0-4])?\\d|25[0-5])(?:\\.(?:(?:[1-9]|1\\d|2[0-4])?\\d|25[0-5])){3}$/u;\n/**\n* [IPv6](https://en.wikipedia.org/wiki/IPv6) regex.\n*/\nconst IPV6_REGEX = /^(?:(?:[\\da-f]{1,4}:){7}[\\da-f]{1,4}|(?:[\\da-f]{1,4}:){1,7}:|(?:[\\da-f]{1,4}:){1,6}:[\\da-f]{1,4}|(?:[\\da-f]{1,4}:){1,5}(?::[\\da-f]{1,4}){1,2}|(?:[\\da-f]{1,4}:){1,4}(?::[\\da-f]{1,4}){1,3}|(?:[\\da-f]{1,4}:){1,3}(?::[\\da-f]{1,4}){1,4}|(?:[\\da-f]{1,4}:){1,2}(?::[\\da-f]{1,4}){1,5}|[\\da-f]{1,4}:(?::[\\da-f]{1,4}){1,6}|:(?:(?::[\\da-f]{1,4}){1,7}|:)|fe80:(?::[\\da-f]{0,4}){0,4}%[\\da-z]+|::(?:f{4}(?::0{1,4})?:)?(?:(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)\\.){3}(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)|(?:[\\da-f]{1,4}:){1,4}:(?:(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)\\.){3}(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d))$/iu;\n/**\n* [IP](https://en.wikipedia.org/wiki/IP_address) regex.\n*/\nconst IP_REGEX = /^(?:(?:[1-9]|1\\d|2[0-4])?\\d|25[0-5])(?:\\.(?:(?:[1-9]|1\\d|2[0-4])?\\d|25[0-5])){3}$|^(?:(?:[\\da-f]{1,4}:){7}[\\da-f]{1,4}|(?:[\\da-f]{1,4}:){1,7}:|(?:[\\da-f]{1,4}:){1,6}:[\\da-f]{1,4}|(?:[\\da-f]{1,4}:){1,5}(?::[\\da-f]{1,4}){1,2}|(?:[\\da-f]{1,4}:){1,4}(?::[\\da-f]{1,4}){1,3}|(?:[\\da-f]{1,4}:){1,3}(?::[\\da-f]{1,4}){1,4}|(?:[\\da-f]{1,4}:){1,2}(?::[\\da-f]{1,4}){1,5}|[\\da-f]{1,4}:(?::[\\da-f]{1,4}){1,6}|:(?:(?::[\\da-f]{1,4}){1,7}|:)|fe80:(?::[\\da-f]{0,4}){0,4}%[\\da-z]+|::(?:f{4}(?::0{1,4})?:)?(?:(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)\\.){3}(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)|(?:[\\da-f]{1,4}:){1,4}:(?:(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)\\.){3}(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d))$/iu;\n/**\n* [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) date regex.\n*/\nconst ISO_DATE_REGEX = /^\\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\\d|0[1-9]|3[01])$/u;\n/**\n* [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) date-time regex.\n*/\nconst ISO_DATE_TIME_REGEX = /^\\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\\d|0[1-9]|3[01])[T ](?:0\\d|1\\d|2[0-3]):[0-5]\\d$/u;\n/**\n* [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) time regex.\n*/\nconst ISO_TIME_REGEX = /^(?:0\\d|1\\d|2[0-3]):[0-5]\\d$/u;\n/**\n* [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) time with seconds regex.\n*/\nconst ISO_TIME_SECOND_REGEX = /^(?:0\\d|1\\d|2[0-3])(?::[0-5]\\d){2}$/u;\n/**\n* [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) timestamp regex.\n*/\nconst ISO_TIMESTAMP_REGEX = /^\\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\\d|0[1-9]|3[01])[T ](?:0\\d|1\\d|2[0-3])(?::[0-5]\\d){2}(?:\\.\\d{1,9})?(?:Z|[+-](?:0\\d|1\\d|2[0-3])(?::?[0-5]\\d)?)$/u;\n/**\n* [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) week regex.\n*/\nconst ISO_WEEK_REGEX = /^\\d{4}-W(?:0[1-9]|[1-4]\\d|5[0-3])$/u;\n/**\n* [MAC](https://en.wikipedia.org/wiki/MAC_address) 48 bit regex.\n*/\nconst MAC48_REGEX = /^(?:[\\da-f]{2}:){5}[\\da-f]{2}$|^(?:[\\da-f]{2}-){5}[\\da-f]{2}$|^(?:[\\da-f]{4}\\.){2}[\\da-f]{4}$/iu;\n/**\n* [MAC](https://en.wikipedia.org/wiki/MAC_address) 64 bit regex.\n*/\nconst MAC64_REGEX = /^(?:[\\da-f]{2}:){7}[\\da-f]{2}$|^(?:[\\da-f]{2}-){7}[\\da-f]{2}$|^(?:[\\da-f]{4}\\.){3}[\\da-f]{4}$|^(?:[\\da-f]{4}:){3}[\\da-f]{4}$/iu;\n/**\n* [MAC](https://en.wikipedia.org/wiki/MAC_address) regex.\n*/\nconst MAC_REGEX = /^(?:[\\da-f]{2}:){5}[\\da-f]{2}$|^(?:[\\da-f]{2}-){5}[\\da-f]{2}$|^(?:[\\da-f]{4}\\.){2}[\\da-f]{4}$|^(?:[\\da-f]{2}:){7}[\\da-f]{2}$|^(?:[\\da-f]{2}-){7}[\\da-f]{2}$|^(?:[\\da-f]{4}\\.){3}[\\da-f]{4}$|^(?:[\\da-f]{4}:){3}[\\da-f]{4}$/iu;\n/**\n* [Nano ID](https://github.com/ai/nanoid) regex.\n*/\nconst NANO_ID_REGEX = /^[\\w-]+$/u;\n/**\n* [Octal](https://en.wikipedia.org/wiki/Octal) regex.\n*/\nconst OCTAL_REGEX = /^(?:0o)?[0-7]+$/u;\n/**\n* [RFC 5322 email address](https://datatracker.ietf.org/doc/html/rfc5322#section-3.4.1) regex.\n*\n* Hint: This regex was taken from the [HTML Living Standard Specification](https://html.spec.whatwg.org/multipage/input.html#valid-e-mail-address) and does not perfectly represent RFC 5322.\n*/\nconst RFC_EMAIL_REGEX = /^[a-zA-Z0-9.!#$%&'*+\\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;\n/**\n* [Slug](https://en.wikipedia.org/wiki/Clean_URL#Slug) regex.\n*/\nconst SLUG_REGEX = /^[\\da-z]+(?:[-_][\\da-z]+)*$/u;\n/**\n* [ULID](https://github.com/ulid/spec) regex.\n*\n* Hint: We decided against the `i` flag for better JSON Schema compatibility.\n*/\nconst ULID_REGEX = /^[\\da-hjkmnp-tv-zA-HJKMNP-TV-Z]{26}$/u;\n/**\n* [UUID](https://en.wikipedia.org/wiki/Universally_unique_identifier) regex.\n*/\nconst UUID_REGEX = /^[\\da-f]{8}(?:-[\\da-f]{4}){3}-[\\da-f]{12}$/iu;\n\n//#endregion\n//#region src/actions/base64/base64.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction base64(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"base64\",\n\t\treference: base64,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: BASE64_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"Base64\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/bic/bic.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction bic(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"bic\",\n\t\treference: bic,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: BIC_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"BIC\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/brand/brand.ts\n/**\n* Creates a brand transformation action.\n*\n* @param name The brand name.\n*\n* @returns A brand action.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction brand(name) {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"brand\",\n\t\treference: brand,\n\t\tasync: false,\n\t\tname,\n\t\t\"~run\"(dataset) {\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/bytes/bytes.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction bytes(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"bytes\",\n\t\treference: bytes,\n\t\tasync: false,\n\t\texpects: `${requirement}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed) {\n\t\t\t\tconst length$1 = /* @__PURE__ */ _getByteCount(dataset.value);\n\t\t\t\tif (length$1 !== this.requirement) _addIssue(this, \"bytes\", dataset, config$1, { received: `${length$1}` });\n\t\t\t}\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/check/check.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction check(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"check\",\n\t\treference: check,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement(dataset.value)) _addIssue(this, \"input\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/check/checkAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction checkAsync(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"check\",\n\t\treference: checkAsync,\n\t\tasync: true,\n\t\texpects: null,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !await this.requirement(dataset.value)) _addIssue(this, \"input\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/checkItems/checkItems.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction checkItems(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"check_items\",\n\t\treference: checkItems,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed) for (let index = 0; index < dataset.value.length; index++) {\n\t\t\t\tconst item = dataset.value[index];\n\t\t\t\tif (!this.requirement(item, index, dataset.value)) _addIssue(this, \"item\", dataset, config$1, {\n\t\t\t\t\tinput: item,\n\t\t\t\t\tpath: [{\n\t\t\t\t\t\ttype: \"array\",\n\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\tinput: dataset.value,\n\t\t\t\t\t\tkey: index,\n\t\t\t\t\t\tvalue: item\n\t\t\t\t\t}]\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/checkItems/checkItemsAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction checkItemsAsync(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"check_items\",\n\t\treference: checkItemsAsync,\n\t\tasync: true,\n\t\texpects: null,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed) {\n\t\t\t\tconst requirementResults = await Promise.all(dataset.value.map(this.requirement));\n\t\t\t\tfor (let index = 0; index < dataset.value.length; index++) if (!requirementResults[index]) {\n\t\t\t\t\tconst item = dataset.value[index];\n\t\t\t\t\t_addIssue(this, \"item\", dataset, config$1, {\n\t\t\t\t\t\tinput: item,\n\t\t\t\t\t\tpath: [{\n\t\t\t\t\t\t\ttype: \"array\",\n\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\tinput: dataset.value,\n\t\t\t\t\t\t\tkey: index,\n\t\t\t\t\t\t\tvalue: item\n\t\t\t\t\t\t}]\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/creditCard/creditCard.ts\n/**\n* Credit card regex.\n*/\nconst CREDIT_CARD_REGEX = /^(?:\\d{14,19}|\\d{4}(?: \\d{3,6}){2,4}|\\d{4}(?:-\\d{3,6}){2,4})$/u;\n/**\n* Sanitize regex.\n*/\nconst SANITIZE_REGEX = /[- ]/gu;\n/**\n* Provider regex list.\n*/\nconst PROVIDER_REGEX_LIST = [\n\t/^3[47]\\d{13}$/u,\n\t/^3(?:0[0-5]|[68]\\d)\\d{11,13}$/u,\n\t/^6(?:011|5\\d{2})\\d{12,15}$/u,\n\t/^(?:2131|1800|35\\d{3})\\d{11}$/u,\n\t/^5[1-5]\\d{2}|(?:222\\d|22[3-9]\\d|2[3-6]\\d{2}|27[01]\\d|2720)\\d{12}$/u,\n\t/^(?:6[27]\\d{14,17}|81\\d{14,17})$/u,\n\t/^4\\d{12}(?:\\d{3,6})?$/u\n];\n/* @__NO_SIDE_EFFECTS__ */\nfunction creditCard(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"credit_card\",\n\t\treference: creditCard,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement(input) {\n\t\t\tlet sanitized;\n\t\t\treturn CREDIT_CARD_REGEX.test(input) && (sanitized = input.replace(SANITIZE_REGEX, \"\")) && PROVIDER_REGEX_LIST.some((regex$1) => regex$1.test(sanitized)) && /* @__PURE__ */ _isLuhnAlgo(sanitized);\n\t\t},\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement(dataset.value)) _addIssue(this, \"credit card\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/cuid2/cuid2.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction cuid2(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"cuid2\",\n\t\treference: cuid2,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: CUID2_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"Cuid2\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/decimal/decimal.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction decimal(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"decimal\",\n\t\treference: decimal,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: DECIMAL_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"decimal\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/description/description.ts\n/**\n* Creates a description metadata action.\n*\n* @param description_ The description text.\n*\n* @returns A description action.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction description(description_) {\n\treturn {\n\t\tkind: \"metadata\",\n\t\ttype: \"description\",\n\t\treference: description,\n\t\tdescription: description_\n\t};\n}\n\n//#endregion\n//#region src/actions/digits/digits.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction digits(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"digits\",\n\t\treference: digits,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: DIGITS_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"digits\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/email/email.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction email(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"email\",\n\t\treference: email,\n\t\texpects: null,\n\t\tasync: false,\n\t\trequirement: EMAIL_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"email\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/emoji/emoji.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction emoji(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"emoji\",\n\t\treference: emoji,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: EMOJI_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"emoji\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/empty/empty.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction empty(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"empty\",\n\t\treference: empty,\n\t\tasync: false,\n\t\texpects: \"0\",\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && dataset.value.length > 0) _addIssue(this, \"length\", dataset, config$1, { received: `${dataset.value.length}` });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/endsWith/endsWith.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction endsWith(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"ends_with\",\n\t\treference: endsWith,\n\t\tasync: false,\n\t\texpects: `\"${requirement}\"`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !dataset.value.endsWith(this.requirement)) _addIssue(this, \"end\", dataset, config$1, { received: `\"${dataset.value.slice(-this.requirement.length)}\"` });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/entries/entries.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction entries(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"entries\",\n\t\treference: entries,\n\t\tasync: false,\n\t\texpects: `${requirement}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (!dataset.typed) return dataset;\n\t\t\tconst count = Object.keys(dataset.value).length;\n\t\t\tif (dataset.typed && count !== this.requirement) _addIssue(this, \"entries\", dataset, config$1, { received: `${count}` });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/everyItem/everyItem.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction everyItem(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"every_item\",\n\t\treference: everyItem,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !dataset.value.every(this.requirement)) _addIssue(this, \"item\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/examples/examples.ts\n/**\n* Creates an examples metadata action.\n*\n* @param examples_ The examples.\n*\n* @returns An examples action.\n*\n* @beta\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction examples(examples_) {\n\treturn {\n\t\tkind: \"metadata\",\n\t\ttype: \"examples\",\n\t\treference: examples,\n\t\texamples: examples_\n\t};\n}\n\n//#endregion\n//#region src/actions/excludes/excludes.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction excludes(requirement, message$1) {\n\tconst received = /* @__PURE__ */ _stringify(requirement);\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"excludes\",\n\t\treference: excludes,\n\t\tasync: false,\n\t\texpects: `!${received}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && dataset.value.includes(this.requirement)) _addIssue(this, \"content\", dataset, config$1, { received });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/filterItems/filterItems.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction filterItems(operation) {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"filter_items\",\n\t\treference: filterItems,\n\t\tasync: false,\n\t\toperation,\n\t\t\"~run\"(dataset) {\n\t\t\tdataset.value = dataset.value.filter(this.operation);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/findItem/findItem.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction findItem(operation) {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"find_item\",\n\t\treference: findItem,\n\t\tasync: false,\n\t\toperation,\n\t\t\"~run\"(dataset) {\n\t\t\tdataset.value = dataset.value.find(this.operation);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/finite/finite.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction finite(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"finite\",\n\t\treference: finite,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: Number.isFinite,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement(dataset.value)) _addIssue(this, \"finite\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/flavor/flavor.ts\n/**\n* Creates a flavor transformation action.\n*\n* @param name The flavor name.\n*\n* @returns A flavor action.\n*\n* @beta\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction flavor(name) {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"flavor\",\n\t\treference: flavor,\n\t\tasync: false,\n\t\tname,\n\t\t\"~run\"(dataset) {\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/graphemes/graphemes.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction graphemes(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"graphemes\",\n\t\treference: graphemes,\n\t\tasync: false,\n\t\texpects: `${requirement}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed) {\n\t\t\t\tconst count = /* @__PURE__ */ _getGraphemeCount(dataset.value);\n\t\t\t\tif (count !== this.requirement) _addIssue(this, \"graphemes\", dataset, config$1, { received: `${count}` });\n\t\t\t}\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/gtValue/gtValue.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction gtValue(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"gt_value\",\n\t\treference: gtValue,\n\t\tasync: false,\n\t\texpects: `>${requirement instanceof Date ? requirement.toJSON() : /* @__PURE__ */ _stringify(requirement)}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !(dataset.value > this.requirement)) _addIssue(this, \"value\", dataset, config$1, { received: dataset.value instanceof Date ? dataset.value.toJSON() : /* @__PURE__ */ _stringify(dataset.value) });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/hash/hash.ts\n/**\n* Hash lengths object.\n*/\nconst HASH_LENGTHS = {\n\tmd4: 32,\n\tmd5: 32,\n\tsha1: 40,\n\tsha256: 64,\n\tsha384: 96,\n\tsha512: 128,\n\tripemd128: 32,\n\tripemd160: 40,\n\ttiger128: 32,\n\ttiger160: 40,\n\ttiger192: 48,\n\tcrc32: 8,\n\tcrc32b: 8,\n\tadler32: 8\n};\n/* @__NO_SIDE_EFFECTS__ */\nfunction hash(types, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"hash\",\n\t\treference: hash,\n\t\texpects: null,\n\t\tasync: false,\n\t\trequirement: RegExp(types.map((type) => `^[a-f0-9]{${HASH_LENGTHS[type]}}$`).join(\"|\"), \"iu\"),\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"hash\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/hexadecimal/hexadecimal.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction hexadecimal(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"hexadecimal\",\n\t\treference: hexadecimal,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: HEXADECIMAL_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"hexadecimal\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/hexColor/hexColor.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction hexColor(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"hex_color\",\n\t\treference: hexColor,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: HEX_COLOR_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"hex color\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/imei/imei.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction imei(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"imei\",\n\t\treference: imei,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement(input) {\n\t\t\treturn IMEI_REGEX.test(input) && /* @__PURE__ */ _isLuhnAlgo(input);\n\t\t},\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement(dataset.value)) _addIssue(this, \"IMEI\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/includes/includes.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction includes(requirement, message$1) {\n\tconst expects = /* @__PURE__ */ _stringify(requirement);\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"includes\",\n\t\treference: includes,\n\t\tasync: false,\n\t\texpects,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !dataset.value.includes(this.requirement)) _addIssue(this, \"content\", dataset, config$1, { received: `!${expects}` });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/integer/integer.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction integer(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"integer\",\n\t\treference: integer,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: Number.isInteger,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement(dataset.value)) _addIssue(this, \"integer\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/ip/ip.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction ip(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"ip\",\n\t\treference: ip,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: IP_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"IP\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/ipv4/ipv4.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction ipv4(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"ipv4\",\n\t\treference: ipv4,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: IPV4_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"IPv4\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/ipv6/ipv6.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction ipv6(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"ipv6\",\n\t\treference: ipv6,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: IPV6_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"IPv6\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/isoDate/isoDate.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction isoDate(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"iso_date\",\n\t\treference: isoDate,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: ISO_DATE_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"date\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/isoDateTime/isoDateTime.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction isoDateTime(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"iso_date_time\",\n\t\treference: isoDateTime,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: ISO_DATE_TIME_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"date-time\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/isoTime/isoTime.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction isoTime(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"iso_time\",\n\t\treference: isoTime,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: ISO_TIME_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"time\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/isoTimeSecond/isoTimeSecond.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction isoTimeSecond(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"iso_time_second\",\n\t\treference: isoTimeSecond,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: ISO_TIME_SECOND_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"time-second\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/isoTimestamp/isoTimestamp.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction isoTimestamp(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"iso_timestamp\",\n\t\treference: isoTimestamp,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: ISO_TIMESTAMP_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"timestamp\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/isoWeek/isoWeek.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction isoWeek(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"iso_week\",\n\t\treference: isoWeek,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: ISO_WEEK_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"week\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/length/length.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction length(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"length\",\n\t\treference: length,\n\t\tasync: false,\n\t\texpects: `${requirement}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && dataset.value.length !== this.requirement) _addIssue(this, \"length\", dataset, config$1, { received: `${dataset.value.length}` });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/ltValue/ltValue.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction ltValue(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"lt_value\",\n\t\treference: ltValue,\n\t\tasync: false,\n\t\texpects: `<${requirement instanceof Date ? requirement.toJSON() : /* @__PURE__ */ _stringify(requirement)}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !(dataset.value < this.requirement)) _addIssue(this, \"value\", dataset, config$1, { received: dataset.value instanceof Date ? dataset.value.toJSON() : /* @__PURE__ */ _stringify(dataset.value) });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/mac/mac.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction mac(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"mac\",\n\t\treference: mac,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: MAC_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"MAC\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/mac48/mac48.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction mac48(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"mac48\",\n\t\treference: mac48,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: MAC48_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"48-bit MAC\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/mac64/mac64.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction mac64(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"mac64\",\n\t\treference: mac64,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: MAC64_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"64-bit MAC\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/mapItems/mapItems.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction mapItems(operation) {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"map_items\",\n\t\treference: mapItems,\n\t\tasync: false,\n\t\toperation,\n\t\t\"~run\"(dataset) {\n\t\t\tdataset.value = dataset.value.map(this.operation);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/maxBytes/maxBytes.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction maxBytes(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"max_bytes\",\n\t\treference: maxBytes,\n\t\tasync: false,\n\t\texpects: `<=${requirement}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed) {\n\t\t\t\tconst length$1 = /* @__PURE__ */ _getByteCount(dataset.value);\n\t\t\t\tif (length$1 > this.requirement) _addIssue(this, \"bytes\", dataset, config$1, { received: `${length$1}` });\n\t\t\t}\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/maxEntries/maxEntries.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction maxEntries(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"max_entries\",\n\t\treference: maxEntries,\n\t\tasync: false,\n\t\texpects: `<=${requirement}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (!dataset.typed) return dataset;\n\t\t\tconst count = Object.keys(dataset.value).length;\n\t\t\tif (dataset.typed && count > this.requirement) _addIssue(this, \"entries\", dataset, config$1, { received: `${count}` });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/maxGraphemes/maxGraphemes.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction maxGraphemes(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"max_graphemes\",\n\t\treference: maxGraphemes,\n\t\tasync: false,\n\t\texpects: `<=${requirement}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed) {\n\t\t\t\tconst count = /* @__PURE__ */ _getGraphemeCount(dataset.value);\n\t\t\t\tif (count > this.requirement) _addIssue(this, \"graphemes\", dataset, config$1, { received: `${count}` });\n\t\t\t}\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/maxLength/maxLength.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction maxLength(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"max_length\",\n\t\treference: maxLength,\n\t\tasync: false,\n\t\texpects: `<=${requirement}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && dataset.value.length > this.requirement) _addIssue(this, \"length\", dataset, config$1, { received: `${dataset.value.length}` });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/maxSize/maxSize.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction maxSize(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"max_size\",\n\t\treference: maxSize,\n\t\tasync: false,\n\t\texpects: `<=${requirement}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && dataset.value.size > this.requirement) _addIssue(this, \"size\", dataset, config$1, { received: `${dataset.value.size}` });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/maxValue/maxValue.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction maxValue(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"max_value\",\n\t\treference: maxValue,\n\t\tasync: false,\n\t\texpects: `<=${requirement instanceof Date ? requirement.toJSON() : /* @__PURE__ */ _stringify(requirement)}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !(dataset.value <= this.requirement)) _addIssue(this, \"value\", dataset, config$1, { received: dataset.value instanceof Date ? dataset.value.toJSON() : /* @__PURE__ */ _stringify(dataset.value) });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/maxWords/maxWords.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction maxWords(locales, requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"max_words\",\n\t\treference: maxWords,\n\t\tasync: false,\n\t\texpects: `<=${requirement}`,\n\t\tlocales,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed) {\n\t\t\t\tconst count = /* @__PURE__ */ _getWordCount(this.locales, dataset.value);\n\t\t\t\tif (count > this.requirement) _addIssue(this, \"words\", dataset, config$1, { received: `${count}` });\n\t\t\t}\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/metadata/metadata.ts\n/**\n* Creates a custom metadata action.\n*\n* @param metadata_ The metadata object.\n*\n* @returns A metadata action.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction metadata(metadata_) {\n\treturn {\n\t\tkind: \"metadata\",\n\t\ttype: \"metadata\",\n\t\treference: metadata,\n\t\tmetadata: metadata_\n\t};\n}\n\n//#endregion\n//#region src/actions/mimeType/mimeType.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction mimeType(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"mime_type\",\n\t\treference: mimeType,\n\t\tasync: false,\n\t\texpects: /* @__PURE__ */ _joinExpects(requirement.map((option) => `\"${option}\"`), \"|\"),\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.includes(dataset.value.type)) _addIssue(this, \"MIME type\", dataset, config$1, { received: `\"${dataset.value.type}\"` });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/minBytes/minBytes.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction minBytes(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"min_bytes\",\n\t\treference: minBytes,\n\t\tasync: false,\n\t\texpects: `>=${requirement}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed) {\n\t\t\t\tconst length$1 = /* @__PURE__ */ _getByteCount(dataset.value);\n\t\t\t\tif (length$1 < this.requirement) _addIssue(this, \"bytes\", dataset, config$1, { received: `${length$1}` });\n\t\t\t}\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/minEntries/minEntries.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction minEntries(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"min_entries\",\n\t\treference: minEntries,\n\t\tasync: false,\n\t\texpects: `>=${requirement}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (!dataset.typed) return dataset;\n\t\t\tconst count = Object.keys(dataset.value).length;\n\t\t\tif (dataset.typed && count < this.requirement) _addIssue(this, \"entries\", dataset, config$1, { received: `${count}` });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/minGraphemes/minGraphemes.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction minGraphemes(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"min_graphemes\",\n\t\treference: minGraphemes,\n\t\tasync: false,\n\t\texpects: `>=${requirement}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed) {\n\t\t\t\tconst count = /* @__PURE__ */ _getGraphemeCount(dataset.value);\n\t\t\t\tif (count < this.requirement) _addIssue(this, \"graphemes\", dataset, config$1, { received: `${count}` });\n\t\t\t}\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/minLength/minLength.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction minLength(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"min_length\",\n\t\treference: minLength,\n\t\tasync: false,\n\t\texpects: `>=${requirement}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && dataset.value.length < this.requirement) _addIssue(this, \"length\", dataset, config$1, { received: `${dataset.value.length}` });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/minSize/minSize.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction minSize(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"min_size\",\n\t\treference: minSize,\n\t\tasync: false,\n\t\texpects: `>=${requirement}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && dataset.value.size < this.requirement) _addIssue(this, \"size\", dataset, config$1, { received: `${dataset.value.size}` });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/minValue/minValue.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction minValue(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"min_value\",\n\t\treference: minValue,\n\t\tasync: false,\n\t\texpects: `>=${requirement instanceof Date ? requirement.toJSON() : /* @__PURE__ */ _stringify(requirement)}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !(dataset.value >= this.requirement)) _addIssue(this, \"value\", dataset, config$1, { received: dataset.value instanceof Date ? dataset.value.toJSON() : /* @__PURE__ */ _stringify(dataset.value) });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/minWords/minWords.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction minWords(locales, requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"min_words\",\n\t\treference: minWords,\n\t\tasync: false,\n\t\texpects: `>=${requirement}`,\n\t\tlocales,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed) {\n\t\t\t\tconst count = /* @__PURE__ */ _getWordCount(this.locales, dataset.value);\n\t\t\t\tif (count < this.requirement) _addIssue(this, \"words\", dataset, config$1, { received: `${count}` });\n\t\t\t}\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/multipleOf/multipleOf.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction multipleOf(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"multiple_of\",\n\t\treference: multipleOf,\n\t\tasync: false,\n\t\texpects: `%${requirement}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && dataset.value % this.requirement != 0) _addIssue(this, \"multiple\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/nanoid/nanoid.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction nanoid(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"nanoid\",\n\t\treference: nanoid,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: NANO_ID_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"Nano ID\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/nonEmpty/nonEmpty.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction nonEmpty(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"non_empty\",\n\t\treference: nonEmpty,\n\t\tasync: false,\n\t\texpects: \"!0\",\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && dataset.value.length === 0) _addIssue(this, \"length\", dataset, config$1, { received: \"0\" });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/normalize/normalize.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction normalize(form) {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"normalize\",\n\t\treference: normalize,\n\t\tasync: false,\n\t\tform,\n\t\t\"~run\"(dataset) {\n\t\t\tdataset.value = dataset.value.normalize(this.form);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/notBytes/notBytes.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction notBytes(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"not_bytes\",\n\t\treference: notBytes,\n\t\tasync: false,\n\t\texpects: `!${requirement}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed) {\n\t\t\t\tconst length$1 = /* @__PURE__ */ _getByteCount(dataset.value);\n\t\t\t\tif (length$1 === this.requirement) _addIssue(this, \"bytes\", dataset, config$1, { received: `${length$1}` });\n\t\t\t}\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/notEntries/notEntries.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction notEntries(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"not_entries\",\n\t\treference: notEntries,\n\t\tasync: false,\n\t\texpects: `!${requirement}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (!dataset.typed) return dataset;\n\t\t\tconst count = Object.keys(dataset.value).length;\n\t\t\tif (dataset.typed && count === this.requirement) _addIssue(this, \"entries\", dataset, config$1, { received: `${count}` });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/notGraphemes/notGraphemes.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction notGraphemes(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"not_graphemes\",\n\t\treference: notGraphemes,\n\t\tasync: false,\n\t\texpects: `!${requirement}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed) {\n\t\t\t\tconst count = /* @__PURE__ */ _getGraphemeCount(dataset.value);\n\t\t\t\tif (count === this.requirement) _addIssue(this, \"graphemes\", dataset, config$1, { received: `${count}` });\n\t\t\t}\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/notLength/notLength.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction notLength(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"not_length\",\n\t\treference: notLength,\n\t\tasync: false,\n\t\texpects: `!${requirement}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && dataset.value.length === this.requirement) _addIssue(this, \"length\", dataset, config$1, { received: `${dataset.value.length}` });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/notSize/notSize.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction notSize(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"not_size\",\n\t\treference: notSize,\n\t\tasync: false,\n\t\texpects: `!${requirement}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && dataset.value.size === this.requirement) _addIssue(this, \"size\", dataset, config$1, { received: `${dataset.value.size}` });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/notValue/notValue.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction notValue(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"not_value\",\n\t\treference: notValue,\n\t\tasync: false,\n\t\texpects: requirement instanceof Date ? `!${requirement.toJSON()}` : `!${/* @__PURE__ */ _stringify(requirement)}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && this.requirement <= dataset.value && this.requirement >= dataset.value) _addIssue(this, \"value\", dataset, config$1, { received: dataset.value instanceof Date ? dataset.value.toJSON() : /* @__PURE__ */ _stringify(dataset.value) });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/notValues/notValues.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction notValues(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"not_values\",\n\t\treference: notValues,\n\t\tasync: false,\n\t\texpects: `!${/* @__PURE__ */ _joinExpects(requirement.map((value$1) => value$1 instanceof Date ? value$1.toJSON() : /* @__PURE__ */ _stringify(value$1)), \"|\")}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && this.requirement.some((value$1) => value$1 <= dataset.value && value$1 >= dataset.value)) _addIssue(this, \"value\", dataset, config$1, { received: dataset.value instanceof Date ? dataset.value.toJSON() : /* @__PURE__ */ _stringify(dataset.value) });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/notWords/notWords.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction notWords(locales, requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"not_words\",\n\t\treference: notWords,\n\t\tasync: false,\n\t\texpects: `!${requirement}`,\n\t\tlocales,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed) {\n\t\t\t\tconst count = /* @__PURE__ */ _getWordCount(this.locales, dataset.value);\n\t\t\t\tif (count === this.requirement) _addIssue(this, \"words\", dataset, config$1, { received: `${count}` });\n\t\t\t}\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/octal/octal.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction octal(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"octal\",\n\t\treference: octal,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: OCTAL_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"octal\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/parseJson/parseJson.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction parseJson(config$1, message$1) {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"parse_json\",\n\t\treference: parseJson,\n\t\tconfig: config$1,\n\t\tmessage: message$1,\n\t\tasync: false,\n\t\t\"~run\"(dataset, config$2) {\n\t\t\ttry {\n\t\t\t\tdataset.value = JSON.parse(dataset.value, this.config?.reviver);\n\t\t\t} catch (error) {\n\t\t\t\tif (error instanceof Error) {\n\t\t\t\t\t_addIssue(this, \"JSON\", dataset, config$2, { received: `\"${error.message}\"` });\n\t\t\t\t\tdataset.typed = false;\n\t\t\t\t} else throw error;\n\t\t\t}\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/partialCheck/utils/_isPartiallyTyped/_isPartiallyTyped.ts\n/**\n* Checks if a dataset is partially typed.\n*\n* @param dataset The dataset to check.\n* @param paths The paths to check.\n*\n* @returns Whether it is partially typed.\n*\n* @internal\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction _isPartiallyTyped(dataset, paths) {\n\tif (dataset.issues) for (const path of paths) for (const issue of dataset.issues) {\n\t\tlet typed = false;\n\t\tconst bound = Math.min(path.length, issue.path?.length ?? 0);\n\t\tfor (let index = 0; index < bound; index++) if (path[index] !== issue.path[index].key && (path[index] !== \"$\" || issue.path[index].type !== \"array\")) {\n\t\t\ttyped = true;\n\t\t\tbreak;\n\t\t}\n\t\tif (!typed) return false;\n\t}\n\treturn true;\n}\n\n//#endregion\n//#region src/actions/partialCheck/partialCheck.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction partialCheck(paths, requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"partial_check\",\n\t\treference: partialCheck,\n\t\tasync: false,\n\t\texpects: null,\n\t\tpaths,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif ((dataset.typed || /* @__PURE__ */ _isPartiallyTyped(dataset, paths)) && !this.requirement(dataset.value)) _addIssue(this, \"input\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/partialCheck/partialCheckAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction partialCheckAsync(paths, requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"partial_check\",\n\t\treference: partialCheckAsync,\n\t\tasync: true,\n\t\texpects: null,\n\t\tpaths,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tif ((dataset.typed || /* @__PURE__ */ _isPartiallyTyped(dataset, paths)) && !await this.requirement(dataset.value)) _addIssue(this, \"input\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/rawCheck/rawCheck.ts\n/**\n* Creates a raw check validation action.\n*\n* @param action The validation action.\n*\n* @returns A raw check action.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction rawCheck(action) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"raw_check\",\n\t\treference: rawCheck,\n\t\tasync: false,\n\t\texpects: null,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\taction({\n\t\t\t\tdataset,\n\t\t\t\tconfig: config$1,\n\t\t\t\taddIssue: (info) => _addIssue(this, info?.label ?? \"input\", dataset, config$1, info)\n\t\t\t});\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/rawCheck/rawCheckAsync.ts\n/**\n* Creates a raw check validation action.\n*\n* @param action The validation action.\n*\n* @returns A raw check action.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction rawCheckAsync(action) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"raw_check\",\n\t\treference: rawCheckAsync,\n\t\tasync: true,\n\t\texpects: null,\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tawait action({\n\t\t\t\tdataset,\n\t\t\t\tconfig: config$1,\n\t\t\t\taddIssue: (info) => _addIssue(this, info?.label ?? \"input\", dataset, config$1, info)\n\t\t\t});\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/rawTransform/rawTransform.ts\n/**\n* Creates a raw transformation action.\n*\n* @param action The transformation action.\n*\n* @returns A raw transform action.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction rawTransform(action) {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"raw_transform\",\n\t\treference: rawTransform,\n\t\tasync: false,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tconst output = action({\n\t\t\t\tdataset,\n\t\t\t\tconfig: config$1,\n\t\t\t\taddIssue: (info) => _addIssue(this, info?.label ?? \"input\", dataset, config$1, info),\n\t\t\t\tNEVER: null\n\t\t\t});\n\t\t\tif (dataset.issues) dataset.typed = false;\n\t\t\telse dataset.value = output;\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/rawTransform/rawTransformAsync.ts\n/**\n* Creates a raw transformation action.\n*\n* @param action The transformation action.\n*\n* @returns A raw transform action.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction rawTransformAsync(action) {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"raw_transform\",\n\t\treference: rawTransformAsync,\n\t\tasync: true,\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tconst output = await action({\n\t\t\t\tdataset,\n\t\t\t\tconfig: config$1,\n\t\t\t\taddIssue: (info) => _addIssue(this, info?.label ?? \"input\", dataset, config$1, info),\n\t\t\t\tNEVER: null\n\t\t\t});\n\t\t\tif (dataset.issues) dataset.typed = false;\n\t\t\telse dataset.value = output;\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/readonly/readonly.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction readonly() {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"readonly\",\n\t\treference: readonly,\n\t\tasync: false,\n\t\t\"~run\"(dataset) {\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/reduceItems/reduceItems.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction reduceItems(operation, initial) {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"reduce_items\",\n\t\treference: reduceItems,\n\t\tasync: false,\n\t\toperation,\n\t\tinitial,\n\t\t\"~run\"(dataset) {\n\t\t\tdataset.value = dataset.value.reduce(this.operation, this.initial);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/regex/regex.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction regex(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"regex\",\n\t\treference: regex,\n\t\tasync: false,\n\t\texpects: `${requirement}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"format\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/returns/returns.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction returns(schema) {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"returns\",\n\t\treference: returns,\n\t\tasync: false,\n\t\tschema,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tconst func = dataset.value;\n\t\t\tdataset.value = (...args_) => {\n\t\t\t\tconst returnsDataset = this.schema[\"~run\"]({ value: func(...args_) }, config$1);\n\t\t\t\tif (returnsDataset.issues) throw new ValiError(returnsDataset.issues);\n\t\t\t\treturn returnsDataset.value;\n\t\t\t};\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/returns/returnsAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction returnsAsync(schema) {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"returns\",\n\t\treference: returnsAsync,\n\t\tasync: false,\n\t\tschema,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tconst func = dataset.value;\n\t\t\tdataset.value = async (...args_) => {\n\t\t\t\tconst returnsDataset = await this.schema[\"~run\"]({ value: await func(...args_) }, config$1);\n\t\t\t\tif (returnsDataset.issues) throw new ValiError(returnsDataset.issues);\n\t\t\t\treturn returnsDataset.value;\n\t\t\t};\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/rfcEmail/rfcEmail.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction rfcEmail(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"rfc_email\",\n\t\treference: rfcEmail,\n\t\texpects: null,\n\t\tasync: false,\n\t\trequirement: RFC_EMAIL_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"email\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/safeInteger/safeInteger.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction safeInteger(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"safe_integer\",\n\t\treference: safeInteger,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: Number.isSafeInteger,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement(dataset.value)) _addIssue(this, \"safe integer\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/size/size.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction size(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"size\",\n\t\treference: size,\n\t\tasync: false,\n\t\texpects: `${requirement}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && dataset.value.size !== this.requirement) _addIssue(this, \"size\", dataset, config$1, { received: `${dataset.value.size}` });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/slug/slug.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction slug(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"slug\",\n\t\treference: slug,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: SLUG_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"slug\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/someItem/someItem.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction someItem(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"some_item\",\n\t\treference: someItem,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !dataset.value.some(this.requirement)) _addIssue(this, \"item\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/sortItems/sortItems.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction sortItems(operation) {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"sort_items\",\n\t\treference: sortItems,\n\t\tasync: false,\n\t\toperation,\n\t\t\"~run\"(dataset) {\n\t\t\tdataset.value = dataset.value.sort(this.operation);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/startsWith/startsWith.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction startsWith(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"starts_with\",\n\t\treference: startsWith,\n\t\tasync: false,\n\t\texpects: `\"${requirement}\"`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !dataset.value.startsWith(this.requirement)) _addIssue(this, \"start\", dataset, config$1, { received: `\"${dataset.value.slice(0, this.requirement.length)}\"` });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/stringifyJson/stringifyJson.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction stringifyJson(config$1, message$1) {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"stringify_json\",\n\t\treference: stringifyJson,\n\t\tmessage: message$1,\n\t\tconfig: config$1,\n\t\tasync: false,\n\t\t\"~run\"(dataset, config$2) {\n\t\t\ttry {\n\t\t\t\tconst output = JSON.stringify(dataset.value, this.config?.replacer, this.config?.space);\n\t\t\t\tif (output === void 0) {\n\t\t\t\t\t_addIssue(this, \"JSON\", dataset, config$2);\n\t\t\t\t\tdataset.typed = false;\n\t\t\t\t}\n\t\t\t\tdataset.value = output;\n\t\t\t} catch (error) {\n\t\t\t\tif (error instanceof Error) {\n\t\t\t\t\t_addIssue(this, \"JSON\", dataset, config$2, { received: `\"${error.message}\"` });\n\t\t\t\t\tdataset.typed = false;\n\t\t\t\t} else throw error;\n\t\t\t}\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/title/title.ts\n/**\n* Creates a title metadata action.\n*\n* @param title_ The title text.\n*\n* @returns A title action.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction title(title_) {\n\treturn {\n\t\tkind: \"metadata\",\n\t\ttype: \"title\",\n\t\treference: title,\n\t\ttitle: title_\n\t};\n}\n\n//#endregion\n//#region src/actions/toBigint/toBigint.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction toBigint(message$1) {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"to_bigint\",\n\t\treference: toBigint,\n\t\tasync: false,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\ttry {\n\t\t\t\tdataset.value = BigInt(dataset.value);\n\t\t\t} catch {\n\t\t\t\t_addIssue(this, \"bigint\", dataset, config$1);\n\t\t\t\tdataset.typed = false;\n\t\t\t}\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/toBoolean/toBoolean.ts\n/**\n* Creates a to boolean transformation action.\n*\n* @returns A to boolean action.\n*\n* @beta\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction toBoolean() {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"to_boolean\",\n\t\treference: toBoolean,\n\t\tasync: false,\n\t\t\"~run\"(dataset) {\n\t\t\tdataset.value = Boolean(dataset.value);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/toDate/toDate.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction toDate(message$1) {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"to_date\",\n\t\treference: toDate,\n\t\tasync: false,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\ttry {\n\t\t\t\tdataset.value = new Date(dataset.value);\n\t\t\t\tif (isNaN(dataset.value)) {\n\t\t\t\t\t_addIssue(this, \"date\", dataset, config$1, { received: \"\\\"Invalid Date\\\"\" });\n\t\t\t\t\tdataset.typed = false;\n\t\t\t\t}\n\t\t\t} catch {\n\t\t\t\t_addIssue(this, \"date\", dataset, config$1);\n\t\t\t\tdataset.typed = false;\n\t\t\t}\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/toLowerCase/toLowerCase.ts\n/**\n* Creates a to lower case transformation action.\n*\n* @returns A to lower case action.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction toLowerCase() {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"to_lower_case\",\n\t\treference: toLowerCase,\n\t\tasync: false,\n\t\t\"~run\"(dataset) {\n\t\t\tdataset.value = dataset.value.toLowerCase();\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/toMaxValue/toMaxValue.ts\n/**\n* Creates a to max value transformation action.\n*\n* @param requirement The maximum value.\n*\n* @returns A to max value action.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction toMaxValue(requirement) {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"to_max_value\",\n\t\treference: toMaxValue,\n\t\tasync: false,\n\t\trequirement,\n\t\t\"~run\"(dataset) {\n\t\t\tdataset.value = dataset.value > this.requirement ? this.requirement : dataset.value;\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/toMinValue/toMinValue.ts\n/**\n* Creates a to min value transformation action.\n*\n* @param requirement The minimum value.\n*\n* @returns A to min value action.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction toMinValue(requirement) {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"to_min_value\",\n\t\treference: toMinValue,\n\t\tasync: false,\n\t\trequirement,\n\t\t\"~run\"(dataset) {\n\t\t\tdataset.value = dataset.value < this.requirement ? this.requirement : dataset.value;\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/toNumber/toNumber.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction toNumber(message$1) {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"to_number\",\n\t\treference: toNumber,\n\t\tasync: false,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\ttry {\n\t\t\t\tdataset.value = Number(dataset.value);\n\t\t\t\tif (isNaN(dataset.value)) {\n\t\t\t\t\t_addIssue(this, \"number\", dataset, config$1);\n\t\t\t\t\tdataset.typed = false;\n\t\t\t\t}\n\t\t\t} catch {\n\t\t\t\t_addIssue(this, \"number\", dataset, config$1);\n\t\t\t\tdataset.typed = false;\n\t\t\t}\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/toString/toString.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction toString(message$1) {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"to_string\",\n\t\treference: toString,\n\t\tasync: false,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\ttry {\n\t\t\t\tdataset.value = String(dataset.value);\n\t\t\t} catch {\n\t\t\t\t_addIssue(this, \"string\", dataset, config$1);\n\t\t\t\tdataset.typed = false;\n\t\t\t}\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/toUpperCase/toUpperCase.ts\n/**\n* Creates a to upper case transformation action.\n*\n* @returns A to upper case action.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction toUpperCase() {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"to_upper_case\",\n\t\treference: toUpperCase,\n\t\tasync: false,\n\t\t\"~run\"(dataset) {\n\t\t\tdataset.value = dataset.value.toUpperCase();\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/transform/transform.ts\n/**\n* Creates a custom transformation action.\n*\n* @param operation The transformation operation.\n*\n* @returns A transform action.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction transform(operation) {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"transform\",\n\t\treference: transform,\n\t\tasync: false,\n\t\toperation,\n\t\t\"~run\"(dataset) {\n\t\t\tdataset.value = this.operation(dataset.value);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/transform/transformAsync.ts\n/**\n* Creates a custom transformation action.\n*\n* @param operation The transformation operation.\n*\n* @returns A transform action.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction transformAsync(operation) {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"transform\",\n\t\treference: transformAsync,\n\t\tasync: true,\n\t\toperation,\n\t\tasync \"~run\"(dataset) {\n\t\t\tdataset.value = await this.operation(dataset.value);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/trim/trim.ts\n/**\n* Creates a trim transformation action.\n*\n* @returns A trim action.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction trim() {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"trim\",\n\t\treference: trim,\n\t\tasync: false,\n\t\t\"~run\"(dataset) {\n\t\t\tdataset.value = dataset.value.trim();\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/trimEnd/trimEnd.ts\n/**\n* Creates a trim end transformation action.\n*\n* @returns A trim end action.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction trimEnd() {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"trim_end\",\n\t\treference: trimEnd,\n\t\tasync: false,\n\t\t\"~run\"(dataset) {\n\t\t\tdataset.value = dataset.value.trimEnd();\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/trimStart/trimStart.ts\n/**\n* Creates a trim start transformation action.\n*\n* @returns A trim start action.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction trimStart() {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"trim_start\",\n\t\treference: trimStart,\n\t\tasync: false,\n\t\t\"~run\"(dataset) {\n\t\t\tdataset.value = dataset.value.trimStart();\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/ulid/ulid.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction ulid(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"ulid\",\n\t\treference: ulid,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: ULID_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"ULID\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/url/url.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction url(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"url\",\n\t\treference: url,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement(input) {\n\t\t\ttry {\n\t\t\t\tnew URL(input);\n\t\t\t\treturn true;\n\t\t\t} catch {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t},\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement(dataset.value)) _addIssue(this, \"URL\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/uuid/uuid.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction uuid(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"uuid\",\n\t\treference: uuid,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: UUID_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"UUID\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/value/value.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction value(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"value\",\n\t\treference: value,\n\t\tasync: false,\n\t\texpects: requirement instanceof Date ? requirement.toJSON() : /* @__PURE__ */ _stringify(requirement),\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !(this.requirement <= dataset.value && this.requirement >= dataset.value)) _addIssue(this, \"value\", dataset, config$1, { received: dataset.value instanceof Date ? dataset.value.toJSON() : /* @__PURE__ */ _stringify(dataset.value) });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/values/values.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction values(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"values\",\n\t\treference: values,\n\t\tasync: false,\n\t\texpects: `${/* @__PURE__ */ _joinExpects(requirement.map((value$1) => value$1 instanceof Date ? value$1.toJSON() : /* @__PURE__ */ _stringify(value$1)), \"|\")}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.some((value$1) => value$1 <= dataset.value && value$1 >= dataset.value)) _addIssue(this, \"value\", dataset, config$1, { received: dataset.value instanceof Date ? dataset.value.toJSON() : /* @__PURE__ */ _stringify(dataset.value) });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/words/words.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction words(locales, requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"words\",\n\t\treference: words,\n\t\tasync: false,\n\t\texpects: `${requirement}`,\n\t\tlocales,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed) {\n\t\t\t\tconst count = /* @__PURE__ */ _getWordCount(this.locales, dataset.value);\n\t\t\t\tif (count !== this.requirement) _addIssue(this, \"words\", dataset, config$1, { received: `${count}` });\n\t\t\t}\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/methods/assert/assert.ts\n/**\n* Checks if the input matches the schema. As this is an assertion function, it\n* can be used as a type guard.\n*\n* @param schema The schema to be used.\n* @param input The input to be tested.\n*/\nfunction assert(schema, input) {\n\tconst issues = schema[\"~run\"]({ value: input }, { abortEarly: true }).issues;\n\tif (issues) throw new ValiError(issues);\n}\n\n//#endregion\n//#region src/methods/config/config.ts\n/**\n* Changes the local configuration of a schema.\n*\n* @param schema The schema to configure.\n* @param config The parse configuration.\n*\n* @returns The configured schema.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction config(schema, config$1) {\n\treturn {\n\t\t...schema,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config_) {\n\t\t\treturn schema[\"~run\"](dataset, {\n\t\t\t\t...config_,\n\t\t\t\t...config$1\n\t\t\t});\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/methods/getFallback/getFallback.ts\n/**\n* Returns the fallback value of the schema.\n*\n* @param schema The schema to get it from.\n* @param dataset The output dataset if available.\n* @param config The config if available.\n*\n* @returns The fallback value.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction getFallback(schema, dataset, config$1) {\n\treturn typeof schema.fallback === \"function\" ? schema.fallback(dataset, config$1) : schema.fallback;\n}\n\n//#endregion\n//#region src/methods/fallback/fallback.ts\n/**\n* Returns a fallback value as output if the input does not match the schema.\n*\n* @param schema The schema to catch.\n* @param fallback The fallback value.\n*\n* @returns The passed schema.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction fallback(schema, fallback$1) {\n\treturn {\n\t\t...schema,\n\t\tfallback: fallback$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tconst outputDataset = schema[\"~run\"](dataset, config$1);\n\t\t\treturn outputDataset.issues ? {\n\t\t\t\ttyped: true,\n\t\t\t\tvalue: /* @__PURE__ */ getFallback(this, outputDataset, config$1)\n\t\t\t} : outputDataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/methods/fallback/fallbackAsync.ts\n/**\n* Returns a fallback value as output if the input does not match the schema.\n*\n* @param schema The schema to catch.\n* @param fallback The fallback value.\n*\n* @returns The passed schema.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction fallbackAsync(schema, fallback$1) {\n\treturn {\n\t\t...schema,\n\t\tfallback: fallback$1,\n\t\tasync: true,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tconst outputDataset = await schema[\"~run\"](dataset, config$1);\n\t\t\treturn outputDataset.issues ? {\n\t\t\t\ttyped: true,\n\t\t\t\tvalue: await /* @__PURE__ */ getFallback(this, outputDataset, config$1)\n\t\t\t} : outputDataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/methods/flatten/flatten.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction flatten(issues) {\n\tconst flatErrors = {};\n\tfor (const issue of issues) if (issue.path) {\n\t\tconst dotPath = /* @__PURE__ */ getDotPath(issue);\n\t\tif (dotPath) {\n\t\t\tif (!flatErrors.nested) flatErrors.nested = {};\n\t\t\tif (flatErrors.nested[dotPath]) flatErrors.nested[dotPath].push(issue.message);\n\t\t\telse flatErrors.nested[dotPath] = [issue.message];\n\t\t} else if (flatErrors.other) flatErrors.other.push(issue.message);\n\t\telse flatErrors.other = [issue.message];\n\t} else if (flatErrors.root) flatErrors.root.push(issue.message);\n\telse flatErrors.root = [issue.message];\n\treturn flatErrors;\n}\n\n//#endregion\n//#region src/methods/forward/forward.ts\n/**\n* Forwards the issues of the passed validation action.\n*\n* @param action The validation action.\n* @param path The path to forward the issues to.\n*\n* @returns The modified action.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction forward(action, path) {\n\treturn {\n\t\t...action,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tconst prevIssues = dataset.issues && [...dataset.issues];\n\t\t\tdataset = action[\"~run\"](dataset, config$1);\n\t\t\tif (dataset.issues) {\n\t\t\t\tfor (const issue of dataset.issues) if (!prevIssues?.includes(issue)) {\n\t\t\t\t\tlet pathInput = dataset.value;\n\t\t\t\t\tfor (const key of path) {\n\t\t\t\t\t\tconst pathValue = pathInput[key];\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"unknown\",\n\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\tinput: pathInput,\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue: pathValue\n\t\t\t\t\t\t};\n\t\t\t\t\t\tif (issue.path) issue.path.push(pathItem);\n\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\tif (!pathValue) break;\n\t\t\t\t\t\tpathInput = pathValue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/methods/forward/forwardAsync.ts\n/**\n* Forwards the issues of the passed validation action.\n*\n* @param action The validation action.\n* @param path The path to forward the issues to.\n*\n* @returns The modified action.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction forwardAsync(action, path) {\n\treturn {\n\t\t...action,\n\t\tasync: true,\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tconst prevIssues = dataset.issues && [...dataset.issues];\n\t\t\tdataset = await action[\"~run\"](dataset, config$1);\n\t\t\tif (dataset.issues) {\n\t\t\t\tfor (const issue of dataset.issues) if (!prevIssues?.includes(issue)) {\n\t\t\t\t\tlet pathInput = dataset.value;\n\t\t\t\t\tfor (const key of path) {\n\t\t\t\t\t\tconst pathValue = pathInput[key];\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"unknown\",\n\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\tinput: pathInput,\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue: pathValue\n\t\t\t\t\t\t};\n\t\t\t\t\t\tif (issue.path) issue.path.push(pathItem);\n\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\tif (!pathValue) break;\n\t\t\t\t\t\tpathInput = pathValue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/methods/getDefault/getDefault.ts\n/**\n* Returns the default value of the schema.\n*\n* @param schema The schema to get it from.\n* @param dataset The input dataset if available.\n* @param config The config if available.\n*\n* @returns The default value.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction getDefault(schema, dataset, config$1) {\n\treturn typeof schema.default === \"function\" ? schema.default(dataset, config$1) : schema.default;\n}\n\n//#endregion\n//#region src/methods/getDefaults/getDefaults.ts\n/**\n* Returns the default values of the schema.\n*\n* Hint: The difference to `getDefault` is that for object and tuple schemas\n* this function recursively returns the default values of the subschemas\n* instead of `undefined`.\n*\n* @param schema The schema to get them from.\n*\n* @returns The default values.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction getDefaults(schema) {\n\tif (\"entries\" in schema) {\n\t\tconst object$1 = {};\n\t\tfor (const key in schema.entries) object$1[key] = /* @__PURE__ */ getDefaults(schema.entries[key]);\n\t\treturn object$1;\n\t}\n\tif (\"items\" in schema) return schema.items.map(getDefaults);\n\treturn /* @__PURE__ */ getDefault(schema);\n}\n\n//#endregion\n//#region src/methods/getDefaults/getDefaultsAsync.ts\n/**\n* Returns the default values of the schema.\n*\n* Hint: The difference to `getDefault` is that for object and tuple schemas\n* this function recursively returns the default values of the subschemas\n* instead of `undefined`.\n*\n* @param schema The schema to get them from.\n*\n* @returns The default values.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nasync function getDefaultsAsync(schema) {\n\tif (\"entries\" in schema) return Object.fromEntries(await Promise.all(Object.entries(schema.entries).map(async ([key, value$1]) => [key, await /* @__PURE__ */ getDefaultsAsync(value$1)])));\n\tif (\"items\" in schema) return Promise.all(schema.items.map(getDefaultsAsync));\n\treturn /* @__PURE__ */ getDefault(schema);\n}\n\n//#endregion\n//#region src/methods/getDescription/getDescription.ts\n/**\n* Returns the description of the schema.\n*\n* If multiple descriptions are defined, the last one of the highest level is\n* returned. If no description is defined, `undefined` is returned.\n*\n* @param schema The schema to get the description from.\n*\n* @returns The description, if any.\n*\n* @beta\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction getDescription(schema) {\n\treturn /* @__PURE__ */ _getLastMetadata(schema, \"description\");\n}\n\n//#endregion\n//#region src/methods/getExamples/getExamples.ts\n/**\n* Returns the examples of a schema.\n*\n* If multiple examples are defined, it concatenates them using depth-first\n* search. If no examples are defined, an empty array is returned.\n*\n* @param schema The schema to get the examples from.\n*\n* @returns The examples, if any.\n*\n* @beta\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction getExamples(schema) {\n\tconst examples$1 = [];\n\tfunction depthFirstCollect(schema$1) {\n\t\tif (\"pipe\" in schema$1) {\n\t\t\tfor (const item of schema$1.pipe) if (item.kind === \"schema\" && \"pipe\" in item) depthFirstCollect(item);\n\t\t\telse if (item.kind === \"metadata\" && item.type === \"examples\") examples$1.push(...item.examples);\n\t\t}\n\t}\n\tdepthFirstCollect(schema);\n\treturn examples$1;\n}\n\n//#endregion\n//#region src/methods/getFallbacks/getFallbacks.ts\n/**\n* Returns the fallback values of the schema.\n*\n* Hint: The difference to `getFallback` is that for object and tuple schemas\n* this function recursively returns the fallback values of the subschemas\n* instead of `undefined`.\n*\n* @param schema The schema to get them from.\n*\n* @returns The fallback values.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction getFallbacks(schema) {\n\tif (\"entries\" in schema) {\n\t\tconst object$1 = {};\n\t\tfor (const key in schema.entries) object$1[key] = /* @__PURE__ */ getFallbacks(schema.entries[key]);\n\t\treturn object$1;\n\t}\n\tif (\"items\" in schema) return schema.items.map(getFallbacks);\n\treturn /* @__PURE__ */ getFallback(schema);\n}\n\n//#endregion\n//#region src/methods/getFallbacks/getFallbacksAsync.ts\n/**\n* Returns the fallback values of the schema.\n*\n* Hint: The difference to `getFallback` is that for object and tuple schemas\n* this function recursively returns the fallback values of the subschemas\n* instead of `undefined`.\n*\n* @param schema The schema to get them from.\n*\n* @returns The fallback values.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nasync function getFallbacksAsync(schema) {\n\tif (\"entries\" in schema) return Object.fromEntries(await Promise.all(Object.entries(schema.entries).map(async ([key, value$1]) => [key, await /* @__PURE__ */ getFallbacksAsync(value$1)])));\n\tif (\"items\" in schema) return Promise.all(schema.items.map(getFallbacksAsync));\n\treturn /* @__PURE__ */ getFallback(schema);\n}\n\n//#endregion\n//#region src/methods/getMetadata/getMetadata.ts\n/**\n* Returns the metadata of a schema.\n*\n* If multiple metadata are defined, it shallowly merges them using depth-first\n* search. If no metadata is defined, an empty object is returned.\n*\n* @param schema Schema to get the metadata from.\n*\n* @returns The metadata, if any.\n*\n* @beta\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction getMetadata(schema) {\n\tconst result = {};\n\tfunction depthFirstMerge(schema$1) {\n\t\tif (\"pipe\" in schema$1) {\n\t\t\tfor (const item of schema$1.pipe) if (item.kind === \"schema\" && \"pipe\" in item) depthFirstMerge(item);\n\t\t\telse if (item.kind === \"metadata\" && item.type === \"metadata\") Object.assign(result, item.metadata);\n\t\t}\n\t}\n\tdepthFirstMerge(schema);\n\treturn result;\n}\n\n//#endregion\n//#region src/methods/getTitle/getTitle.ts\n/**\n* Returns the title of the schema.\n*\n* If multiple titles are defined, the last one of the highest level is\n* returned. If no title is defined, `undefined` is returned.\n*\n* @param schema The schema to get the title from.\n*\n* @returns The title, if any.\n*\n* @beta\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction getTitle(schema) {\n\treturn /* @__PURE__ */ _getLastMetadata(schema, \"title\");\n}\n\n//#endregion\n//#region src/methods/is/is.ts\n/**\n* Checks if the input matches the schema. By using a type predicate, this\n* function can be used as a type guard.\n*\n* @param schema The schema to be used.\n* @param input The input to be tested.\n*\n* @returns Whether the input matches the schema.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction is(schema, input) {\n\treturn !schema[\"~run\"]({ value: input }, { abortEarly: true }).issues;\n}\n\n//#endregion\n//#region src/schemas/any/any.ts\n/**\n* Creates an any schema.\n*\n* Hint: This schema function exists only for completeness and is not\n* recommended in practice. Instead, `unknown` should be used to accept\n* unknown data.\n*\n* @returns An any schema.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction any() {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"any\",\n\t\treference: any,\n\t\texpects: \"any\",\n\t\tasync: false,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset) {\n\t\t\tdataset.typed = true;\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/array/array.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction array(item, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"array\",\n\t\treference: array,\n\t\texpects: \"Array\",\n\t\tasync: false,\n\t\titem,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tconst input = dataset.value;\n\t\t\tif (Array.isArray(input)) {\n\t\t\t\tdataset.typed = true;\n\t\t\t\tdataset.value = [];\n\t\t\t\tfor (let key = 0; key < input.length; key++) {\n\t\t\t\t\tconst value$1 = input[key];\n\t\t\t\t\tconst itemDataset = this.item[\"~run\"]({ value: value$1 }, config$1);\n\t\t\t\t\tif (itemDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"array\",\n\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue: value$1\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of itemDataset.issues) {\n\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = itemDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!itemDataset.typed) dataset.typed = false;\n\t\t\t\t\tdataset.value.push(itemDataset.value);\n\t\t\t\t}\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/array/arrayAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction arrayAsync(item, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"array\",\n\t\treference: arrayAsync,\n\t\texpects: \"Array\",\n\t\tasync: true,\n\t\titem,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tconst input = dataset.value;\n\t\t\tif (Array.isArray(input)) {\n\t\t\t\tdataset.typed = true;\n\t\t\t\tdataset.value = [];\n\t\t\t\tconst itemDatasets = await Promise.all(input.map((value$1) => this.item[\"~run\"]({ value: value$1 }, config$1)));\n\t\t\t\tfor (let key = 0; key < itemDatasets.length; key++) {\n\t\t\t\t\tconst itemDataset = itemDatasets[key];\n\t\t\t\t\tif (itemDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"array\",\n\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue: input[key]\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of itemDataset.issues) {\n\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = itemDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!itemDataset.typed) dataset.typed = false;\n\t\t\t\t\tdataset.value.push(itemDataset.value);\n\t\t\t\t}\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/bigint/bigint.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction bigint(message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"bigint\",\n\t\treference: bigint,\n\t\texpects: \"bigint\",\n\t\tasync: false,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (typeof dataset.value === \"bigint\") dataset.typed = true;\n\t\t\telse _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/blob/blob.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction blob(message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"blob\",\n\t\treference: blob,\n\t\texpects: \"Blob\",\n\t\tasync: false,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.value instanceof Blob) dataset.typed = true;\n\t\t\telse _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/boolean/boolean.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction boolean(message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"boolean\",\n\t\treference: boolean,\n\t\texpects: \"boolean\",\n\t\tasync: false,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (typeof dataset.value === \"boolean\") dataset.typed = true;\n\t\t\telse _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/custom/custom.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction custom(check$1, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"custom\",\n\t\treference: custom,\n\t\texpects: \"unknown\",\n\t\tasync: false,\n\t\tcheck: check$1,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (this.check(dataset.value)) dataset.typed = true;\n\t\t\telse _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/custom/customAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction customAsync(check$1, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"custom\",\n\t\treference: customAsync,\n\t\texpects: \"unknown\",\n\t\tasync: true,\n\t\tcheck: check$1,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tif (await this.check(dataset.value)) dataset.typed = true;\n\t\t\telse _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/date/date.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction date(message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"date\",\n\t\treference: date,\n\t\texpects: \"Date\",\n\t\tasync: false,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.value instanceof Date) if (!isNaN(dataset.value)) dataset.typed = true;\n\t\t\telse _addIssue(this, \"type\", dataset, config$1, { received: \"\\\"Invalid Date\\\"\" });\n\t\t\telse _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/enum/enum.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction enum_(enum__, message$1) {\n\tconst options = [];\n\tfor (const key in enum__) if (`${+key}` !== key || typeof enum__[key] !== \"string\" || !Object.is(enum__[enum__[key]], +key)) options.push(enum__[key]);\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"enum\",\n\t\treference: enum_,\n\t\texpects: /* @__PURE__ */ _joinExpects(options.map(_stringify), \"|\"),\n\t\tasync: false,\n\t\tenum: enum__,\n\t\toptions,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (this.options.includes(dataset.value)) dataset.typed = true;\n\t\t\telse _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/exactOptional/exactOptional.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction exactOptional(wrapped, default_) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"exact_optional\",\n\t\treference: exactOptional,\n\t\texpects: wrapped.expects,\n\t\tasync: false,\n\t\twrapped,\n\t\tdefault: default_,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\treturn this.wrapped[\"~run\"](dataset, config$1);\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/exactOptional/exactOptionalAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction exactOptionalAsync(wrapped, default_) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"exact_optional\",\n\t\treference: exactOptionalAsync,\n\t\texpects: wrapped.expects,\n\t\tasync: true,\n\t\twrapped,\n\t\tdefault: default_,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\treturn this.wrapped[\"~run\"](dataset, config$1);\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/file/file.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction file(message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"file\",\n\t\treference: file,\n\t\texpects: \"File\",\n\t\tasync: false,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.value instanceof File) dataset.typed = true;\n\t\t\telse _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/function/function.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction function_(message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"function\",\n\t\treference: function_,\n\t\texpects: \"Function\",\n\t\tasync: false,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (typeof dataset.value === \"function\") dataset.typed = true;\n\t\t\telse _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/instance/instance.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction instance(class_, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"instance\",\n\t\treference: instance,\n\t\texpects: class_.name,\n\t\tasync: false,\n\t\tclass: class_,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.value instanceof this.class) dataset.typed = true;\n\t\t\telse _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/intersect/utils/_merge/_merge.ts\n/**\n* Merges two values into one single output.\n*\n* @param value1 First value.\n* @param value2 Second value.\n*\n* @returns The merge dataset.\n*\n* @internal\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction _merge(value1, value2) {\n\tif (typeof value1 === typeof value2) {\n\t\tif (value1 === value2 || value1 instanceof Date && value2 instanceof Date && +value1 === +value2) return { value: value1 };\n\t\tif (value1 && value2 && value1.constructor === Object && value2.constructor === Object) {\n\t\t\tfor (const key in value2) if (key in value1) {\n\t\t\t\tconst dataset = /* @__PURE__ */ _merge(value1[key], value2[key]);\n\t\t\t\tif (dataset.issue) return dataset;\n\t\t\t\tvalue1[key] = dataset.value;\n\t\t\t} else value1[key] = value2[key];\n\t\t\treturn { value: value1 };\n\t\t}\n\t\tif (Array.isArray(value1) && Array.isArray(value2)) {\n\t\t\tif (value1.length === value2.length) {\n\t\t\t\tfor (let index = 0; index < value1.length; index++) {\n\t\t\t\t\tconst dataset = /* @__PURE__ */ _merge(value1[index], value2[index]);\n\t\t\t\t\tif (dataset.issue) return dataset;\n\t\t\t\t\tvalue1[index] = dataset.value;\n\t\t\t\t}\n\t\t\t\treturn { value: value1 };\n\t\t\t}\n\t\t}\n\t}\n\treturn { issue: true };\n}\n\n//#endregion\n//#region src/schemas/intersect/intersect.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction intersect(options, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"intersect\",\n\t\treference: intersect,\n\t\texpects: /* @__PURE__ */ _joinExpects(options.map((option) => option.expects), \"&\"),\n\t\tasync: false,\n\t\toptions,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (this.options.length) {\n\t\t\t\tconst input = dataset.value;\n\t\t\t\tlet outputs;\n\t\t\t\tdataset.typed = true;\n\t\t\t\tfor (const schema of this.options) {\n\t\t\t\t\tconst optionDataset = schema[\"~run\"]({ value: input }, config$1);\n\t\t\t\t\tif (optionDataset.issues) {\n\t\t\t\t\t\tif (dataset.issues) dataset.issues.push(...optionDataset.issues);\n\t\t\t\t\t\telse dataset.issues = optionDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!optionDataset.typed) dataset.typed = false;\n\t\t\t\t\tif (dataset.typed) if (outputs) outputs.push(optionDataset.value);\n\t\t\t\t\telse outputs = [optionDataset.value];\n\t\t\t\t}\n\t\t\t\tif (dataset.typed) {\n\t\t\t\t\tdataset.value = outputs[0];\n\t\t\t\t\tfor (let index = 1; index < outputs.length; index++) {\n\t\t\t\t\t\tconst mergeDataset = /* @__PURE__ */ _merge(dataset.value, outputs[index]);\n\t\t\t\t\t\tif (mergeDataset.issue) {\n\t\t\t\t\t\t\t_addIssue(this, \"type\", dataset, config$1, { received: \"unknown\" });\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdataset.value = mergeDataset.value;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/intersect/intersectAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction intersectAsync(options, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"intersect\",\n\t\treference: intersectAsync,\n\t\texpects: /* @__PURE__ */ _joinExpects(options.map((option) => option.expects), \"&\"),\n\t\tasync: true,\n\t\toptions,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tif (this.options.length) {\n\t\t\t\tconst input = dataset.value;\n\t\t\t\tlet outputs;\n\t\t\t\tdataset.typed = true;\n\t\t\t\tconst optionDatasets = await Promise.all(this.options.map((schema) => schema[\"~run\"]({ value: input }, config$1)));\n\t\t\t\tfor (const optionDataset of optionDatasets) {\n\t\t\t\t\tif (optionDataset.issues) {\n\t\t\t\t\t\tif (dataset.issues) dataset.issues.push(...optionDataset.issues);\n\t\t\t\t\t\telse dataset.issues = optionDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!optionDataset.typed) dataset.typed = false;\n\t\t\t\t\tif (dataset.typed) if (outputs) outputs.push(optionDataset.value);\n\t\t\t\t\telse outputs = [optionDataset.value];\n\t\t\t\t}\n\t\t\t\tif (dataset.typed) {\n\t\t\t\t\tdataset.value = outputs[0];\n\t\t\t\t\tfor (let index = 1; index < outputs.length; index++) {\n\t\t\t\t\t\tconst mergeDataset = /* @__PURE__ */ _merge(dataset.value, outputs[index]);\n\t\t\t\t\t\tif (mergeDataset.issue) {\n\t\t\t\t\t\t\t_addIssue(this, \"type\", dataset, config$1, { received: \"unknown\" });\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdataset.value = mergeDataset.value;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/lazy/lazy.ts\n/**\n* Creates a lazy schema.\n*\n* @param getter The schema getter.\n*\n* @returns A lazy schema.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction lazy(getter) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"lazy\",\n\t\treference: lazy,\n\t\texpects: \"unknown\",\n\t\tasync: false,\n\t\tgetter,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\treturn this.getter(dataset.value)[\"~run\"](dataset, config$1);\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/lazy/lazyAsync.ts\n/**\n* Creates a lazy schema.\n*\n* @param getter The schema getter.\n*\n* @returns A lazy schema.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction lazyAsync(getter) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"lazy\",\n\t\treference: lazyAsync,\n\t\texpects: \"unknown\",\n\t\tasync: true,\n\t\tgetter,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\treturn (await this.getter(dataset.value))[\"~run\"](dataset, config$1);\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/literal/literal.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction literal(literal_, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"literal\",\n\t\treference: literal,\n\t\texpects: /* @__PURE__ */ _stringify(literal_),\n\t\tasync: false,\n\t\tliteral: literal_,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.value === this.literal) dataset.typed = true;\n\t\t\telse _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/looseObject/looseObject.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction looseObject(entries$1, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"loose_object\",\n\t\treference: looseObject,\n\t\texpects: \"Object\",\n\t\tasync: false,\n\t\tentries: entries$1,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tconst input = dataset.value;\n\t\t\tif (input && typeof input === \"object\") {\n\t\t\t\tdataset.typed = true;\n\t\t\t\tdataset.value = {};\n\t\t\t\tfor (const key in this.entries) {\n\t\t\t\t\tconst valueSchema = this.entries[key];\n\t\t\t\t\tif (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && valueSchema.default !== void 0) {\n\t\t\t\t\t\tconst value$1 = key in input ? input[key] : /* @__PURE__ */ getDefault(valueSchema);\n\t\t\t\t\t\tconst valueDataset = valueSchema[\"~run\"]({ value: value$1 }, config$1);\n\t\t\t\t\t\tif (valueDataset.issues) {\n\t\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\t\tvalue: value$1\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tfor (const issue of valueDataset.issues) {\n\t\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (!dataset.issues) dataset.issues = valueDataset.issues;\n\t\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!valueDataset.typed) dataset.typed = false;\n\t\t\t\t\t\tdataset.value[key] = valueDataset.value;\n\t\t\t\t\t} else if (valueSchema.fallback !== void 0) dataset.value[key] = /* @__PURE__ */ getFallback(valueSchema);\n\t\t\t\t\telse if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n\t\t\t\t\t\t_addIssue(this, \"key\", dataset, config$1, {\n\t\t\t\t\t\t\tinput: void 0,\n\t\t\t\t\t\t\texpected: `\"${key}\"`,\n\t\t\t\t\t\t\tpath: [{\n\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\torigin: \"key\",\n\t\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\t\tvalue: input[key]\n\t\t\t\t\t\t\t}]\n\t\t\t\t\t\t});\n\t\t\t\t\t\tif (config$1.abortEarly) break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!dataset.issues || !config$1.abortEarly) {\n\t\t\t\t\tfor (const key in input) if (/* @__PURE__ */ _isValidObjectKey(input, key) && !(key in this.entries)) dataset.value[key] = input[key];\n\t\t\t\t}\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/looseObject/looseObjectAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction looseObjectAsync(entries$1, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"loose_object\",\n\t\treference: looseObjectAsync,\n\t\texpects: \"Object\",\n\t\tasync: true,\n\t\tentries: entries$1,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tconst input = dataset.value;\n\t\t\tif (input && typeof input === \"object\") {\n\t\t\t\tdataset.typed = true;\n\t\t\t\tdataset.value = {};\n\t\t\t\tconst valueDatasets = await Promise.all(Object.entries(this.entries).map(async ([key, valueSchema]) => {\n\t\t\t\t\tif (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && valueSchema.default !== void 0) {\n\t\t\t\t\t\tconst value$1 = key in input ? input[key] : await /* @__PURE__ */ getDefault(valueSchema);\n\t\t\t\t\t\treturn [\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue$1,\n\t\t\t\t\t\t\tvalueSchema,\n\t\t\t\t\t\t\tawait valueSchema[\"~run\"]({ value: value$1 }, config$1)\n\t\t\t\t\t\t];\n\t\t\t\t\t}\n\t\t\t\t\treturn [\n\t\t\t\t\t\tkey,\n\t\t\t\t\t\tinput[key],\n\t\t\t\t\t\tvalueSchema,\n\t\t\t\t\t\tnull\n\t\t\t\t\t];\n\t\t\t\t}));\n\t\t\t\tfor (const [key, value$1, valueSchema, valueDataset] of valueDatasets) if (valueDataset) {\n\t\t\t\t\tif (valueDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue: value$1\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of valueDataset.issues) {\n\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = valueDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!valueDataset.typed) dataset.typed = false;\n\t\t\t\t\tdataset.value[key] = valueDataset.value;\n\t\t\t\t} else if (valueSchema.fallback !== void 0) dataset.value[key] = await /* @__PURE__ */ getFallback(valueSchema);\n\t\t\t\telse if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n\t\t\t\t\t_addIssue(this, \"key\", dataset, config$1, {\n\t\t\t\t\t\tinput: void 0,\n\t\t\t\t\t\texpected: `\"${key}\"`,\n\t\t\t\t\t\tpath: [{\n\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\torigin: \"key\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue: value$1\n\t\t\t\t\t\t}]\n\t\t\t\t\t});\n\t\t\t\t\tif (config$1.abortEarly) break;\n\t\t\t\t}\n\t\t\t\tif (!dataset.issues || !config$1.abortEarly) {\n\t\t\t\t\tfor (const key in input) if (/* @__PURE__ */ _isValidObjectKey(input, key) && !(key in this.entries)) dataset.value[key] = input[key];\n\t\t\t\t}\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/looseTuple/looseTuple.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction looseTuple(items, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"loose_tuple\",\n\t\treference: looseTuple,\n\t\texpects: \"Array\",\n\t\tasync: false,\n\t\titems,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tconst input = dataset.value;\n\t\t\tif (Array.isArray(input)) {\n\t\t\t\tdataset.typed = true;\n\t\t\t\tdataset.value = [];\n\t\t\t\tfor (let key = 0; key < this.items.length; key++) {\n\t\t\t\t\tconst value$1 = input[key];\n\t\t\t\t\tconst itemDataset = this.items[key][\"~run\"]({ value: value$1 }, config$1);\n\t\t\t\t\tif (itemDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"array\",\n\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue: value$1\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of itemDataset.issues) {\n\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = itemDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!itemDataset.typed) dataset.typed = false;\n\t\t\t\t\tdataset.value.push(itemDataset.value);\n\t\t\t\t}\n\t\t\t\tif (!dataset.issues || !config$1.abortEarly) for (let key = this.items.length; key < input.length; key++) dataset.value.push(input[key]);\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/looseTuple/looseTupleAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction looseTupleAsync(items, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"loose_tuple\",\n\t\treference: looseTupleAsync,\n\t\texpects: \"Array\",\n\t\tasync: true,\n\t\titems,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tconst input = dataset.value;\n\t\t\tif (Array.isArray(input)) {\n\t\t\t\tdataset.typed = true;\n\t\t\t\tdataset.value = [];\n\t\t\t\tconst itemDatasets = await Promise.all(this.items.map(async (item, key) => {\n\t\t\t\t\tconst value$1 = input[key];\n\t\t\t\t\treturn [\n\t\t\t\t\t\tkey,\n\t\t\t\t\t\tvalue$1,\n\t\t\t\t\t\tawait item[\"~run\"]({ value: value$1 }, config$1)\n\t\t\t\t\t];\n\t\t\t\t}));\n\t\t\t\tfor (const [key, value$1, itemDataset] of itemDatasets) {\n\t\t\t\t\tif (itemDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"array\",\n\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue: value$1\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of itemDataset.issues) {\n\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = itemDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!itemDataset.typed) dataset.typed = false;\n\t\t\t\t\tdataset.value.push(itemDataset.value);\n\t\t\t\t}\n\t\t\t\tif (!dataset.issues || !config$1.abortEarly) for (let key = this.items.length; key < input.length; key++) dataset.value.push(input[key]);\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/map/map.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction map(key, value$1, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"map\",\n\t\treference: map,\n\t\texpects: \"Map\",\n\t\tasync: false,\n\t\tkey,\n\t\tvalue: value$1,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tconst input = dataset.value;\n\t\t\tif (input instanceof Map) {\n\t\t\t\tdataset.typed = true;\n\t\t\t\tdataset.value = /* @__PURE__ */ new Map();\n\t\t\t\tfor (const [inputKey, inputValue] of input) {\n\t\t\t\t\tconst keyDataset = this.key[\"~run\"]({ value: inputKey }, config$1);\n\t\t\t\t\tif (keyDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"map\",\n\t\t\t\t\t\t\torigin: \"key\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey: inputKey,\n\t\t\t\t\t\t\tvalue: inputValue\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of keyDataset.issues) {\n\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = keyDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tconst valueDataset = this.value[\"~run\"]({ value: inputValue }, config$1);\n\t\t\t\t\tif (valueDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"map\",\n\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey: inputKey,\n\t\t\t\t\t\t\tvalue: inputValue\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of valueDataset.issues) {\n\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = valueDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!keyDataset.typed || !valueDataset.typed) dataset.typed = false;\n\t\t\t\t\tdataset.value.set(keyDataset.value, valueDataset.value);\n\t\t\t\t}\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/map/mapAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction mapAsync(key, value$1, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"map\",\n\t\treference: mapAsync,\n\t\texpects: \"Map\",\n\t\tasync: true,\n\t\tkey,\n\t\tvalue: value$1,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tconst input = dataset.value;\n\t\t\tif (input instanceof Map) {\n\t\t\t\tdataset.typed = true;\n\t\t\t\tdataset.value = /* @__PURE__ */ new Map();\n\t\t\t\tconst datasets = await Promise.all([...input].map(([inputKey, inputValue]) => Promise.all([\n\t\t\t\t\tinputKey,\n\t\t\t\t\tinputValue,\n\t\t\t\t\tthis.key[\"~run\"]({ value: inputKey }, config$1),\n\t\t\t\t\tthis.value[\"~run\"]({ value: inputValue }, config$1)\n\t\t\t\t])));\n\t\t\t\tfor (const [inputKey, inputValue, keyDataset, valueDataset] of datasets) {\n\t\t\t\t\tif (keyDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"map\",\n\t\t\t\t\t\t\torigin: \"key\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey: inputKey,\n\t\t\t\t\t\t\tvalue: inputValue\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of keyDataset.issues) {\n\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = keyDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (valueDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"map\",\n\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey: inputKey,\n\t\t\t\t\t\t\tvalue: inputValue\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of valueDataset.issues) {\n\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = valueDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!keyDataset.typed || !valueDataset.typed) dataset.typed = false;\n\t\t\t\t\tdataset.value.set(keyDataset.value, valueDataset.value);\n\t\t\t\t}\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/nan/nan.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction nan(message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"nan\",\n\t\treference: nan,\n\t\texpects: \"NaN\",\n\t\tasync: false,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (Number.isNaN(dataset.value)) dataset.typed = true;\n\t\t\telse _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/never/never.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction never(message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"never\",\n\t\treference: never,\n\t\texpects: \"never\",\n\t\tasync: false,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\t_addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/nonNullable/nonNullable.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction nonNullable(wrapped, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"non_nullable\",\n\t\treference: nonNullable,\n\t\texpects: \"!null\",\n\t\tasync: false,\n\t\twrapped,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.value !== null) dataset = this.wrapped[\"~run\"](dataset, config$1);\n\t\t\tif (dataset.value === null) _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/nonNullable/nonNullableAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction nonNullableAsync(wrapped, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"non_nullable\",\n\t\treference: nonNullableAsync,\n\t\texpects: \"!null\",\n\t\tasync: true,\n\t\twrapped,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tif (dataset.value !== null) dataset = await this.wrapped[\"~run\"](dataset, config$1);\n\t\t\tif (dataset.value === null) _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/nonNullish/nonNullish.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction nonNullish(wrapped, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"non_nullish\",\n\t\treference: nonNullish,\n\t\texpects: \"(!null & !undefined)\",\n\t\tasync: false,\n\t\twrapped,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (!(dataset.value === null || dataset.value === void 0)) dataset = this.wrapped[\"~run\"](dataset, config$1);\n\t\t\tif (dataset.value === null || dataset.value === void 0) _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/nonNullish/nonNullishAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction nonNullishAsync(wrapped, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"non_nullish\",\n\t\treference: nonNullishAsync,\n\t\texpects: \"(!null & !undefined)\",\n\t\tasync: true,\n\t\twrapped,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tif (!(dataset.value === null || dataset.value === void 0)) dataset = await this.wrapped[\"~run\"](dataset, config$1);\n\t\t\tif (dataset.value === null || dataset.value === void 0) _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/nonOptional/nonOptional.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction nonOptional(wrapped, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"non_optional\",\n\t\treference: nonOptional,\n\t\texpects: \"!undefined\",\n\t\tasync: false,\n\t\twrapped,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.value !== void 0) dataset = this.wrapped[\"~run\"](dataset, config$1);\n\t\t\tif (dataset.value === void 0) _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/nonOptional/nonOptionalAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction nonOptionalAsync(wrapped, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"non_optional\",\n\t\treference: nonOptionalAsync,\n\t\texpects: \"!undefined\",\n\t\tasync: true,\n\t\twrapped,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tif (dataset.value !== void 0) dataset = await this.wrapped[\"~run\"](dataset, config$1);\n\t\t\tif (dataset.value === void 0) _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/null/null.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction null_(message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"null\",\n\t\treference: null_,\n\t\texpects: \"null\",\n\t\tasync: false,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.value === null) dataset.typed = true;\n\t\t\telse _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/nullable/nullable.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction nullable(wrapped, default_) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"nullable\",\n\t\treference: nullable,\n\t\texpects: `(${wrapped.expects} | null)`,\n\t\tasync: false,\n\t\twrapped,\n\t\tdefault: default_,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.value === null) {\n\t\t\t\tif (this.default !== void 0) dataset.value = /* @__PURE__ */ getDefault(this, dataset, config$1);\n\t\t\t\tif (dataset.value === null) {\n\t\t\t\t\tdataset.typed = true;\n\t\t\t\t\treturn dataset;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this.wrapped[\"~run\"](dataset, config$1);\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/nullable/nullableAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction nullableAsync(wrapped, default_) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"nullable\",\n\t\treference: nullableAsync,\n\t\texpects: `(${wrapped.expects} | null)`,\n\t\tasync: true,\n\t\twrapped,\n\t\tdefault: default_,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tif (dataset.value === null) {\n\t\t\t\tif (this.default !== void 0) dataset.value = await /* @__PURE__ */ getDefault(this, dataset, config$1);\n\t\t\t\tif (dataset.value === null) {\n\t\t\t\t\tdataset.typed = true;\n\t\t\t\t\treturn dataset;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this.wrapped[\"~run\"](dataset, config$1);\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/nullish/nullish.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction nullish(wrapped, default_) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"nullish\",\n\t\treference: nullish,\n\t\texpects: `(${wrapped.expects} | null | undefined)`,\n\t\tasync: false,\n\t\twrapped,\n\t\tdefault: default_,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.value === null || dataset.value === void 0) {\n\t\t\t\tif (this.default !== void 0) dataset.value = /* @__PURE__ */ getDefault(this, dataset, config$1);\n\t\t\t\tif (dataset.value === null || dataset.value === void 0) {\n\t\t\t\t\tdataset.typed = true;\n\t\t\t\t\treturn dataset;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this.wrapped[\"~run\"](dataset, config$1);\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/nullish/nullishAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction nullishAsync(wrapped, default_) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"nullish\",\n\t\treference: nullishAsync,\n\t\texpects: `(${wrapped.expects} | null | undefined)`,\n\t\tasync: true,\n\t\twrapped,\n\t\tdefault: default_,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tif (dataset.value === null || dataset.value === void 0) {\n\t\t\t\tif (this.default !== void 0) dataset.value = await /* @__PURE__ */ getDefault(this, dataset, config$1);\n\t\t\t\tif (dataset.value === null || dataset.value === void 0) {\n\t\t\t\t\tdataset.typed = true;\n\t\t\t\t\treturn dataset;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this.wrapped[\"~run\"](dataset, config$1);\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/number/number.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction number(message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"number\",\n\t\treference: number,\n\t\texpects: \"number\",\n\t\tasync: false,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (typeof dataset.value === \"number\" && !isNaN(dataset.value)) dataset.typed = true;\n\t\t\telse _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/object/object.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction object(entries$1, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"object\",\n\t\treference: object,\n\t\texpects: \"Object\",\n\t\tasync: false,\n\t\tentries: entries$1,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tconst input = dataset.value;\n\t\t\tif (input && typeof input === \"object\") {\n\t\t\t\tdataset.typed = true;\n\t\t\t\tdataset.value = {};\n\t\t\t\tfor (const key in this.entries) {\n\t\t\t\t\tconst valueSchema = this.entries[key];\n\t\t\t\t\tif (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && valueSchema.default !== void 0) {\n\t\t\t\t\t\tconst value$1 = key in input ? input[key] : /* @__PURE__ */ getDefault(valueSchema);\n\t\t\t\t\t\tconst valueDataset = valueSchema[\"~run\"]({ value: value$1 }, config$1);\n\t\t\t\t\t\tif (valueDataset.issues) {\n\t\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\t\tvalue: value$1\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tfor (const issue of valueDataset.issues) {\n\t\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (!dataset.issues) dataset.issues = valueDataset.issues;\n\t\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!valueDataset.typed) dataset.typed = false;\n\t\t\t\t\t\tdataset.value[key] = valueDataset.value;\n\t\t\t\t\t} else if (valueSchema.fallback !== void 0) dataset.value[key] = /* @__PURE__ */ getFallback(valueSchema);\n\t\t\t\t\telse if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n\t\t\t\t\t\t_addIssue(this, \"key\", dataset, config$1, {\n\t\t\t\t\t\t\tinput: void 0,\n\t\t\t\t\t\t\texpected: `\"${key}\"`,\n\t\t\t\t\t\t\tpath: [{\n\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\torigin: \"key\",\n\t\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\t\tvalue: input[key]\n\t\t\t\t\t\t\t}]\n\t\t\t\t\t\t});\n\t\t\t\t\t\tif (config$1.abortEarly) break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/object/objectAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction objectAsync(entries$1, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"object\",\n\t\treference: objectAsync,\n\t\texpects: \"Object\",\n\t\tasync: true,\n\t\tentries: entries$1,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tconst input = dataset.value;\n\t\t\tif (input && typeof input === \"object\") {\n\t\t\t\tdataset.typed = true;\n\t\t\t\tdataset.value = {};\n\t\t\t\tconst valueDatasets = await Promise.all(Object.entries(this.entries).map(async ([key, valueSchema]) => {\n\t\t\t\t\tif (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && valueSchema.default !== void 0) {\n\t\t\t\t\t\tconst value$1 = key in input ? input[key] : await /* @__PURE__ */ getDefault(valueSchema);\n\t\t\t\t\t\treturn [\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue$1,\n\t\t\t\t\t\t\tvalueSchema,\n\t\t\t\t\t\t\tawait valueSchema[\"~run\"]({ value: value$1 }, config$1)\n\t\t\t\t\t\t];\n\t\t\t\t\t}\n\t\t\t\t\treturn [\n\t\t\t\t\t\tkey,\n\t\t\t\t\t\tinput[key],\n\t\t\t\t\t\tvalueSchema,\n\t\t\t\t\t\tnull\n\t\t\t\t\t];\n\t\t\t\t}));\n\t\t\t\tfor (const [key, value$1, valueSchema, valueDataset] of valueDatasets) if (valueDataset) {\n\t\t\t\t\tif (valueDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue: value$1\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of valueDataset.issues) {\n\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = valueDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!valueDataset.typed) dataset.typed = false;\n\t\t\t\t\tdataset.value[key] = valueDataset.value;\n\t\t\t\t} else if (valueSchema.fallback !== void 0) dataset.value[key] = await /* @__PURE__ */ getFallback(valueSchema);\n\t\t\t\telse if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n\t\t\t\t\t_addIssue(this, \"key\", dataset, config$1, {\n\t\t\t\t\t\tinput: void 0,\n\t\t\t\t\t\texpected: `\"${key}\"`,\n\t\t\t\t\t\tpath: [{\n\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\torigin: \"key\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue: value$1\n\t\t\t\t\t\t}]\n\t\t\t\t\t});\n\t\t\t\t\tif (config$1.abortEarly) break;\n\t\t\t\t}\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/objectWithRest/objectWithRest.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction objectWithRest(entries$1, rest, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"object_with_rest\",\n\t\treference: objectWithRest,\n\t\texpects: \"Object\",\n\t\tasync: false,\n\t\tentries: entries$1,\n\t\trest,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tconst input = dataset.value;\n\t\t\tif (input && typeof input === \"object\") {\n\t\t\t\tdataset.typed = true;\n\t\t\t\tdataset.value = {};\n\t\t\t\tfor (const key in this.entries) {\n\t\t\t\t\tconst valueSchema = this.entries[key];\n\t\t\t\t\tif (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && valueSchema.default !== void 0) {\n\t\t\t\t\t\tconst value$1 = key in input ? input[key] : /* @__PURE__ */ getDefault(valueSchema);\n\t\t\t\t\t\tconst valueDataset = valueSchema[\"~run\"]({ value: value$1 }, config$1);\n\t\t\t\t\t\tif (valueDataset.issues) {\n\t\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\t\tvalue: value$1\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tfor (const issue of valueDataset.issues) {\n\t\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (!dataset.issues) dataset.issues = valueDataset.issues;\n\t\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!valueDataset.typed) dataset.typed = false;\n\t\t\t\t\t\tdataset.value[key] = valueDataset.value;\n\t\t\t\t\t} else if (valueSchema.fallback !== void 0) dataset.value[key] = /* @__PURE__ */ getFallback(valueSchema);\n\t\t\t\t\telse if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n\t\t\t\t\t\t_addIssue(this, \"key\", dataset, config$1, {\n\t\t\t\t\t\t\tinput: void 0,\n\t\t\t\t\t\t\texpected: `\"${key}\"`,\n\t\t\t\t\t\t\tpath: [{\n\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\torigin: \"key\",\n\t\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\t\tvalue: input[key]\n\t\t\t\t\t\t\t}]\n\t\t\t\t\t\t});\n\t\t\t\t\t\tif (config$1.abortEarly) break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!dataset.issues || !config$1.abortEarly) {\n\t\t\t\t\tfor (const key in input) if (/* @__PURE__ */ _isValidObjectKey(input, key) && !(key in this.entries)) {\n\t\t\t\t\t\tconst valueDataset = this.rest[\"~run\"]({ value: input[key] }, config$1);\n\t\t\t\t\t\tif (valueDataset.issues) {\n\t\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\t\tvalue: input[key]\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tfor (const issue of valueDataset.issues) {\n\t\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (!dataset.issues) dataset.issues = valueDataset.issues;\n\t\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!valueDataset.typed) dataset.typed = false;\n\t\t\t\t\t\tdataset.value[key] = valueDataset.value;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/objectWithRest/objectWithRestAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction objectWithRestAsync(entries$1, rest, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"object_with_rest\",\n\t\treference: objectWithRestAsync,\n\t\texpects: \"Object\",\n\t\tasync: true,\n\t\tentries: entries$1,\n\t\trest,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tconst input = dataset.value;\n\t\t\tif (input && typeof input === \"object\") {\n\t\t\t\tdataset.typed = true;\n\t\t\t\tdataset.value = {};\n\t\t\t\tconst [normalDatasets, restDatasets] = await Promise.all([Promise.all(Object.entries(this.entries).map(async ([key, valueSchema]) => {\n\t\t\t\t\tif (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && valueSchema.default !== void 0) {\n\t\t\t\t\t\tconst value$1 = key in input ? input[key] : await /* @__PURE__ */ getDefault(valueSchema);\n\t\t\t\t\t\treturn [\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue$1,\n\t\t\t\t\t\t\tvalueSchema,\n\t\t\t\t\t\t\tawait valueSchema[\"~run\"]({ value: value$1 }, config$1)\n\t\t\t\t\t\t];\n\t\t\t\t\t}\n\t\t\t\t\treturn [\n\t\t\t\t\t\tkey,\n\t\t\t\t\t\tinput[key],\n\t\t\t\t\t\tvalueSchema,\n\t\t\t\t\t\tnull\n\t\t\t\t\t];\n\t\t\t\t})), Promise.all(Object.entries(input).filter(([key]) => /* @__PURE__ */ _isValidObjectKey(input, key) && !(key in this.entries)).map(async ([key, value$1]) => [\n\t\t\t\t\tkey,\n\t\t\t\t\tvalue$1,\n\t\t\t\t\tawait this.rest[\"~run\"]({ value: value$1 }, config$1)\n\t\t\t\t]))]);\n\t\t\t\tfor (const [key, value$1, valueSchema, valueDataset] of normalDatasets) if (valueDataset) {\n\t\t\t\t\tif (valueDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue: value$1\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of valueDataset.issues) {\n\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = valueDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!valueDataset.typed) dataset.typed = false;\n\t\t\t\t\tdataset.value[key] = valueDataset.value;\n\t\t\t\t} else if (valueSchema.fallback !== void 0) dataset.value[key] = await /* @__PURE__ */ getFallback(valueSchema);\n\t\t\t\telse if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n\t\t\t\t\t_addIssue(this, \"key\", dataset, config$1, {\n\t\t\t\t\t\tinput: void 0,\n\t\t\t\t\t\texpected: `\"${key}\"`,\n\t\t\t\t\t\tpath: [{\n\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\torigin: \"key\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue: value$1\n\t\t\t\t\t\t}]\n\t\t\t\t\t});\n\t\t\t\t\tif (config$1.abortEarly) break;\n\t\t\t\t}\n\t\t\t\tif (!dataset.issues || !config$1.abortEarly) for (const [key, value$1, valueDataset] of restDatasets) {\n\t\t\t\t\tif (valueDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue: value$1\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of valueDataset.issues) {\n\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = valueDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!valueDataset.typed) dataset.typed = false;\n\t\t\t\t\tdataset.value[key] = valueDataset.value;\n\t\t\t\t}\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/optional/optional.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction optional(wrapped, default_) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"optional\",\n\t\treference: optional,\n\t\texpects: `(${wrapped.expects} | undefined)`,\n\t\tasync: false,\n\t\twrapped,\n\t\tdefault: default_,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.value === void 0) {\n\t\t\t\tif (this.default !== void 0) dataset.value = /* @__PURE__ */ getDefault(this, dataset, config$1);\n\t\t\t\tif (dataset.value === void 0) {\n\t\t\t\t\tdataset.typed = true;\n\t\t\t\t\treturn dataset;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this.wrapped[\"~run\"](dataset, config$1);\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/optional/optionalAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction optionalAsync(wrapped, default_) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"optional\",\n\t\treference: optionalAsync,\n\t\texpects: `(${wrapped.expects} | undefined)`,\n\t\tasync: true,\n\t\twrapped,\n\t\tdefault: default_,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tif (dataset.value === void 0) {\n\t\t\t\tif (this.default !== void 0) dataset.value = await /* @__PURE__ */ getDefault(this, dataset, config$1);\n\t\t\t\tif (dataset.value === void 0) {\n\t\t\t\t\tdataset.typed = true;\n\t\t\t\t\treturn dataset;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this.wrapped[\"~run\"](dataset, config$1);\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/picklist/picklist.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction picklist(options, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"picklist\",\n\t\treference: picklist,\n\t\texpects: /* @__PURE__ */ _joinExpects(options.map(_stringify), \"|\"),\n\t\tasync: false,\n\t\toptions,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (this.options.includes(dataset.value)) dataset.typed = true;\n\t\t\telse _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/promise/promise.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction promise(message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"promise\",\n\t\treference: promise,\n\t\texpects: \"Promise\",\n\t\tasync: false,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.value instanceof Promise) dataset.typed = true;\n\t\t\telse _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/record/record.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction record(key, value$1, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"record\",\n\t\treference: record,\n\t\texpects: \"Object\",\n\t\tasync: false,\n\t\tkey,\n\t\tvalue: value$1,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tconst input = dataset.value;\n\t\t\tif (input && typeof input === \"object\") {\n\t\t\t\tdataset.typed = true;\n\t\t\t\tdataset.value = {};\n\t\t\t\tfor (const entryKey in input) if (/* @__PURE__ */ _isValidObjectKey(input, entryKey)) {\n\t\t\t\t\tconst entryValue = input[entryKey];\n\t\t\t\t\tconst keyDataset = this.key[\"~run\"]({ value: entryKey }, config$1);\n\t\t\t\t\tif (keyDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\torigin: \"key\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey: entryKey,\n\t\t\t\t\t\t\tvalue: entryValue\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of keyDataset.issues) {\n\t\t\t\t\t\t\tissue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = keyDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tconst valueDataset = this.value[\"~run\"]({ value: entryValue }, config$1);\n\t\t\t\t\tif (valueDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey: entryKey,\n\t\t\t\t\t\t\tvalue: entryValue\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of valueDataset.issues) {\n\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = valueDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!keyDataset.typed || !valueDataset.typed) dataset.typed = false;\n\t\t\t\t\tif (keyDataset.typed) dataset.value[keyDataset.value] = valueDataset.value;\n\t\t\t\t}\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/record/recordAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction recordAsync(key, value$1, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"record\",\n\t\treference: recordAsync,\n\t\texpects: \"Object\",\n\t\tasync: true,\n\t\tkey,\n\t\tvalue: value$1,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tconst input = dataset.value;\n\t\t\tif (input && typeof input === \"object\") {\n\t\t\t\tdataset.typed = true;\n\t\t\t\tdataset.value = {};\n\t\t\t\tconst datasets = await Promise.all(Object.entries(input).filter(([key$1]) => /* @__PURE__ */ _isValidObjectKey(input, key$1)).map(([entryKey, entryValue]) => Promise.all([\n\t\t\t\t\tentryKey,\n\t\t\t\t\tentryValue,\n\t\t\t\t\tthis.key[\"~run\"]({ value: entryKey }, config$1),\n\t\t\t\t\tthis.value[\"~run\"]({ value: entryValue }, config$1)\n\t\t\t\t])));\n\t\t\t\tfor (const [entryKey, entryValue, keyDataset, valueDataset] of datasets) {\n\t\t\t\t\tif (keyDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\torigin: \"key\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey: entryKey,\n\t\t\t\t\t\t\tvalue: entryValue\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of keyDataset.issues) {\n\t\t\t\t\t\t\tissue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = keyDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (valueDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey: entryKey,\n\t\t\t\t\t\t\tvalue: entryValue\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of valueDataset.issues) {\n\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = valueDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!keyDataset.typed || !valueDataset.typed) dataset.typed = false;\n\t\t\t\t\tif (keyDataset.typed) dataset.value[keyDataset.value] = valueDataset.value;\n\t\t\t\t}\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/set/set.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction set(value$1, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"set\",\n\t\treference: set,\n\t\texpects: \"Set\",\n\t\tasync: false,\n\t\tvalue: value$1,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tconst input = dataset.value;\n\t\t\tif (input instanceof Set) {\n\t\t\t\tdataset.typed = true;\n\t\t\t\tdataset.value = /* @__PURE__ */ new Set();\n\t\t\t\tfor (const inputValue of input) {\n\t\t\t\t\tconst valueDataset = this.value[\"~run\"]({ value: inputValue }, config$1);\n\t\t\t\t\tif (valueDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"set\",\n\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey: null,\n\t\t\t\t\t\t\tvalue: inputValue\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of valueDataset.issues) {\n\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = valueDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!valueDataset.typed) dataset.typed = false;\n\t\t\t\t\tdataset.value.add(valueDataset.value);\n\t\t\t\t}\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/set/setAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction setAsync(value$1, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"set\",\n\t\treference: setAsync,\n\t\texpects: \"Set\",\n\t\tasync: true,\n\t\tvalue: value$1,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tconst input = dataset.value;\n\t\t\tif (input instanceof Set) {\n\t\t\t\tdataset.typed = true;\n\t\t\t\tdataset.value = /* @__PURE__ */ new Set();\n\t\t\t\tconst valueDatasets = await Promise.all([...input].map(async (inputValue) => [inputValue, await this.value[\"~run\"]({ value: inputValue }, config$1)]));\n\t\t\t\tfor (const [inputValue, valueDataset] of valueDatasets) {\n\t\t\t\t\tif (valueDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"set\",\n\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey: null,\n\t\t\t\t\t\t\tvalue: inputValue\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of valueDataset.issues) {\n\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = valueDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!valueDataset.typed) dataset.typed = false;\n\t\t\t\t\tdataset.value.add(valueDataset.value);\n\t\t\t\t}\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/strictObject/strictObject.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction strictObject(entries$1, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"strict_object\",\n\t\treference: strictObject,\n\t\texpects: \"Object\",\n\t\tasync: false,\n\t\tentries: entries$1,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tconst input = dataset.value;\n\t\t\tif (input && typeof input === \"object\") {\n\t\t\t\tdataset.typed = true;\n\t\t\t\tdataset.value = {};\n\t\t\t\tfor (const key in this.entries) {\n\t\t\t\t\tconst valueSchema = this.entries[key];\n\t\t\t\t\tif (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && valueSchema.default !== void 0) {\n\t\t\t\t\t\tconst value$1 = key in input ? input[key] : /* @__PURE__ */ getDefault(valueSchema);\n\t\t\t\t\t\tconst valueDataset = valueSchema[\"~run\"]({ value: value$1 }, config$1);\n\t\t\t\t\t\tif (valueDataset.issues) {\n\t\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\t\tvalue: value$1\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tfor (const issue of valueDataset.issues) {\n\t\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (!dataset.issues) dataset.issues = valueDataset.issues;\n\t\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!valueDataset.typed) dataset.typed = false;\n\t\t\t\t\t\tdataset.value[key] = valueDataset.value;\n\t\t\t\t\t} else if (valueSchema.fallback !== void 0) dataset.value[key] = /* @__PURE__ */ getFallback(valueSchema);\n\t\t\t\t\telse if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n\t\t\t\t\t\t_addIssue(this, \"key\", dataset, config$1, {\n\t\t\t\t\t\t\tinput: void 0,\n\t\t\t\t\t\t\texpected: `\"${key}\"`,\n\t\t\t\t\t\t\tpath: [{\n\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\torigin: \"key\",\n\t\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\t\tvalue: input[key]\n\t\t\t\t\t\t\t}]\n\t\t\t\t\t\t});\n\t\t\t\t\t\tif (config$1.abortEarly) break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!dataset.issues || !config$1.abortEarly) {\n\t\t\t\t\tfor (const key in input) if (!(key in this.entries)) {\n\t\t\t\t\t\t_addIssue(this, \"key\", dataset, config$1, {\n\t\t\t\t\t\t\tinput: key,\n\t\t\t\t\t\t\texpected: \"never\",\n\t\t\t\t\t\t\tpath: [{\n\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\torigin: \"key\",\n\t\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\t\tvalue: input[key]\n\t\t\t\t\t\t\t}]\n\t\t\t\t\t\t});\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/strictObject/strictObjectAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction strictObjectAsync(entries$1, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"strict_object\",\n\t\treference: strictObjectAsync,\n\t\texpects: \"Object\",\n\t\tasync: true,\n\t\tentries: entries$1,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tconst input = dataset.value;\n\t\t\tif (input && typeof input === \"object\") {\n\t\t\t\tdataset.typed = true;\n\t\t\t\tdataset.value = {};\n\t\t\t\tconst valueDatasets = await Promise.all(Object.entries(this.entries).map(async ([key, valueSchema]) => {\n\t\t\t\t\tif (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && valueSchema.default !== void 0) {\n\t\t\t\t\t\tconst value$1 = key in input ? input[key] : await /* @__PURE__ */ getDefault(valueSchema);\n\t\t\t\t\t\treturn [\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue$1,\n\t\t\t\t\t\t\tvalueSchema,\n\t\t\t\t\t\t\tawait valueSchema[\"~run\"]({ value: value$1 }, config$1)\n\t\t\t\t\t\t];\n\t\t\t\t\t}\n\t\t\t\t\treturn [\n\t\t\t\t\t\tkey,\n\t\t\t\t\t\tinput[key],\n\t\t\t\t\t\tvalueSchema,\n\t\t\t\t\t\tnull\n\t\t\t\t\t];\n\t\t\t\t}));\n\t\t\t\tfor (const [key, value$1, valueSchema, valueDataset] of valueDatasets) if (valueDataset) {\n\t\t\t\t\tif (valueDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue: value$1\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of valueDataset.issues) {\n\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = valueDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!valueDataset.typed) dataset.typed = false;\n\t\t\t\t\tdataset.value[key] = valueDataset.value;\n\t\t\t\t} else if (valueSchema.fallback !== void 0) dataset.value[key] = await /* @__PURE__ */ getFallback(valueSchema);\n\t\t\t\telse if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n\t\t\t\t\t_addIssue(this, \"key\", dataset, config$1, {\n\t\t\t\t\t\tinput: void 0,\n\t\t\t\t\t\texpected: `\"${key}\"`,\n\t\t\t\t\t\tpath: [{\n\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\torigin: \"key\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue: value$1\n\t\t\t\t\t\t}]\n\t\t\t\t\t});\n\t\t\t\t\tif (config$1.abortEarly) break;\n\t\t\t\t}\n\t\t\t\tif (!dataset.issues || !config$1.abortEarly) {\n\t\t\t\t\tfor (const key in input) if (!(key in this.entries)) {\n\t\t\t\t\t\t_addIssue(this, \"key\", dataset, config$1, {\n\t\t\t\t\t\t\tinput: key,\n\t\t\t\t\t\t\texpected: \"never\",\n\t\t\t\t\t\t\tpath: [{\n\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\torigin: \"key\",\n\t\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\t\tvalue: input[key]\n\t\t\t\t\t\t\t}]\n\t\t\t\t\t\t});\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/strictTuple/strictTuple.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction strictTuple(items, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"strict_tuple\",\n\t\treference: strictTuple,\n\t\texpects: \"Array\",\n\t\tasync: false,\n\t\titems,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tconst input = dataset.value;\n\t\t\tif (Array.isArray(input)) {\n\t\t\t\tdataset.typed = true;\n\t\t\t\tdataset.value = [];\n\t\t\t\tfor (let key = 0; key < this.items.length; key++) {\n\t\t\t\t\tconst value$1 = input[key];\n\t\t\t\t\tconst itemDataset = this.items[key][\"~run\"]({ value: value$1 }, config$1);\n\t\t\t\t\tif (itemDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"array\",\n\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue: value$1\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of itemDataset.issues) {\n\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = itemDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!itemDataset.typed) dataset.typed = false;\n\t\t\t\t\tdataset.value.push(itemDataset.value);\n\t\t\t\t}\n\t\t\t\tif (!(dataset.issues && config$1.abortEarly) && this.items.length < input.length) _addIssue(this, \"type\", dataset, config$1, {\n\t\t\t\t\tinput: input[this.items.length],\n\t\t\t\t\texpected: \"never\",\n\t\t\t\t\tpath: [{\n\t\t\t\t\t\ttype: \"array\",\n\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\tinput,\n\t\t\t\t\t\tkey: this.items.length,\n\t\t\t\t\t\tvalue: input[this.items.length]\n\t\t\t\t\t}]\n\t\t\t\t});\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/strictTuple/strictTupleAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction strictTupleAsync(items, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"strict_tuple\",\n\t\treference: strictTupleAsync,\n\t\texpects: \"Array\",\n\t\tasync: true,\n\t\titems,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tconst input = dataset.value;\n\t\t\tif (Array.isArray(input)) {\n\t\t\t\tdataset.typed = true;\n\t\t\t\tdataset.value = [];\n\t\t\t\tconst itemDatasets = await Promise.all(this.items.map(async (item, key) => {\n\t\t\t\t\tconst value$1 = input[key];\n\t\t\t\t\treturn [\n\t\t\t\t\t\tkey,\n\t\t\t\t\t\tvalue$1,\n\t\t\t\t\t\tawait item[\"~run\"]({ value: value$1 }, config$1)\n\t\t\t\t\t];\n\t\t\t\t}));\n\t\t\t\tfor (const [key, value$1, itemDataset] of itemDatasets) {\n\t\t\t\t\tif (itemDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"array\",\n\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue: value$1\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of itemDataset.issues) {\n\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = itemDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!itemDataset.typed) dataset.typed = false;\n\t\t\t\t\tdataset.value.push(itemDataset.value);\n\t\t\t\t}\n\t\t\t\tif (!(dataset.issues && config$1.abortEarly) && this.items.length < input.length) _addIssue(this, \"type\", dataset, config$1, {\n\t\t\t\t\tinput: input[this.items.length],\n\t\t\t\t\texpected: \"never\",\n\t\t\t\t\tpath: [{\n\t\t\t\t\t\ttype: \"array\",\n\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\tinput,\n\t\t\t\t\t\tkey: this.items.length,\n\t\t\t\t\t\tvalue: input[this.items.length]\n\t\t\t\t\t}]\n\t\t\t\t});\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/string/string.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction string(message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"string\",\n\t\treference: string,\n\t\texpects: \"string\",\n\t\tasync: false,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (typeof dataset.value === \"string\") dataset.typed = true;\n\t\t\telse _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/symbol/symbol.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction symbol(message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"symbol\",\n\t\treference: symbol,\n\t\texpects: \"symbol\",\n\t\tasync: false,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (typeof dataset.value === \"symbol\") dataset.typed = true;\n\t\t\telse _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/tuple/tuple.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction tuple(items, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"tuple\",\n\t\treference: tuple,\n\t\texpects: \"Array\",\n\t\tasync: false,\n\t\titems,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tconst input = dataset.value;\n\t\t\tif (Array.isArray(input)) {\n\t\t\t\tdataset.typed = true;\n\t\t\t\tdataset.value = [];\n\t\t\t\tfor (let key = 0; key < this.items.length; key++) {\n\t\t\t\t\tconst value$1 = input[key];\n\t\t\t\t\tconst itemDataset = this.items[key][\"~run\"]({ value: value$1 }, config$1);\n\t\t\t\t\tif (itemDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"array\",\n\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue: value$1\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of itemDataset.issues) {\n\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = itemDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!itemDataset.typed) dataset.typed = false;\n\t\t\t\t\tdataset.value.push(itemDataset.value);\n\t\t\t\t}\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/tuple/tupleAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction tupleAsync(items, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"tuple\",\n\t\treference: tupleAsync,\n\t\texpects: \"Array\",\n\t\tasync: true,\n\t\titems,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tconst input = dataset.value;\n\t\t\tif (Array.isArray(input)) {\n\t\t\t\tdataset.typed = true;\n\t\t\t\tdataset.value = [];\n\t\t\t\tconst itemDatasets = await Promise.all(this.items.map(async (item, key) => {\n\t\t\t\t\tconst value$1 = input[key];\n\t\t\t\t\treturn [\n\t\t\t\t\t\tkey,\n\t\t\t\t\t\tvalue$1,\n\t\t\t\t\t\tawait item[\"~run\"]({ value: value$1 }, config$1)\n\t\t\t\t\t];\n\t\t\t\t}));\n\t\t\t\tfor (const [key, value$1, itemDataset] of itemDatasets) {\n\t\t\t\t\tif (itemDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"array\",\n\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue: value$1\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of itemDataset.issues) {\n\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = itemDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!itemDataset.typed) dataset.typed = false;\n\t\t\t\t\tdataset.value.push(itemDataset.value);\n\t\t\t\t}\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/tupleWithRest/tupleWithRest.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction tupleWithRest(items, rest, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"tuple_with_rest\",\n\t\treference: tupleWithRest,\n\t\texpects: \"Array\",\n\t\tasync: false,\n\t\titems,\n\t\trest,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tconst input = dataset.value;\n\t\t\tif (Array.isArray(input)) {\n\t\t\t\tdataset.typed = true;\n\t\t\t\tdataset.value = [];\n\t\t\t\tfor (let key = 0; key < this.items.length; key++) {\n\t\t\t\t\tconst value$1 = input[key];\n\t\t\t\t\tconst itemDataset = this.items[key][\"~run\"]({ value: value$1 }, config$1);\n\t\t\t\t\tif (itemDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"array\",\n\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue: value$1\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of itemDataset.issues) {\n\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = itemDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!itemDataset.typed) dataset.typed = false;\n\t\t\t\t\tdataset.value.push(itemDataset.value);\n\t\t\t\t}\n\t\t\t\tif (!dataset.issues || !config$1.abortEarly) for (let key = this.items.length; key < input.length; key++) {\n\t\t\t\t\tconst value$1 = input[key];\n\t\t\t\t\tconst itemDataset = this.rest[\"~run\"]({ value: value$1 }, config$1);\n\t\t\t\t\tif (itemDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"array\",\n\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue: value$1\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of itemDataset.issues) {\n\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = itemDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!itemDataset.typed) dataset.typed = false;\n\t\t\t\t\tdataset.value.push(itemDataset.value);\n\t\t\t\t}\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/tupleWithRest/tupleWithRestAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction tupleWithRestAsync(items, rest, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"tuple_with_rest\",\n\t\treference: tupleWithRestAsync,\n\t\texpects: \"Array\",\n\t\tasync: true,\n\t\titems,\n\t\trest,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tconst input = dataset.value;\n\t\t\tif (Array.isArray(input)) {\n\t\t\t\tdataset.typed = true;\n\t\t\t\tdataset.value = [];\n\t\t\t\tconst [normalDatasets, restDatasets] = await Promise.all([Promise.all(this.items.map(async (item, key) => {\n\t\t\t\t\tconst value$1 = input[key];\n\t\t\t\t\treturn [\n\t\t\t\t\t\tkey,\n\t\t\t\t\t\tvalue$1,\n\t\t\t\t\t\tawait item[\"~run\"]({ value: value$1 }, config$1)\n\t\t\t\t\t];\n\t\t\t\t})), Promise.all(input.slice(this.items.length).map(async (value$1, key) => {\n\t\t\t\t\treturn [\n\t\t\t\t\t\tkey + this.items.length,\n\t\t\t\t\t\tvalue$1,\n\t\t\t\t\t\tawait this.rest[\"~run\"]({ value: value$1 }, config$1)\n\t\t\t\t\t];\n\t\t\t\t}))]);\n\t\t\t\tfor (const [key, value$1, itemDataset] of normalDatasets) {\n\t\t\t\t\tif (itemDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"array\",\n\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue: value$1\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of itemDataset.issues) {\n\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = itemDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!itemDataset.typed) dataset.typed = false;\n\t\t\t\t\tdataset.value.push(itemDataset.value);\n\t\t\t\t}\n\t\t\t\tif (!dataset.issues || !config$1.abortEarly) for (const [key, value$1, itemDataset] of restDatasets) {\n\t\t\t\t\tif (itemDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"array\",\n\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue: value$1\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of itemDataset.issues) {\n\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = itemDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!itemDataset.typed) dataset.typed = false;\n\t\t\t\t\tdataset.value.push(itemDataset.value);\n\t\t\t\t}\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/undefined/undefined.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction undefined_(message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"undefined\",\n\t\treference: undefined_,\n\t\texpects: \"undefined\",\n\t\tasync: false,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.value === void 0) dataset.typed = true;\n\t\t\telse _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/undefinedable/undefinedable.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction undefinedable(wrapped, default_) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"undefinedable\",\n\t\treference: undefinedable,\n\t\texpects: `(${wrapped.expects} | undefined)`,\n\t\tasync: false,\n\t\twrapped,\n\t\tdefault: default_,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.value === void 0) {\n\t\t\t\tif (this.default !== void 0) dataset.value = /* @__PURE__ */ getDefault(this, dataset, config$1);\n\t\t\t\tif (dataset.value === void 0) {\n\t\t\t\t\tdataset.typed = true;\n\t\t\t\t\treturn dataset;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this.wrapped[\"~run\"](dataset, config$1);\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/undefinedable/undefinedableAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction undefinedableAsync(wrapped, default_) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"undefinedable\",\n\t\treference: undefinedableAsync,\n\t\texpects: `(${wrapped.expects} | undefined)`,\n\t\tasync: true,\n\t\twrapped,\n\t\tdefault: default_,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tif (dataset.value === void 0) {\n\t\t\t\tif (this.default !== void 0) dataset.value = await /* @__PURE__ */ getDefault(this, dataset, config$1);\n\t\t\t\tif (dataset.value === void 0) {\n\t\t\t\t\tdataset.typed = true;\n\t\t\t\t\treturn dataset;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this.wrapped[\"~run\"](dataset, config$1);\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/union/utils/_subIssues/_subIssues.ts\n/**\n* Returns the sub issues of the provided datasets for the union issue.\n*\n* @param datasets The datasets.\n*\n* @returns The sub issues.\n*\n* @internal\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction _subIssues(datasets) {\n\tlet issues;\n\tif (datasets) for (const dataset of datasets) if (issues) issues.push(...dataset.issues);\n\telse issues = dataset.issues;\n\treturn issues;\n}\n\n//#endregion\n//#region src/schemas/union/union.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction union(options, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"union\",\n\t\treference: union,\n\t\texpects: /* @__PURE__ */ _joinExpects(options.map((option) => option.expects), \"|\"),\n\t\tasync: false,\n\t\toptions,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tlet validDataset;\n\t\t\tlet typedDatasets;\n\t\t\tlet untypedDatasets;\n\t\t\tfor (const schema of this.options) {\n\t\t\t\tconst optionDataset = schema[\"~run\"]({ value: dataset.value }, config$1);\n\t\t\t\tif (optionDataset.typed) if (optionDataset.issues) if (typedDatasets) typedDatasets.push(optionDataset);\n\t\t\t\telse typedDatasets = [optionDataset];\n\t\t\t\telse {\n\t\t\t\t\tvalidDataset = optionDataset;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if (untypedDatasets) untypedDatasets.push(optionDataset);\n\t\t\t\telse untypedDatasets = [optionDataset];\n\t\t\t}\n\t\t\tif (validDataset) return validDataset;\n\t\t\tif (typedDatasets) {\n\t\t\t\tif (typedDatasets.length === 1) return typedDatasets[0];\n\t\t\t\t_addIssue(this, \"type\", dataset, config$1, { issues: /* @__PURE__ */ _subIssues(typedDatasets) });\n\t\t\t\tdataset.typed = true;\n\t\t\t} else if (untypedDatasets?.length === 1) return untypedDatasets[0];\n\t\t\telse _addIssue(this, \"type\", dataset, config$1, { issues: /* @__PURE__ */ _subIssues(untypedDatasets) });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/union/unionAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction unionAsync(options, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"union\",\n\t\treference: unionAsync,\n\t\texpects: /* @__PURE__ */ _joinExpects(options.map((option) => option.expects), \"|\"),\n\t\tasync: true,\n\t\toptions,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tlet validDataset;\n\t\t\tlet typedDatasets;\n\t\t\tlet untypedDatasets;\n\t\t\tfor (const schema of this.options) {\n\t\t\t\tconst optionDataset = await schema[\"~run\"]({ value: dataset.value }, config$1);\n\t\t\t\tif (optionDataset.typed) if (optionDataset.issues) if (typedDatasets) typedDatasets.push(optionDataset);\n\t\t\t\telse typedDatasets = [optionDataset];\n\t\t\t\telse {\n\t\t\t\t\tvalidDataset = optionDataset;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if (untypedDatasets) untypedDatasets.push(optionDataset);\n\t\t\t\telse untypedDatasets = [optionDataset];\n\t\t\t}\n\t\t\tif (validDataset) return validDataset;\n\t\t\tif (typedDatasets) {\n\t\t\t\tif (typedDatasets.length === 1) return typedDatasets[0];\n\t\t\t\t_addIssue(this, \"type\", dataset, config$1, { issues: /* @__PURE__ */ _subIssues(typedDatasets) });\n\t\t\t\tdataset.typed = true;\n\t\t\t} else if (untypedDatasets?.length === 1) return untypedDatasets[0];\n\t\t\telse _addIssue(this, \"type\", dataset, config$1, { issues: /* @__PURE__ */ _subIssues(untypedDatasets) });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/unknown/unknown.ts\n/**\n* Creates a unknown schema.\n*\n* @returns A unknown schema.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction unknown() {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"unknown\",\n\t\treference: unknown,\n\t\texpects: \"unknown\",\n\t\tasync: false,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset) {\n\t\t\tdataset.typed = true;\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/variant/variant.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction variant(key, options, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"variant\",\n\t\treference: variant,\n\t\texpects: \"Object\",\n\t\tasync: false,\n\t\tkey,\n\t\toptions,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tconst input = dataset.value;\n\t\t\tif (input && typeof input === \"object\") {\n\t\t\t\tlet outputDataset;\n\t\t\t\tlet maxDiscriminatorPriority = 0;\n\t\t\t\tlet invalidDiscriminatorKey = this.key;\n\t\t\t\tlet expectedDiscriminators = [];\n\t\t\t\tconst parseOptions = (variant$1, allKeys) => {\n\t\t\t\t\tfor (const schema of variant$1.options) {\n\t\t\t\t\t\tif (schema.type === \"variant\") parseOptions(schema, new Set(allKeys).add(schema.key));\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tlet keysAreValid = true;\n\t\t\t\t\t\t\tlet currentPriority = 0;\n\t\t\t\t\t\t\tfor (const currentKey of allKeys) {\n\t\t\t\t\t\t\t\tconst discriminatorSchema = schema.entries[currentKey];\n\t\t\t\t\t\t\t\tif (currentKey in input ? discriminatorSchema[\"~run\"]({\n\t\t\t\t\t\t\t\t\ttyped: false,\n\t\t\t\t\t\t\t\t\tvalue: input[currentKey]\n\t\t\t\t\t\t\t\t}, { abortEarly: true }).issues : discriminatorSchema.type !== \"exact_optional\" && discriminatorSchema.type !== \"optional\" && discriminatorSchema.type !== \"nullish\") {\n\t\t\t\t\t\t\t\t\tkeysAreValid = false;\n\t\t\t\t\t\t\t\t\tif (invalidDiscriminatorKey !== currentKey && (maxDiscriminatorPriority < currentPriority || maxDiscriminatorPriority === currentPriority && currentKey in input && !(invalidDiscriminatorKey in input))) {\n\t\t\t\t\t\t\t\t\t\tmaxDiscriminatorPriority = currentPriority;\n\t\t\t\t\t\t\t\t\t\tinvalidDiscriminatorKey = currentKey;\n\t\t\t\t\t\t\t\t\t\texpectedDiscriminators = [];\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (invalidDiscriminatorKey === currentKey) expectedDiscriminators.push(schema.entries[currentKey].expects);\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcurrentPriority++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (keysAreValid) {\n\t\t\t\t\t\t\t\tconst optionDataset = schema[\"~run\"]({ value: input }, config$1);\n\t\t\t\t\t\t\t\tif (!outputDataset || !outputDataset.typed && optionDataset.typed) outputDataset = optionDataset;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (outputDataset && !outputDataset.issues) break;\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tparseOptions(this, new Set([this.key]));\n\t\t\t\tif (outputDataset) return outputDataset;\n\t\t\t\t_addIssue(this, \"type\", dataset, config$1, {\n\t\t\t\t\tinput: input[invalidDiscriminatorKey],\n\t\t\t\t\texpected: /* @__PURE__ */ _joinExpects(expectedDiscriminators, \"|\"),\n\t\t\t\t\tpath: [{\n\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\tinput,\n\t\t\t\t\t\tkey: invalidDiscriminatorKey,\n\t\t\t\t\t\tvalue: input[invalidDiscriminatorKey]\n\t\t\t\t\t}]\n\t\t\t\t});\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/variant/variantAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction variantAsync(key, options, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"variant\",\n\t\treference: variantAsync,\n\t\texpects: \"Object\",\n\t\tasync: true,\n\t\tkey,\n\t\toptions,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tconst input = dataset.value;\n\t\t\tif (input && typeof input === \"object\") {\n\t\t\t\tlet outputDataset;\n\t\t\t\tlet maxDiscriminatorPriority = 0;\n\t\t\t\tlet invalidDiscriminatorKey = this.key;\n\t\t\t\tlet expectedDiscriminators = [];\n\t\t\t\tconst parseOptions = async (variant$1, allKeys) => {\n\t\t\t\t\tfor (const schema of variant$1.options) {\n\t\t\t\t\t\tif (schema.type === \"variant\") await parseOptions(schema, new Set(allKeys).add(schema.key));\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tlet keysAreValid = true;\n\t\t\t\t\t\t\tlet currentPriority = 0;\n\t\t\t\t\t\t\tfor (const currentKey of allKeys) {\n\t\t\t\t\t\t\t\tconst discriminatorSchema = schema.entries[currentKey];\n\t\t\t\t\t\t\t\tif (currentKey in input ? (await discriminatorSchema[\"~run\"]({\n\t\t\t\t\t\t\t\t\ttyped: false,\n\t\t\t\t\t\t\t\t\tvalue: input[currentKey]\n\t\t\t\t\t\t\t\t}, { abortEarly: true })).issues : discriminatorSchema.type !== \"exact_optional\" && discriminatorSchema.type !== \"optional\" && discriminatorSchema.type !== \"nullish\") {\n\t\t\t\t\t\t\t\t\tkeysAreValid = false;\n\t\t\t\t\t\t\t\t\tif (invalidDiscriminatorKey !== currentKey && (maxDiscriminatorPriority < currentPriority || maxDiscriminatorPriority === currentPriority && currentKey in input && !(invalidDiscriminatorKey in input))) {\n\t\t\t\t\t\t\t\t\t\tmaxDiscriminatorPriority = currentPriority;\n\t\t\t\t\t\t\t\t\t\tinvalidDiscriminatorKey = currentKey;\n\t\t\t\t\t\t\t\t\t\texpectedDiscriminators = [];\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (invalidDiscriminatorKey === currentKey) expectedDiscriminators.push(schema.entries[currentKey].expects);\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcurrentPriority++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (keysAreValid) {\n\t\t\t\t\t\t\t\tconst optionDataset = await schema[\"~run\"]({ value: input }, config$1);\n\t\t\t\t\t\t\t\tif (!outputDataset || !outputDataset.typed && optionDataset.typed) outputDataset = optionDataset;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (outputDataset && !outputDataset.issues) break;\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tawait parseOptions(this, new Set([this.key]));\n\t\t\t\tif (outputDataset) return outputDataset;\n\t\t\t\t_addIssue(this, \"type\", dataset, config$1, {\n\t\t\t\t\tinput: input[invalidDiscriminatorKey],\n\t\t\t\t\texpected: /* @__PURE__ */ _joinExpects(expectedDiscriminators, \"|\"),\n\t\t\t\t\tpath: [{\n\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\tinput,\n\t\t\t\t\t\tkey: invalidDiscriminatorKey,\n\t\t\t\t\t\tvalue: input[invalidDiscriminatorKey]\n\t\t\t\t\t}]\n\t\t\t\t});\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/void/void.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction void_(message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"void\",\n\t\treference: void_,\n\t\texpects: \"void\",\n\t\tasync: false,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.value === void 0) dataset.typed = true;\n\t\t\telse _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/methods/keyof/keyof.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction keyof(schema, message$1) {\n\treturn /* @__PURE__ */ picklist(Object.keys(schema.entries), message$1);\n}\n\n//#endregion\n//#region src/methods/message/message.ts\n/**\n* Changes the local message configuration of a schema.\n*\n* @param schema The schema to configure.\n* @param message_ The error message.\n*\n* @returns The configured schema.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction message(schema, message_) {\n\treturn {\n\t\t...schema,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\treturn schema[\"~run\"](dataset, {\n\t\t\t\t...config$1,\n\t\t\t\tmessage: message_\n\t\t\t});\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/methods/omit/omit.ts\n/**\n* Creates a modified copy of an object schema that does not contain the\n* selected entries.\n*\n* @param schema The schema to omit from.\n* @param keys The selected entries.\n*\n* @returns An object schema.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction omit(schema, keys) {\n\tconst entries$1 = { ...schema.entries };\n\tfor (const key of keys) delete entries$1[key];\n\treturn {\n\t\t...schema,\n\t\tentries: entries$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/methods/parse/parse.ts\n/**\n* Parses an unknown input based on a schema.\n*\n* @param schema The schema to be used.\n* @param input The input to be parsed.\n* @param config The parse configuration.\n*\n* @returns The parsed input.\n*/\nfunction parse(schema, input, config$1) {\n\tconst dataset = schema[\"~run\"]({ value: input }, /* @__PURE__ */ getGlobalConfig(config$1));\n\tif (dataset.issues) throw new ValiError(dataset.issues);\n\treturn dataset.value;\n}\n\n//#endregion\n//#region src/methods/parse/parseAsync.ts\n/**\n* Parses an unknown input based on a schema.\n*\n* @param schema The schema to be used.\n* @param input The input to be parsed.\n* @param config The parse configuration.\n*\n* @returns The parsed input.\n*/\nasync function parseAsync(schema, input, config$1) {\n\tconst dataset = await schema[\"~run\"]({ value: input }, /* @__PURE__ */ getGlobalConfig(config$1));\n\tif (dataset.issues) throw new ValiError(dataset.issues);\n\treturn dataset.value;\n}\n\n//#endregion\n//#region src/methods/parser/parser.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction parser(schema, config$1) {\n\tconst func = (input) => parse(schema, input, config$1);\n\tfunc.schema = schema;\n\tfunc.config = config$1;\n\treturn func;\n}\n\n//#endregion\n//#region src/methods/parser/parserAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction parserAsync(schema, config$1) {\n\tconst func = (input) => parseAsync(schema, input, config$1);\n\tfunc.schema = schema;\n\tfunc.config = config$1;\n\treturn func;\n}\n\n//#endregion\n//#region src/methods/partial/partial.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction partial(schema, keys) {\n\tconst entries$1 = {};\n\tfor (const key in schema.entries) entries$1[key] = !keys || keys.includes(key) ? /* @__PURE__ */ optional(schema.entries[key]) : schema.entries[key];\n\treturn {\n\t\t...schema,\n\t\tentries: entries$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/methods/partial/partialAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction partialAsync(schema, keys) {\n\tconst entries$1 = {};\n\tfor (const key in schema.entries) entries$1[key] = !keys || keys.includes(key) ? /* @__PURE__ */ optionalAsync(schema.entries[key]) : schema.entries[key];\n\treturn {\n\t\t...schema,\n\t\tentries: entries$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/methods/pick/pick.ts\n/**\n* Creates a modified copy of an object schema that contains only the selected\n* entries.\n*\n* @param schema The schema to pick from.\n* @param keys The selected entries.\n*\n* @returns An object schema.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction pick(schema, keys) {\n\tconst entries$1 = {};\n\tfor (const key of keys) entries$1[key] = schema.entries[key];\n\treturn {\n\t\t...schema,\n\t\tentries: entries$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/methods/pipe/pipe.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction pipe(...pipe$1) {\n\treturn {\n\t\t...pipe$1[0],\n\t\tpipe: pipe$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tfor (const item of pipe$1) if (item.kind !== \"metadata\") {\n\t\t\t\tif (dataset.issues && (item.kind === \"schema\" || item.kind === \"transformation\")) {\n\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!dataset.issues || !config$1.abortEarly && !config$1.abortPipeEarly) dataset = item[\"~run\"](dataset, config$1);\n\t\t\t}\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/methods/pipe/pipeAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction pipeAsync(...pipe$1) {\n\treturn {\n\t\t...pipe$1[0],\n\t\tpipe: pipe$1,\n\t\tasync: true,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tfor (const item of pipe$1) if (item.kind !== \"metadata\") {\n\t\t\t\tif (dataset.issues && (item.kind === \"schema\" || item.kind === \"transformation\")) {\n\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!dataset.issues || !config$1.abortEarly && !config$1.abortPipeEarly) dataset = await item[\"~run\"](dataset, config$1);\n\t\t\t}\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/methods/required/required.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction required(schema, arg2, arg3) {\n\tconst keys = Array.isArray(arg2) ? arg2 : void 0;\n\tconst message$1 = Array.isArray(arg2) ? arg3 : arg2;\n\tconst entries$1 = {};\n\tfor (const key in schema.entries) entries$1[key] = !keys || keys.includes(key) ? /* @__PURE__ */ nonOptional(schema.entries[key], message$1) : schema.entries[key];\n\treturn {\n\t\t...schema,\n\t\tentries: entries$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/methods/required/requiredAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction requiredAsync(schema, arg2, arg3) {\n\tconst keys = Array.isArray(arg2) ? arg2 : void 0;\n\tconst message$1 = Array.isArray(arg2) ? arg3 : arg2;\n\tconst entries$1 = {};\n\tfor (const key in schema.entries) entries$1[key] = !keys || keys.includes(key) ? /* @__PURE__ */ nonOptionalAsync(schema.entries[key], message$1) : schema.entries[key];\n\treturn {\n\t\t...schema,\n\t\tentries: entries$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/methods/safeParse/safeParse.ts\n/**\n* Parses an unknown input based on a schema.\n*\n* @param schema The schema to be used.\n* @param input The input to be parsed.\n* @param config The parse configuration.\n*\n* @returns The parse result.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction safeParse(schema, input, config$1) {\n\tconst dataset = schema[\"~run\"]({ value: input }, /* @__PURE__ */ getGlobalConfig(config$1));\n\treturn {\n\t\ttyped: dataset.typed,\n\t\tsuccess: !dataset.issues,\n\t\toutput: dataset.value,\n\t\tissues: dataset.issues\n\t};\n}\n\n//#endregion\n//#region src/methods/safeParse/safeParseAsync.ts\n/**\n* Parses an unknown input based on a schema.\n*\n* @param schema The schema to be used.\n* @param input The input to be parsed.\n* @param config The parse configuration.\n*\n* @returns The parse result.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nasync function safeParseAsync(schema, input, config$1) {\n\tconst dataset = await schema[\"~run\"]({ value: input }, /* @__PURE__ */ getGlobalConfig(config$1));\n\treturn {\n\t\ttyped: dataset.typed,\n\t\tsuccess: !dataset.issues,\n\t\toutput: dataset.value,\n\t\tissues: dataset.issues\n\t};\n}\n\n//#endregion\n//#region src/methods/safeParser/safeParser.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction safeParser(schema, config$1) {\n\tconst func = (input) => /* @__PURE__ */ safeParse(schema, input, config$1);\n\tfunc.schema = schema;\n\tfunc.config = config$1;\n\treturn func;\n}\n\n//#endregion\n//#region src/methods/safeParser/safeParserAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction safeParserAsync(schema, config$1) {\n\tconst func = (input) => /* @__PURE__ */ safeParseAsync(schema, input, config$1);\n\tfunc.schema = schema;\n\tfunc.config = config$1;\n\treturn func;\n}\n\n//#endregion\n//#region src/methods/summarize/summarize.ts\n/**\n* Summarize the error messages of issues in a pretty-printable multi-line string.\n*\n* @param issues The list of issues.\n*\n* @returns A summary of the issues.\n*\n* @beta\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction summarize(issues) {\n\tlet summary = \"\";\n\tfor (const issue of issues) {\n\t\tif (summary) summary += \"\\n\";\n\t\tsummary += ` ${issue.message}`;\n\t\tconst dotPath = /* @__PURE__ */ getDotPath(issue);\n\t\tif (dotPath) summary += `\\n   at ${dotPath}`;\n\t}\n\treturn summary;\n}\n\n//#endregion\n//#region src/methods/unwrap/unwrap.ts\n/**\n* Unwraps the wrapped schema.\n*\n* @param schema The schema to be unwrapped.\n*\n* @returns The unwrapped schema.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction unwrap(schema) {\n\treturn schema.wrapped;\n}\n\n//#endregion\nexport { BASE64_REGEX, BIC_REGEX, CUID2_REGEX, DECIMAL_REGEX, DIGITS_REGEX, EMAIL_REGEX, EMOJI_REGEX, HEXADECIMAL_REGEX, HEX_COLOR_REGEX, IMEI_REGEX, IPV4_REGEX, IPV6_REGEX, IP_REGEX, ISO_DATE_REGEX, ISO_DATE_TIME_REGEX, ISO_TIMESTAMP_REGEX, ISO_TIME_REGEX, ISO_TIME_SECOND_REGEX, ISO_WEEK_REGEX, MAC48_REGEX, MAC64_REGEX, MAC_REGEX, NANO_ID_REGEX, OCTAL_REGEX, RFC_EMAIL_REGEX, SLUG_REGEX, ULID_REGEX, UUID_REGEX, ValiError, _addIssue, _getByteCount, _getGraphemeCount, _getLastMetadata, _getStandardProps, _getWordCount, _isLuhnAlgo, _isValidObjectKey, _joinExpects, _stringify, any, args, argsAsync, array, arrayAsync, assert, awaitAsync, base64, bic, bigint, blob, boolean, brand, bytes, check, checkAsync, checkItems, checkItemsAsync, config, creditCard, cuid2, custom, customAsync, date, decimal, deleteGlobalConfig, deleteGlobalMessage, deleteSchemaMessage, deleteSpecificMessage, description, digits, email, emoji, empty, endsWith, entries, entriesFromList, entriesFromObjects, enum_ as enum, enum_, everyItem, exactOptional, exactOptionalAsync, examples, excludes, fallback, fallbackAsync, file, filterItems, findItem, finite, flatten, flavor, forward, forwardAsync, function_ as function, function_, getDefault, getDefaults, getDefaultsAsync, getDescription, getDotPath, getExamples, getFallback, getFallbacks, getFallbacksAsync, getGlobalConfig, getGlobalMessage, getMetadata, getSchemaMessage, getSpecificMessage, getTitle, graphemes, gtValue, hash, hexColor, hexadecimal, imei, includes, instance, integer, intersect, intersectAsync, ip, ipv4, ipv6, is, isOfKind, isOfType, isValiError, isoDate, isoDateTime, isoTime, isoTimeSecond, isoTimestamp, isoWeek, keyof, lazy, lazyAsync, length, literal, looseObject, looseObjectAsync, looseTuple, looseTupleAsync, ltValue, mac, mac48, mac64, map, mapAsync, mapItems, maxBytes, maxEntries, maxGraphemes, maxLength, maxSize, maxValue, maxWords, message, metadata, mimeType, minBytes, minEntries, minGraphemes, minLength, minSize, minValue, minWords, multipleOf, nan, nanoid, never, nonEmpty, nonNullable, nonNullableAsync, nonNullish, nonNullishAsync, nonOptional, nonOptionalAsync, normalize, notBytes, notEntries, notGraphemes, notLength, notSize, notValue, notValues, notWords, null_ as null, null_, nullable, nullableAsync, nullish, nullishAsync, number, object, objectAsync, objectWithRest, objectWithRestAsync, octal, omit, optional, optionalAsync, parse, parseAsync, parseJson, parser, parserAsync, partial, partialAsync, partialCheck, partialCheckAsync, pick, picklist, pipe, pipeAsync, promise, rawCheck, rawCheckAsync, rawTransform, rawTransformAsync, readonly, record, recordAsync, reduceItems, regex, required, requiredAsync, returns, returnsAsync, rfcEmail, safeInteger, safeParse, safeParseAsync, safeParser, safeParserAsync, set, setAsync, setGlobalConfig, setGlobalMessage, setSchemaMessage, setSpecificMessage, size, slug, someItem, sortItems, startsWith, strictObject, strictObjectAsync, strictTuple, strictTupleAsync, string, stringifyJson, summarize, symbol, title, toBigint, toBoolean, toDate, toLowerCase, toMaxValue, toMinValue, toNumber, toString, toUpperCase, transform, transformAsync, trim, trimEnd, trimStart, tuple, tupleAsync, tupleWithRest, tupleWithRestAsync, ulid, undefined_ as undefined, undefined_, undefinedable, undefinedableAsync, union, unionAsync, unknown, unwrap, url, uuid, value, values, variant, variantAsync, void_ as void, void_, words };","import {\n  array,\n  boolean,\n  check,\n  integer,\n  lazy,\n  literal,\n  nullable,\n  nullish,\n  number,\n  object,\n  optional,\n  pipe,\n  record,\n  string,\n  transform,\n  tuple,\n  union,\n  unknown\n} from \"valibot\";\nimport { isValidSuiAddress, normalizeSuiAddress } from \"../../utils/sui-types.js\";\nfunction safeEnum(options) {\n  const unionOptions = Object.entries(options).map(([key, value]) => object({ [key]: value }));\n  return pipe(\n    union(unionOptions),\n    transform(\n      (value) => ({\n        ...value,\n        $kind: Object.keys(value)[0]\n      })\n    )\n  );\n}\nconst SuiAddress = pipe(\n  string(),\n  transform((value) => normalizeSuiAddress(value)),\n  check(isValidSuiAddress)\n);\nconst ObjectID = SuiAddress;\nconst BCSBytes = string();\nconst JsonU64 = pipe(\n  union([string(), pipe(number(), integer())]),\n  check((val) => {\n    try {\n      BigInt(val);\n      return BigInt(val) >= 0 && BigInt(val) <= 18446744073709551615n;\n    } catch {\n      return false;\n    }\n  }, \"Invalid u64\")\n);\nconst ObjectRefSchema = object({\n  objectId: SuiAddress,\n  version: JsonU64,\n  digest: string()\n});\nconst ArgumentSchema = pipe(\n  union([\n    object({ GasCoin: literal(true) }),\n    object({ Input: pipe(number(), integer()), type: optional(literal(\"pure\")) }),\n    object({ Input: pipe(number(), integer()), type: optional(literal(\"object\")) }),\n    object({ Result: pipe(number(), integer()) }),\n    object({ NestedResult: tuple([pipe(number(), integer()), pipe(number(), integer())]) })\n  ]),\n  transform((value) => ({\n    ...value,\n    $kind: Object.keys(value)[0]\n  }))\n  // Defined manually to add `type?: 'pure' | 'object'` to Input\n);\nconst GasDataSchema = object({\n  budget: nullable(JsonU64),\n  price: nullable(JsonU64),\n  owner: nullable(SuiAddress),\n  payment: nullable(array(ObjectRefSchema))\n});\nconst StructTagSchema = object({\n  address: string(),\n  module: string(),\n  name: string(),\n  // type_params in rust, should be updated to use camelCase\n  typeParams: array(string())\n});\nconst OpenMoveTypeSignatureBodySchema = union([\n  literal(\"address\"),\n  literal(\"bool\"),\n  literal(\"u8\"),\n  literal(\"u16\"),\n  literal(\"u32\"),\n  literal(\"u64\"),\n  literal(\"u128\"),\n  literal(\"u256\"),\n  object({ vector: lazy(() => OpenMoveTypeSignatureBodySchema) }),\n  object({\n    datatype: object({\n      package: string(),\n      module: string(),\n      type: string(),\n      typeParameters: array(lazy(() => OpenMoveTypeSignatureBodySchema))\n    })\n  }),\n  object({ typeParameter: pipe(number(), integer()) })\n]);\nconst OpenMoveTypeSignatureSchema = object({\n  ref: nullable(union([literal(\"&\"), literal(\"&mut\")])),\n  body: OpenMoveTypeSignatureBodySchema\n});\nconst ProgrammableMoveCallSchema = object({\n  package: ObjectID,\n  module: string(),\n  function: string(),\n  // snake case in rust\n  typeArguments: array(string()),\n  arguments: array(ArgumentSchema),\n  _argumentTypes: optional(nullable(array(OpenMoveTypeSignatureSchema)))\n});\nconst $Intent = object({\n  name: string(),\n  inputs: record(string(), union([ArgumentSchema, array(ArgumentSchema)])),\n  data: record(string(), unknown())\n});\nconst CommandSchema = safeEnum({\n  MoveCall: ProgrammableMoveCallSchema,\n  TransferObjects: object({\n    objects: array(ArgumentSchema),\n    address: ArgumentSchema\n  }),\n  SplitCoins: object({\n    coin: ArgumentSchema,\n    amounts: array(ArgumentSchema)\n  }),\n  MergeCoins: object({\n    destination: ArgumentSchema,\n    sources: array(ArgumentSchema)\n  }),\n  Publish: object({\n    modules: array(BCSBytes),\n    dependencies: array(ObjectID)\n  }),\n  MakeMoveVec: object({\n    type: nullable(string()),\n    elements: array(ArgumentSchema)\n  }),\n  Upgrade: object({\n    modules: array(BCSBytes),\n    dependencies: array(ObjectID),\n    package: ObjectID,\n    ticket: ArgumentSchema\n  }),\n  $Intent\n});\nconst ObjectArgSchema = safeEnum({\n  ImmOrOwnedObject: ObjectRefSchema,\n  SharedObject: object({\n    objectId: ObjectID,\n    // snake case in rust\n    initialSharedVersion: JsonU64,\n    mutable: boolean()\n  }),\n  Receiving: ObjectRefSchema\n});\nconst CallArgSchema = safeEnum({\n  Object: ObjectArgSchema,\n  Pure: object({\n    bytes: BCSBytes\n  }),\n  UnresolvedPure: object({\n    value: unknown()\n  }),\n  UnresolvedObject: object({\n    objectId: ObjectID,\n    version: optional(nullable(JsonU64)),\n    digest: optional(nullable(string())),\n    initialSharedVersion: optional(nullable(JsonU64)),\n    mutable: optional(nullable(boolean()))\n  })\n});\nconst NormalizedCallArg = safeEnum({\n  Object: ObjectArgSchema,\n  Pure: object({\n    bytes: BCSBytes\n  })\n});\nconst TransactionExpiration = safeEnum({\n  None: literal(true),\n  Epoch: JsonU64\n});\nconst TransactionDataSchema = object({\n  version: literal(2),\n  sender: nullish(SuiAddress),\n  expiration: nullish(TransactionExpiration),\n  gasData: GasDataSchema,\n  inputs: array(CallArgSchema),\n  commands: array(CommandSchema)\n});\nexport {\n  $Intent,\n  ArgumentSchema,\n  BCSBytes,\n  CommandSchema,\n  GasDataSchema,\n  JsonU64,\n  NormalizedCallArg,\n  ObjectArgSchema,\n  ObjectID,\n  ObjectRefSchema,\n  OpenMoveTypeSignatureBodySchema,\n  OpenMoveTypeSignatureSchema,\n  StructTagSchema,\n  SuiAddress,\n  TransactionDataSchema,\n  TransactionExpiration,\n  safeEnum\n};\n//# sourceMappingURL=internal.js.map\n","import { toBase64 } from \"@mysten/bcs\";\nimport { parse } from \"valibot\";\nimport { normalizeSuiObjectId } from \"../utils/sui-types.js\";\nimport { ArgumentSchema } from \"./data/internal.js\";\nvar UpgradePolicy = /* @__PURE__ */ ((UpgradePolicy2) => {\n  UpgradePolicy2[UpgradePolicy2[\"COMPATIBLE\"] = 0] = \"COMPATIBLE\";\n  UpgradePolicy2[UpgradePolicy2[\"ADDITIVE\"] = 128] = \"ADDITIVE\";\n  UpgradePolicy2[UpgradePolicy2[\"DEP_ONLY\"] = 192] = \"DEP_ONLY\";\n  return UpgradePolicy2;\n})(UpgradePolicy || {});\nconst Commands = {\n  MoveCall(input) {\n    const [pkg, mod = \"\", fn = \"\"] = \"target\" in input ? input.target.split(\"::\") : [input.package, input.module, input.function];\n    return {\n      $kind: \"MoveCall\",\n      MoveCall: {\n        package: pkg,\n        module: mod,\n        function: fn,\n        typeArguments: input.typeArguments ?? [],\n        arguments: input.arguments ?? []\n      }\n    };\n  },\n  TransferObjects(objects, address) {\n    return {\n      $kind: \"TransferObjects\",\n      TransferObjects: {\n        objects: objects.map((o) => parse(ArgumentSchema, o)),\n        address: parse(ArgumentSchema, address)\n      }\n    };\n  },\n  SplitCoins(coin, amounts) {\n    return {\n      $kind: \"SplitCoins\",\n      SplitCoins: {\n        coin: parse(ArgumentSchema, coin),\n        amounts: amounts.map((o) => parse(ArgumentSchema, o))\n      }\n    };\n  },\n  MergeCoins(destination, sources) {\n    return {\n      $kind: \"MergeCoins\",\n      MergeCoins: {\n        destination: parse(ArgumentSchema, destination),\n        sources: sources.map((o) => parse(ArgumentSchema, o))\n      }\n    };\n  },\n  Publish({\n    modules,\n    dependencies\n  }) {\n    return {\n      $kind: \"Publish\",\n      Publish: {\n        modules: modules.map(\n          (module) => typeof module === \"string\" ? module : toBase64(new Uint8Array(module))\n        ),\n        dependencies: dependencies.map((dep) => normalizeSuiObjectId(dep))\n      }\n    };\n  },\n  Upgrade({\n    modules,\n    dependencies,\n    package: packageId,\n    ticket\n  }) {\n    return {\n      $kind: \"Upgrade\",\n      Upgrade: {\n        modules: modules.map(\n          (module) => typeof module === \"string\" ? module : toBase64(new Uint8Array(module))\n        ),\n        dependencies: dependencies.map((dep) => normalizeSuiObjectId(dep)),\n        package: packageId,\n        ticket: parse(ArgumentSchema, ticket)\n      }\n    };\n  },\n  MakeMoveVec({\n    type,\n    elements\n  }) {\n    return {\n      $kind: \"MakeMoveVec\",\n      MakeMoveVec: {\n        type: type ?? null,\n        elements: elements.map((o) => parse(ArgumentSchema, o))\n      }\n    };\n  },\n  Intent({\n    name,\n    inputs = {},\n    data = {}\n  }) {\n    return {\n      $kind: \"$Intent\",\n      $Intent: {\n        name,\n        inputs: Object.fromEntries(\n          Object.entries(inputs).map(([key, value]) => [\n            key,\n            Array.isArray(value) ? value.map((o) => parse(ArgumentSchema, o)) : parse(ArgumentSchema, value)\n          ])\n        ),\n        data\n      }\n    };\n  }\n};\nexport {\n  Commands,\n  UpgradePolicy\n};\n//# sourceMappingURL=Commands.js.map\n","import { fromBase64, toBase64 } from \"@mysten/bcs\";\nimport {\n  array,\n  bigint,\n  boolean,\n  check,\n  integer,\n  is,\n  lazy,\n  literal,\n  nullable,\n  nullish,\n  number,\n  object,\n  optional,\n  parse,\n  pipe,\n  string,\n  union,\n  unknown\n} from \"valibot\";\nimport { TypeTagSerializer } from \"../../bcs/index.js\";\nimport { JsonU64, ObjectID, safeEnum, TransactionDataSchema } from \"./internal.js\";\nconst ObjectRef = object({\n  digest: string(),\n  objectId: string(),\n  version: union([pipe(number(), integer()), string(), bigint()])\n});\nconst ObjectArg = safeEnum({\n  ImmOrOwned: ObjectRef,\n  Shared: object({\n    objectId: ObjectID,\n    initialSharedVersion: JsonU64,\n    mutable: boolean()\n  }),\n  Receiving: ObjectRef\n});\nconst NormalizedCallArg = safeEnum({\n  Object: ObjectArg,\n  Pure: array(pipe(number(), integer()))\n});\nconst TransactionInput = union([\n  object({\n    kind: literal(\"Input\"),\n    index: pipe(number(), integer()),\n    value: unknown(),\n    type: optional(literal(\"object\"))\n  }),\n  object({\n    kind: literal(\"Input\"),\n    index: pipe(number(), integer()),\n    value: unknown(),\n    type: literal(\"pure\")\n  })\n]);\nconst TransactionExpiration = union([\n  object({ Epoch: pipe(number(), integer()) }),\n  object({ None: nullable(literal(true)) })\n]);\nconst StringEncodedBigint = pipe(\n  union([number(), string(), bigint()]),\n  check((val) => {\n    if (![\"string\", \"number\", \"bigint\"].includes(typeof val)) return false;\n    try {\n      BigInt(val);\n      return true;\n    } catch {\n      return false;\n    }\n  })\n);\nconst TypeTag = union([\n  object({ bool: nullable(literal(true)) }),\n  object({ u8: nullable(literal(true)) }),\n  object({ u64: nullable(literal(true)) }),\n  object({ u128: nullable(literal(true)) }),\n  object({ address: nullable(literal(true)) }),\n  object({ signer: nullable(literal(true)) }),\n  object({ vector: lazy(() => TypeTag) }),\n  object({ struct: lazy(() => StructTag) }),\n  object({ u16: nullable(literal(true)) }),\n  object({ u32: nullable(literal(true)) }),\n  object({ u256: nullable(literal(true)) })\n]);\nconst StructTag = object({\n  address: string(),\n  module: string(),\n  name: string(),\n  typeParams: array(TypeTag)\n});\nconst GasConfig = object({\n  budget: optional(StringEncodedBigint),\n  price: optional(StringEncodedBigint),\n  payment: optional(array(ObjectRef)),\n  owner: optional(string())\n});\nconst TransactionArgumentTypes = [\n  TransactionInput,\n  object({ kind: literal(\"GasCoin\") }),\n  object({ kind: literal(\"Result\"), index: pipe(number(), integer()) }),\n  object({\n    kind: literal(\"NestedResult\"),\n    index: pipe(number(), integer()),\n    resultIndex: pipe(number(), integer())\n  })\n];\nconst TransactionArgument = union([...TransactionArgumentTypes]);\nconst MoveCallTransaction = object({\n  kind: literal(\"MoveCall\"),\n  target: pipe(\n    string(),\n    check((target) => target.split(\"::\").length === 3)\n  ),\n  typeArguments: array(string()),\n  arguments: array(TransactionArgument)\n});\nconst TransferObjectsTransaction = object({\n  kind: literal(\"TransferObjects\"),\n  objects: array(TransactionArgument),\n  address: TransactionArgument\n});\nconst SplitCoinsTransaction = object({\n  kind: literal(\"SplitCoins\"),\n  coin: TransactionArgument,\n  amounts: array(TransactionArgument)\n});\nconst MergeCoinsTransaction = object({\n  kind: literal(\"MergeCoins\"),\n  destination: TransactionArgument,\n  sources: array(TransactionArgument)\n});\nconst MakeMoveVecTransaction = object({\n  kind: literal(\"MakeMoveVec\"),\n  type: union([object({ Some: TypeTag }), object({ None: nullable(literal(true)) })]),\n  objects: array(TransactionArgument)\n});\nconst PublishTransaction = object({\n  kind: literal(\"Publish\"),\n  modules: array(array(pipe(number(), integer()))),\n  dependencies: array(string())\n});\nconst UpgradeTransaction = object({\n  kind: literal(\"Upgrade\"),\n  modules: array(array(pipe(number(), integer()))),\n  dependencies: array(string()),\n  packageId: string(),\n  ticket: TransactionArgument\n});\nconst TransactionTypes = [\n  MoveCallTransaction,\n  TransferObjectsTransaction,\n  SplitCoinsTransaction,\n  MergeCoinsTransaction,\n  PublishTransaction,\n  UpgradeTransaction,\n  MakeMoveVecTransaction\n];\nconst TransactionType = union([...TransactionTypes]);\nconst SerializedTransactionDataV1 = object({\n  version: literal(1),\n  sender: optional(string()),\n  expiration: nullish(TransactionExpiration),\n  gasConfig: GasConfig,\n  inputs: array(TransactionInput),\n  transactions: array(TransactionType)\n});\nfunction serializeV1TransactionData(transactionData) {\n  const inputs = transactionData.inputs.map(\n    (input, index) => {\n      if (input.Object) {\n        return {\n          kind: \"Input\",\n          index,\n          value: {\n            Object: input.Object.ImmOrOwnedObject ? {\n              ImmOrOwned: input.Object.ImmOrOwnedObject\n            } : input.Object.Receiving ? {\n              Receiving: {\n                digest: input.Object.Receiving.digest,\n                version: input.Object.Receiving.version,\n                objectId: input.Object.Receiving.objectId\n              }\n            } : {\n              Shared: {\n                mutable: input.Object.SharedObject.mutable,\n                initialSharedVersion: input.Object.SharedObject.initialSharedVersion,\n                objectId: input.Object.SharedObject.objectId\n              }\n            }\n          },\n          type: \"object\"\n        };\n      }\n      if (input.Pure) {\n        return {\n          kind: \"Input\",\n          index,\n          value: {\n            Pure: Array.from(fromBase64(input.Pure.bytes))\n          },\n          type: \"pure\"\n        };\n      }\n      if (input.UnresolvedPure) {\n        return {\n          kind: \"Input\",\n          type: \"pure\",\n          index,\n          value: input.UnresolvedPure.value\n        };\n      }\n      if (input.UnresolvedObject) {\n        return {\n          kind: \"Input\",\n          type: \"object\",\n          index,\n          value: input.UnresolvedObject.objectId\n        };\n      }\n      throw new Error(\"Invalid input\");\n    }\n  );\n  return {\n    version: 1,\n    sender: transactionData.sender ?? void 0,\n    expiration: transactionData.expiration?.$kind === \"Epoch\" ? { Epoch: Number(transactionData.expiration.Epoch) } : transactionData.expiration ? { None: true } : null,\n    gasConfig: {\n      owner: transactionData.gasData.owner ?? void 0,\n      budget: transactionData.gasData.budget ?? void 0,\n      price: transactionData.gasData.price ?? void 0,\n      payment: transactionData.gasData.payment ?? void 0\n    },\n    inputs,\n    transactions: transactionData.commands.map((command) => {\n      if (command.MakeMoveVec) {\n        return {\n          kind: \"MakeMoveVec\",\n          type: command.MakeMoveVec.type === null ? { None: true } : { Some: TypeTagSerializer.parseFromStr(command.MakeMoveVec.type) },\n          objects: command.MakeMoveVec.elements.map(\n            (arg) => convertTransactionArgument(arg, inputs)\n          )\n        };\n      }\n      if (command.MergeCoins) {\n        return {\n          kind: \"MergeCoins\",\n          destination: convertTransactionArgument(command.MergeCoins.destination, inputs),\n          sources: command.MergeCoins.sources.map((arg) => convertTransactionArgument(arg, inputs))\n        };\n      }\n      if (command.MoveCall) {\n        return {\n          kind: \"MoveCall\",\n          target: `${command.MoveCall.package}::${command.MoveCall.module}::${command.MoveCall.function}`,\n          typeArguments: command.MoveCall.typeArguments,\n          arguments: command.MoveCall.arguments.map(\n            (arg) => convertTransactionArgument(arg, inputs)\n          )\n        };\n      }\n      if (command.Publish) {\n        return {\n          kind: \"Publish\",\n          modules: command.Publish.modules.map((mod) => Array.from(fromBase64(mod))),\n          dependencies: command.Publish.dependencies\n        };\n      }\n      if (command.SplitCoins) {\n        return {\n          kind: \"SplitCoins\",\n          coin: convertTransactionArgument(command.SplitCoins.coin, inputs),\n          amounts: command.SplitCoins.amounts.map((arg) => convertTransactionArgument(arg, inputs))\n        };\n      }\n      if (command.TransferObjects) {\n        return {\n          kind: \"TransferObjects\",\n          objects: command.TransferObjects.objects.map(\n            (arg) => convertTransactionArgument(arg, inputs)\n          ),\n          address: convertTransactionArgument(command.TransferObjects.address, inputs)\n        };\n      }\n      if (command.Upgrade) {\n        return {\n          kind: \"Upgrade\",\n          modules: command.Upgrade.modules.map((mod) => Array.from(fromBase64(mod))),\n          dependencies: command.Upgrade.dependencies,\n          packageId: command.Upgrade.package,\n          ticket: convertTransactionArgument(command.Upgrade.ticket, inputs)\n        };\n      }\n      throw new Error(`Unknown transaction ${Object.keys(command)}`);\n    })\n  };\n}\nfunction convertTransactionArgument(arg, inputs) {\n  if (arg.$kind === \"GasCoin\") {\n    return { kind: \"GasCoin\" };\n  }\n  if (arg.$kind === \"Result\") {\n    return { kind: \"Result\", index: arg.Result };\n  }\n  if (arg.$kind === \"NestedResult\") {\n    return { kind: \"NestedResult\", index: arg.NestedResult[0], resultIndex: arg.NestedResult[1] };\n  }\n  if (arg.$kind === \"Input\") {\n    return inputs[arg.Input];\n  }\n  throw new Error(`Invalid argument ${Object.keys(arg)}`);\n}\nfunction transactionDataFromV1(data) {\n  return parse(TransactionDataSchema, {\n    version: 2,\n    sender: data.sender ?? null,\n    expiration: data.expiration ? \"Epoch\" in data.expiration ? { Epoch: data.expiration.Epoch } : { None: true } : null,\n    gasData: {\n      owner: data.gasConfig.owner ?? null,\n      budget: data.gasConfig.budget?.toString() ?? null,\n      price: data.gasConfig.price?.toString() ?? null,\n      payment: data.gasConfig.payment?.map((ref) => ({\n        digest: ref.digest,\n        objectId: ref.objectId,\n        version: ref.version.toString()\n      })) ?? null\n    },\n    inputs: data.inputs.map((input) => {\n      if (input.kind === \"Input\") {\n        if (is(NormalizedCallArg, input.value)) {\n          const value = parse(NormalizedCallArg, input.value);\n          if (value.Object) {\n            if (value.Object.ImmOrOwned) {\n              return {\n                Object: {\n                  ImmOrOwnedObject: {\n                    objectId: value.Object.ImmOrOwned.objectId,\n                    version: String(value.Object.ImmOrOwned.version),\n                    digest: value.Object.ImmOrOwned.digest\n                  }\n                }\n              };\n            }\n            if (value.Object.Shared) {\n              return {\n                Object: {\n                  SharedObject: {\n                    mutable: value.Object.Shared.mutable ?? null,\n                    initialSharedVersion: value.Object.Shared.initialSharedVersion,\n                    objectId: value.Object.Shared.objectId\n                  }\n                }\n              };\n            }\n            if (value.Object.Receiving) {\n              return {\n                Object: {\n                  Receiving: {\n                    digest: value.Object.Receiving.digest,\n                    version: String(value.Object.Receiving.version),\n                    objectId: value.Object.Receiving.objectId\n                  }\n                }\n              };\n            }\n            throw new Error(\"Invalid object input\");\n          }\n          return {\n            Pure: {\n              bytes: toBase64(new Uint8Array(value.Pure))\n            }\n          };\n        }\n        if (input.type === \"object\") {\n          return {\n            UnresolvedObject: {\n              objectId: input.value\n            }\n          };\n        }\n        return {\n          UnresolvedPure: {\n            value: input.value\n          }\n        };\n      }\n      throw new Error(\"Invalid input\");\n    }),\n    commands: data.transactions.map((transaction) => {\n      switch (transaction.kind) {\n        case \"MakeMoveVec\":\n          return {\n            MakeMoveVec: {\n              type: \"Some\" in transaction.type ? TypeTagSerializer.tagToString(transaction.type.Some) : null,\n              elements: transaction.objects.map((arg) => parseV1TransactionArgument(arg))\n            }\n          };\n        case \"MergeCoins\": {\n          return {\n            MergeCoins: {\n              destination: parseV1TransactionArgument(transaction.destination),\n              sources: transaction.sources.map((arg) => parseV1TransactionArgument(arg))\n            }\n          };\n        }\n        case \"MoveCall\": {\n          const [pkg, mod, fn] = transaction.target.split(\"::\");\n          return {\n            MoveCall: {\n              package: pkg,\n              module: mod,\n              function: fn,\n              typeArguments: transaction.typeArguments,\n              arguments: transaction.arguments.map((arg) => parseV1TransactionArgument(arg))\n            }\n          };\n        }\n        case \"Publish\": {\n          return {\n            Publish: {\n              modules: transaction.modules.map((mod) => toBase64(Uint8Array.from(mod))),\n              dependencies: transaction.dependencies\n            }\n          };\n        }\n        case \"SplitCoins\": {\n          return {\n            SplitCoins: {\n              coin: parseV1TransactionArgument(transaction.coin),\n              amounts: transaction.amounts.map((arg) => parseV1TransactionArgument(arg))\n            }\n          };\n        }\n        case \"TransferObjects\": {\n          return {\n            TransferObjects: {\n              objects: transaction.objects.map((arg) => parseV1TransactionArgument(arg)),\n              address: parseV1TransactionArgument(transaction.address)\n            }\n          };\n        }\n        case \"Upgrade\": {\n          return {\n            Upgrade: {\n              modules: transaction.modules.map((mod) => toBase64(Uint8Array.from(mod))),\n              dependencies: transaction.dependencies,\n              package: transaction.packageId,\n              ticket: parseV1TransactionArgument(transaction.ticket)\n            }\n          };\n        }\n      }\n      throw new Error(`Unknown transaction ${Object.keys(transaction)}`);\n    })\n  });\n}\nfunction parseV1TransactionArgument(arg) {\n  switch (arg.kind) {\n    case \"GasCoin\": {\n      return { GasCoin: true };\n    }\n    case \"Result\":\n      return { Result: arg.index };\n    case \"NestedResult\": {\n      return { NestedResult: [arg.index, arg.resultIndex] };\n    }\n    case \"Input\": {\n      return { Input: arg.index };\n    }\n  }\n}\nexport {\n  NormalizedCallArg,\n  ObjectRef,\n  SerializedTransactionDataV1,\n  StructTag,\n  TransactionArgument,\n  TypeTag,\n  serializeV1TransactionData,\n  transactionDataFromV1\n};\n//# sourceMappingURL=v1.js.map\n","import {\n  array,\n  boolean,\n  integer,\n  literal,\n  nullable,\n  nullish,\n  number,\n  object,\n  optional,\n  pipe,\n  record,\n  string,\n  tuple,\n  union,\n  unknown\n} from \"valibot\";\nimport { BCSBytes, JsonU64, ObjectID, ObjectRefSchema, SuiAddress } from \"./internal.js\";\nfunction enumUnion(options) {\n  return union(\n    Object.entries(options).map(([key, value]) => object({ [key]: value }))\n  );\n}\nconst Argument = enumUnion({\n  GasCoin: literal(true),\n  Input: pipe(number(), integer()),\n  Result: pipe(number(), integer()),\n  NestedResult: tuple([pipe(number(), integer()), pipe(number(), integer())])\n});\nconst GasData = object({\n  budget: nullable(JsonU64),\n  price: nullable(JsonU64),\n  owner: nullable(SuiAddress),\n  payment: nullable(array(ObjectRefSchema))\n});\nconst ProgrammableMoveCall = object({\n  package: ObjectID,\n  module: string(),\n  function: string(),\n  // snake case in rust\n  typeArguments: array(string()),\n  arguments: array(Argument)\n});\nconst $Intent = object({\n  name: string(),\n  inputs: record(string(), union([Argument, array(Argument)])),\n  data: record(string(), unknown())\n});\nconst Command = enumUnion({\n  MoveCall: ProgrammableMoveCall,\n  TransferObjects: object({\n    objects: array(Argument),\n    address: Argument\n  }),\n  SplitCoins: object({\n    coin: Argument,\n    amounts: array(Argument)\n  }),\n  MergeCoins: object({\n    destination: Argument,\n    sources: array(Argument)\n  }),\n  Publish: object({\n    modules: array(BCSBytes),\n    dependencies: array(ObjectID)\n  }),\n  MakeMoveVec: object({\n    type: nullable(string()),\n    elements: array(Argument)\n  }),\n  Upgrade: object({\n    modules: array(BCSBytes),\n    dependencies: array(ObjectID),\n    package: ObjectID,\n    ticket: Argument\n  }),\n  $Intent\n});\nconst ObjectArg = enumUnion({\n  ImmOrOwnedObject: ObjectRefSchema,\n  SharedObject: object({\n    objectId: ObjectID,\n    // snake case in rust\n    initialSharedVersion: JsonU64,\n    mutable: boolean()\n  }),\n  Receiving: ObjectRefSchema\n});\nconst CallArg = enumUnion({\n  Object: ObjectArg,\n  Pure: object({\n    bytes: BCSBytes\n  }),\n  UnresolvedPure: object({\n    value: unknown()\n  }),\n  UnresolvedObject: object({\n    objectId: ObjectID,\n    version: optional(nullable(JsonU64)),\n    digest: optional(nullable(string())),\n    initialSharedVersion: optional(nullable(JsonU64)),\n    mutable: optional(nullable(boolean()))\n  })\n});\nconst TransactionExpiration = enumUnion({\n  None: literal(true),\n  Epoch: JsonU64\n});\nconst SerializedTransactionDataV2Schema = object({\n  version: literal(2),\n  sender: nullish(SuiAddress),\n  expiration: nullish(TransactionExpiration),\n  gasData: GasData,\n  inputs: array(CallArg),\n  commands: array(Command),\n  digest: optional(nullable(string()))\n});\nexport {\n  SerializedTransactionDataV2Schema\n};\n//# sourceMappingURL=v2.js.map\n","import { parse } from \"valibot\";\nimport { normalizeSuiAddress, normalizeSuiObjectId, SUI_TYPE_ARG } from \"../utils/index.js\";\nimport { ObjectRefSchema } from \"../transactions/data/internal.js\";\nimport { Inputs } from \"../transactions/Inputs.js\";\nimport {\n  getPureBcsSchema,\n  isTxContext,\n  normalizedTypeToMoveTypeSignature\n} from \"../transactions/serializer.js\";\nimport { chunk } from \"@mysten/utils\";\nconst MAX_OBJECTS_PER_FETCH = 50;\nconst GAS_SAFE_OVERHEAD = 1000n;\nconst MAX_GAS = 5e10;\nfunction jsonRpcClientResolveTransactionPlugin(client) {\n  return async function resolveTransactionData(transactionData, options, next) {\n    await normalizeInputs(transactionData, client);\n    await resolveObjectReferences(transactionData, client);\n    if (!options.onlyTransactionKind) {\n      await setGasPrice(transactionData, client);\n      await setGasBudget(transactionData, client);\n      await setGasPayment(transactionData, client);\n    }\n    return await next();\n  };\n}\nasync function setGasPrice(transactionData, client) {\n  if (!transactionData.gasConfig.price) {\n    transactionData.gasConfig.price = String(await client.getReferenceGasPrice());\n  }\n}\nasync function setGasBudget(transactionData, client) {\n  if (transactionData.gasConfig.budget) {\n    return;\n  }\n  const dryRunResult = await client.dryRunTransactionBlock({\n    transactionBlock: transactionData.build({\n      overrides: {\n        gasData: {\n          budget: String(MAX_GAS),\n          payment: []\n        }\n      }\n    })\n  });\n  if (dryRunResult.effects.status.status !== \"success\") {\n    throw new Error(\n      `Dry run failed, could not automatically determine a budget: ${dryRunResult.effects.status.error}`,\n      { cause: dryRunResult }\n    );\n  }\n  const safeOverhead = GAS_SAFE_OVERHEAD * BigInt(transactionData.gasConfig.price || 1n);\n  const baseComputationCostWithOverhead = BigInt(dryRunResult.effects.gasUsed.computationCost) + safeOverhead;\n  const gasBudget = baseComputationCostWithOverhead + BigInt(dryRunResult.effects.gasUsed.storageCost) - BigInt(dryRunResult.effects.gasUsed.storageRebate);\n  transactionData.gasConfig.budget = String(\n    gasBudget > baseComputationCostWithOverhead ? gasBudget : baseComputationCostWithOverhead\n  );\n}\nasync function setGasPayment(transactionData, client) {\n  if (!transactionData.gasConfig.payment) {\n    const coins = await client.getCoins({\n      owner: transactionData.gasConfig.owner || transactionData.sender,\n      coinType: SUI_TYPE_ARG\n    });\n    const paymentCoins = coins.data.filter((coin) => {\n      const matchingInput = transactionData.inputs.find((input) => {\n        if (input.Object?.ImmOrOwnedObject) {\n          return coin.coinObjectId === input.Object.ImmOrOwnedObject.objectId;\n        }\n        return false;\n      });\n      return !matchingInput;\n    }).map((coin) => ({\n      objectId: coin.coinObjectId,\n      digest: coin.digest,\n      version: coin.version\n    }));\n    if (!paymentCoins.length) {\n      throw new Error(\"No valid gas coins found for the transaction.\");\n    }\n    transactionData.gasConfig.payment = paymentCoins.map(\n      (payment) => parse(ObjectRefSchema, payment)\n    );\n  }\n}\nasync function resolveObjectReferences(transactionData, client) {\n  const objectsToResolve = transactionData.inputs.filter((input) => {\n    return input.UnresolvedObject && !(input.UnresolvedObject.version || input.UnresolvedObject?.initialSharedVersion);\n  });\n  const dedupedIds = [\n    ...new Set(\n      objectsToResolve.map((input) => normalizeSuiObjectId(input.UnresolvedObject.objectId))\n    )\n  ];\n  const objectChunks = dedupedIds.length ? chunk(dedupedIds, MAX_OBJECTS_PER_FETCH) : [];\n  const resolved = (await Promise.all(\n    objectChunks.map(\n      (chunk2) => client.multiGetObjects({\n        ids: chunk2,\n        options: { showOwner: true }\n      })\n    )\n  )).flat();\n  const responsesById = new Map(\n    dedupedIds.map((id, index) => {\n      return [id, resolved[index]];\n    })\n  );\n  const invalidObjects = Array.from(responsesById).filter(([_, obj]) => obj.error).map(([_, obj]) => JSON.stringify(obj.error));\n  if (invalidObjects.length) {\n    throw new Error(`The following input objects are invalid: ${invalidObjects.join(\", \")}`);\n  }\n  const objects = resolved.map((object) => {\n    if (object.error || !object.data) {\n      throw new Error(`Failed to fetch object: ${object.error}`);\n    }\n    const owner = object.data.owner;\n    const initialSharedVersion = owner && typeof owner === \"object\" ? \"Shared\" in owner ? owner.Shared.initial_shared_version : \"ConsensusAddressOwner\" in owner ? owner.ConsensusAddressOwner.start_version : null : null;\n    return {\n      objectId: object.data.objectId,\n      digest: object.data.digest,\n      version: object.data.version,\n      initialSharedVersion\n    };\n  });\n  const objectsById = new Map(\n    dedupedIds.map((id, index) => {\n      return [id, objects[index]];\n    })\n  );\n  for (const [index, input] of transactionData.inputs.entries()) {\n    if (!input.UnresolvedObject) {\n      continue;\n    }\n    let updated;\n    const id = normalizeSuiAddress(input.UnresolvedObject.objectId);\n    const object = objectsById.get(id);\n    if (input.UnresolvedObject.initialSharedVersion ?? object?.initialSharedVersion) {\n      updated = Inputs.SharedObjectRef({\n        objectId: id,\n        initialSharedVersion: input.UnresolvedObject.initialSharedVersion || object?.initialSharedVersion,\n        mutable: input.UnresolvedObject.mutable || isUsedAsMutable(transactionData, index)\n      });\n    } else if (isUsedAsReceiving(transactionData, index)) {\n      updated = Inputs.ReceivingRef(\n        {\n          objectId: id,\n          digest: input.UnresolvedObject.digest ?? object?.digest,\n          version: input.UnresolvedObject.version ?? object?.version\n        }\n      );\n    }\n    transactionData.inputs[transactionData.inputs.indexOf(input)] = updated ?? Inputs.ObjectRef({\n      objectId: id,\n      digest: input.UnresolvedObject.digest ?? object?.digest,\n      version: input.UnresolvedObject.version ?? object?.version\n    });\n  }\n}\nasync function normalizeInputs(transactionData, client) {\n  const { inputs, commands } = transactionData;\n  const moveCallsToResolve = [];\n  const moveFunctionsToResolve = /* @__PURE__ */ new Set();\n  commands.forEach((command) => {\n    if (command.MoveCall) {\n      if (command.MoveCall._argumentTypes) {\n        return;\n      }\n      const inputs2 = command.MoveCall.arguments.map((arg) => {\n        if (arg.$kind === \"Input\") {\n          return transactionData.inputs[arg.Input];\n        }\n        return null;\n      });\n      const needsResolution = inputs2.some(\n        (input) => input?.UnresolvedPure || input?.UnresolvedObject && typeof input?.UnresolvedObject.mutable !== \"boolean\"\n      );\n      if (needsResolution) {\n        const functionName = `${command.MoveCall.package}::${command.MoveCall.module}::${command.MoveCall.function}`;\n        moveFunctionsToResolve.add(functionName);\n        moveCallsToResolve.push(command.MoveCall);\n      }\n    }\n  });\n  const moveFunctionParameters = /* @__PURE__ */ new Map();\n  if (moveFunctionsToResolve.size > 0) {\n    await Promise.all(\n      [...moveFunctionsToResolve].map(async (functionName) => {\n        const [packageId, moduleId, functionId] = functionName.split(\"::\");\n        const def = await client.getNormalizedMoveFunction({\n          package: packageId,\n          module: moduleId,\n          function: functionId\n        });\n        moveFunctionParameters.set(\n          functionName,\n          def.parameters.map((param) => normalizedTypeToMoveTypeSignature(param))\n        );\n      })\n    );\n  }\n  if (moveCallsToResolve.length) {\n    await Promise.all(\n      moveCallsToResolve.map(async (moveCall) => {\n        const parameters = moveFunctionParameters.get(\n          `${moveCall.package}::${moveCall.module}::${moveCall.function}`\n        );\n        if (!parameters) {\n          return;\n        }\n        const hasTxContext = parameters.length > 0 && isTxContext(parameters.at(-1));\n        const params = hasTxContext ? parameters.slice(0, parameters.length - 1) : parameters;\n        moveCall._argumentTypes = params;\n      })\n    );\n  }\n  commands.forEach((command) => {\n    if (!command.MoveCall) {\n      return;\n    }\n    const moveCall = command.MoveCall;\n    const fnName = `${moveCall.package}::${moveCall.module}::${moveCall.function}`;\n    const params = moveCall._argumentTypes;\n    if (!params) {\n      return;\n    }\n    if (params.length !== command.MoveCall.arguments.length) {\n      throw new Error(`Incorrect number of arguments for ${fnName}`);\n    }\n    params.forEach((param, i) => {\n      const arg = moveCall.arguments[i];\n      if (arg.$kind !== \"Input\") return;\n      const input = inputs[arg.Input];\n      if (!input.UnresolvedPure && !input.UnresolvedObject) {\n        return;\n      }\n      const inputValue = input.UnresolvedPure?.value ?? input.UnresolvedObject?.objectId;\n      const schema = getPureBcsSchema(param.body);\n      if (schema) {\n        arg.type = \"pure\";\n        inputs[inputs.indexOf(input)] = Inputs.Pure(schema.serialize(inputValue));\n        return;\n      }\n      if (typeof inputValue !== \"string\") {\n        throw new Error(\n          `Expect the argument to be an object id string, got ${JSON.stringify(\n            inputValue,\n            null,\n            2\n          )}`\n        );\n      }\n      arg.type = \"object\";\n      const unresolvedObject = input.UnresolvedPure ? {\n        $kind: \"UnresolvedObject\",\n        UnresolvedObject: {\n          objectId: inputValue\n        }\n      } : input;\n      inputs[arg.Input] = unresolvedObject;\n    });\n  });\n}\nfunction isUsedAsMutable(transactionData, index) {\n  let usedAsMutable = false;\n  transactionData.getInputUses(index, (arg, tx) => {\n    if (tx.MoveCall && tx.MoveCall._argumentTypes) {\n      const argIndex = tx.MoveCall.arguments.indexOf(arg);\n      usedAsMutable = tx.MoveCall._argumentTypes[argIndex].ref !== \"&\" || usedAsMutable;\n    }\n    if (tx.$kind === \"MakeMoveVec\" || tx.$kind === \"MergeCoins\" || tx.$kind === \"SplitCoins\" || tx.$kind === \"TransferObjects\") {\n      usedAsMutable = true;\n    }\n  });\n  return usedAsMutable;\n}\nfunction isUsedAsReceiving(transactionData, index) {\n  let usedAsReceiving = false;\n  transactionData.getInputUses(index, (arg, tx) => {\n    if (tx.MoveCall && tx.MoveCall._argumentTypes) {\n      const argIndex = tx.MoveCall.arguments.indexOf(arg);\n      usedAsReceiving = isReceivingType(tx.MoveCall._argumentTypes[argIndex]) || usedAsReceiving;\n    }\n  });\n  return usedAsReceiving;\n}\nfunction isReceivingType(type) {\n  if (typeof type.body !== \"object\" || !(\"datatype\" in type.body)) {\n    return false;\n  }\n  return type.body.datatype.package === \"0x2\" && type.body.datatype.module === \"transfer\" && type.body.datatype.type === \"Receiving\";\n}\nexport {\n  jsonRpcClientResolveTransactionPlugin\n};\n//# sourceMappingURL=json-rpc-resolver.js.map\n","import { Inputs } from \"./Inputs.js\";\nimport { bcs } from \"../bcs/index.js\";\nimport { jsonRpcClientResolveTransactionPlugin } from \"../jsonRpc/json-rpc-resolver.js\";\nfunction needsTransactionResolution(data, options) {\n  if (data.inputs.some((input) => {\n    return input.UnresolvedObject || input.UnresolvedPure;\n  })) {\n    return true;\n  }\n  if (!options.onlyTransactionKind) {\n    if (!data.gasConfig.price || !data.gasConfig.budget || !data.gasConfig.payment) {\n      return true;\n    }\n  }\n  return false;\n}\nasync function resolveTransactionPlugin(transactionData, options, next) {\n  normalizeRawArguments(transactionData);\n  if (!needsTransactionResolution(transactionData, options)) {\n    await validate(transactionData);\n    return next();\n  }\n  const client = getClient(options);\n  const plugin = client.core?.resolveTransactionPlugin() ?? jsonRpcClientResolveTransactionPlugin(client);\n  return plugin(transactionData, options, async () => {\n    await validate(transactionData);\n    await next();\n  });\n}\nfunction validate(transactionData) {\n  transactionData.inputs.forEach((input, index) => {\n    if (input.$kind !== \"Object\" && input.$kind !== \"Pure\") {\n      throw new Error(\n        `Input at index ${index} has not been resolved.  Expected a Pure or Object input, but found ${JSON.stringify(\n          input\n        )}`\n      );\n    }\n  });\n}\nfunction getClient(options) {\n  if (!options.client) {\n    throw new Error(\n      `No sui client passed to Transaction#build, but transaction data was not sufficient to build offline.`\n    );\n  }\n  return options.client;\n}\nfunction normalizeRawArguments(transactionData) {\n  for (const command of transactionData.commands) {\n    switch (command.$kind) {\n      case \"SplitCoins\":\n        command.SplitCoins.amounts.forEach((amount) => {\n          normalizeRawArgument(amount, bcs.U64, transactionData);\n        });\n        break;\n      case \"TransferObjects\":\n        normalizeRawArgument(command.TransferObjects.address, bcs.Address, transactionData);\n        break;\n    }\n  }\n}\nfunction normalizeRawArgument(arg, schema, transactionData) {\n  if (arg.$kind !== \"Input\") {\n    return;\n  }\n  const input = transactionData.inputs[arg.Input];\n  if (input.$kind !== \"UnresolvedPure\") {\n    return;\n  }\n  transactionData.inputs[arg.Input] = Inputs.Pure(schema.serialize(input.UnresolvedPure.value));\n}\nexport {\n  getClient,\n  needsTransactionResolution,\n  resolveTransactionPlugin\n};\n//# sourceMappingURL=resolve.js.map\n","import { Inputs } from \"./Inputs.js\";\nfunction createObjectMethods(makeObject) {\n  function object(value) {\n    return makeObject(value);\n  }\n  object.system = (options) => {\n    const mutable = options?.mutable;\n    if (mutable !== void 0) {\n      return object(\n        Inputs.SharedObjectRef({\n          objectId: \"0x5\",\n          initialSharedVersion: 1,\n          mutable\n        })\n      );\n    }\n    return object({\n      $kind: \"UnresolvedObject\",\n      UnresolvedObject: {\n        objectId: \"0x5\",\n        initialSharedVersion: 1\n      }\n    });\n  };\n  object.clock = () => object(\n    Inputs.SharedObjectRef({\n      objectId: \"0x6\",\n      initialSharedVersion: 1,\n      mutable: false\n    })\n  );\n  object.random = () => object({\n    $kind: \"UnresolvedObject\",\n    UnresolvedObject: {\n      objectId: \"0x8\",\n      mutable: false\n    }\n  });\n  object.denyList = (options) => {\n    return object({\n      $kind: \"UnresolvedObject\",\n      UnresolvedObject: {\n        objectId: \"0x403\",\n        mutable: options?.mutable\n      }\n    });\n  };\n  object.option = ({ type, value }) => (tx) => tx.moveCall({\n    typeArguments: [type],\n    target: `0x1::option::${value === null ? \"none\" : \"some\"}`,\n    arguments: value === null ? [] : [tx.object(value)]\n  });\n  return object;\n}\nexport {\n  createObjectMethods\n};\n//# sourceMappingURL=object.js.map\n","import { isSerializedBcs } from \"@mysten/bcs\";\nimport { bcs } from \"../bcs/index.js\";\nimport { pureBcsSchemaFromTypeName } from \"../bcs/pure.js\";\nfunction createPure(makePure) {\n  function pure(typeOrSerializedValue, value) {\n    if (typeof typeOrSerializedValue === \"string\") {\n      return makePure(pureBcsSchemaFromTypeName(typeOrSerializedValue).serialize(value));\n    }\n    if (typeOrSerializedValue instanceof Uint8Array || isSerializedBcs(typeOrSerializedValue)) {\n      return makePure(typeOrSerializedValue);\n    }\n    throw new Error(\"tx.pure must be called either a bcs type name, or a serialized bcs value\");\n  }\n  pure.u8 = (value) => makePure(bcs.U8.serialize(value));\n  pure.u16 = (value) => makePure(bcs.U16.serialize(value));\n  pure.u32 = (value) => makePure(bcs.U32.serialize(value));\n  pure.u64 = (value) => makePure(bcs.U64.serialize(value));\n  pure.u128 = (value) => makePure(bcs.U128.serialize(value));\n  pure.u256 = (value) => makePure(bcs.U256.serialize(value));\n  pure.bool = (value) => makePure(bcs.Bool.serialize(value));\n  pure.string = (value) => makePure(bcs.String.serialize(value));\n  pure.address = (value) => makePure(bcs.Address.serialize(value));\n  pure.id = pure.address;\n  pure.vector = (type, value) => {\n    return makePure(\n      bcs.vector(pureBcsSchemaFromTypeName(type)).serialize(value)\n    );\n  };\n  pure.option = (type, value) => {\n    return makePure(bcs.option(pureBcsSchemaFromTypeName(type)).serialize(value));\n  };\n  return pure;\n}\nexport {\n  createPure\n};\n//# sourceMappingURL=pure.js.map\n","import { blake2b } from \"@noble/hashes/blake2b\";\nfunction hashTypedData(typeTag, data) {\n  const typeTagBytes = Array.from(`${typeTag}::`).map((e) => e.charCodeAt(0));\n  const dataWithTag = new Uint8Array(typeTagBytes.length + data.length);\n  dataWithTag.set(typeTagBytes);\n  dataWithTag.set(data, typeTagBytes.length);\n  return blake2b(dataWithTag, { dkLen: 32 });\n}\nexport {\n  hashTypedData\n};\n//# sourceMappingURL=hash.js.map\n","import { is } from \"valibot\";\nimport { normalizeSuiAddress } from \"../utils/sui-types.js\";\nimport { ArgumentSchema } from \"./data/internal.js\";\nfunction extractMutableReference(normalizedType) {\n  return typeof normalizedType === \"object\" && \"MutableReference\" in normalizedType ? normalizedType.MutableReference : void 0;\n}\nfunction extractReference(normalizedType) {\n  return typeof normalizedType === \"object\" && \"Reference\" in normalizedType ? normalizedType.Reference : void 0;\n}\nfunction extractStructTag(normalizedType) {\n  if (typeof normalizedType === \"object\" && \"Struct\" in normalizedType) {\n    return normalizedType;\n  }\n  const ref = extractReference(normalizedType);\n  const mutRef = extractMutableReference(normalizedType);\n  if (typeof ref === \"object\" && \"Struct\" in ref) {\n    return ref;\n  }\n  if (typeof mutRef === \"object\" && \"Struct\" in mutRef) {\n    return mutRef;\n  }\n  return void 0;\n}\nfunction getIdFromCallArg(arg) {\n  if (typeof arg === \"string\") {\n    return normalizeSuiAddress(arg);\n  }\n  if (arg.Object) {\n    if (arg.Object.ImmOrOwnedObject) {\n      return normalizeSuiAddress(arg.Object.ImmOrOwnedObject.objectId);\n    }\n    if (arg.Object.Receiving) {\n      return normalizeSuiAddress(arg.Object.Receiving.objectId);\n    }\n    return normalizeSuiAddress(arg.Object.SharedObject.objectId);\n  }\n  if (arg.UnresolvedObject) {\n    return normalizeSuiAddress(arg.UnresolvedObject.objectId);\n  }\n  return void 0;\n}\nfunction isArgument(value) {\n  return is(ArgumentSchema, value);\n}\nfunction remapCommandArguments(command, inputMapping, commandMapping) {\n  const remapArg = (arg) => {\n    switch (arg.$kind) {\n      case \"Input\": {\n        const newInputIndex = inputMapping.get(arg.Input);\n        if (newInputIndex === void 0) {\n          throw new Error(`Input ${arg.Input} not found in input mapping`);\n        }\n        return { ...arg, Input: newInputIndex };\n      }\n      case \"Result\": {\n        const newCommandIndex = commandMapping.get(arg.Result);\n        if (newCommandIndex !== void 0) {\n          return { ...arg, Result: newCommandIndex };\n        }\n        return arg;\n      }\n      case \"NestedResult\": {\n        const newCommandIndex = commandMapping.get(arg.NestedResult[0]);\n        if (newCommandIndex !== void 0) {\n          return { ...arg, NestedResult: [newCommandIndex, arg.NestedResult[1]] };\n        }\n        return arg;\n      }\n      default:\n        return arg;\n    }\n  };\n  switch (command.$kind) {\n    case \"MoveCall\":\n      command.MoveCall.arguments = command.MoveCall.arguments.map(remapArg);\n      break;\n    case \"TransferObjects\":\n      command.TransferObjects.objects = command.TransferObjects.objects.map(remapArg);\n      command.TransferObjects.address = remapArg(command.TransferObjects.address);\n      break;\n    case \"SplitCoins\":\n      command.SplitCoins.coin = remapArg(command.SplitCoins.coin);\n      command.SplitCoins.amounts = command.SplitCoins.amounts.map(remapArg);\n      break;\n    case \"MergeCoins\":\n      command.MergeCoins.destination = remapArg(command.MergeCoins.destination);\n      command.MergeCoins.sources = command.MergeCoins.sources.map(remapArg);\n      break;\n    case \"MakeMoveVec\":\n      command.MakeMoveVec.elements = command.MakeMoveVec.elements.map(remapArg);\n      break;\n    case \"Upgrade\":\n      command.Upgrade.ticket = remapArg(command.Upgrade.ticket);\n      break;\n    case \"$Intent\": {\n      const inputs = command.$Intent.inputs;\n      command.$Intent.inputs = {};\n      for (const [key, value] of Object.entries(inputs)) {\n        command.$Intent.inputs[key] = Array.isArray(value) ? value.map(remapArg) : remapArg(value);\n      }\n      break;\n    }\n    case \"Publish\":\n      break;\n  }\n}\nexport {\n  extractMutableReference,\n  extractReference,\n  extractStructTag,\n  getIdFromCallArg,\n  isArgument,\n  remapCommandArguments\n};\n//# sourceMappingURL=utils.js.map\n","import { toBase58 } from \"@mysten/bcs\";\nimport { parse } from \"valibot\";\nimport { bcs } from \"../bcs/index.js\";\nimport { normalizeSuiAddress } from \"../utils/sui-types.js\";\nimport { ArgumentSchema, TransactionDataSchema } from \"./data/internal.js\";\nimport { transactionDataFromV1 } from \"./data/v1.js\";\nimport { hashTypedData } from \"./hash.js\";\nimport { getIdFromCallArg, remapCommandArguments } from \"./utils.js\";\nfunction prepareSuiAddress(address) {\n  return normalizeSuiAddress(address).replace(\"0x\", \"\");\n}\nclass TransactionDataBuilder {\n  constructor(clone) {\n    this.version = 2;\n    this.sender = clone?.sender ?? null;\n    this.expiration = clone?.expiration ?? null;\n    this.inputs = clone?.inputs ?? [];\n    this.commands = clone?.commands ?? [];\n    this.gasData = clone?.gasData ?? {\n      budget: null,\n      price: null,\n      owner: null,\n      payment: null\n    };\n  }\n  static fromKindBytes(bytes) {\n    const kind = bcs.TransactionKind.parse(bytes);\n    const programmableTx = kind.ProgrammableTransaction;\n    if (!programmableTx) {\n      throw new Error(\"Unable to deserialize from bytes.\");\n    }\n    return TransactionDataBuilder.restore({\n      version: 2,\n      sender: null,\n      expiration: null,\n      gasData: {\n        budget: null,\n        owner: null,\n        payment: null,\n        price: null\n      },\n      inputs: programmableTx.inputs,\n      commands: programmableTx.commands\n    });\n  }\n  static fromBytes(bytes) {\n    const rawData = bcs.TransactionData.parse(bytes);\n    const data = rawData?.V1;\n    const programmableTx = data.kind.ProgrammableTransaction;\n    if (!data || !programmableTx) {\n      throw new Error(\"Unable to deserialize from bytes.\");\n    }\n    return TransactionDataBuilder.restore({\n      version: 2,\n      sender: data.sender,\n      expiration: data.expiration,\n      gasData: data.gasData,\n      inputs: programmableTx.inputs,\n      commands: programmableTx.commands\n    });\n  }\n  static restore(data) {\n    if (data.version === 2) {\n      return new TransactionDataBuilder(parse(TransactionDataSchema, data));\n    } else {\n      return new TransactionDataBuilder(parse(TransactionDataSchema, transactionDataFromV1(data)));\n    }\n  }\n  /**\n   * Generate transaction digest.\n   *\n   * @param bytes BCS serialized transaction data\n   * @returns transaction digest.\n   */\n  static getDigestFromBytes(bytes) {\n    const hash = hashTypedData(\"TransactionData\", bytes);\n    return toBase58(hash);\n  }\n  // @deprecated use gasData instead\n  get gasConfig() {\n    return this.gasData;\n  }\n  // @deprecated use gasData instead\n  set gasConfig(value) {\n    this.gasData = value;\n  }\n  build({\n    maxSizeBytes = Infinity,\n    overrides,\n    onlyTransactionKind\n  } = {}) {\n    const inputs = this.inputs;\n    const commands = this.commands;\n    const kind = {\n      ProgrammableTransaction: {\n        inputs,\n        commands\n      }\n    };\n    if (onlyTransactionKind) {\n      return bcs.TransactionKind.serialize(kind, { maxSize: maxSizeBytes }).toBytes();\n    }\n    const expiration = overrides?.expiration ?? this.expiration;\n    const sender = overrides?.sender ?? this.sender;\n    const gasData = { ...this.gasData, ...overrides?.gasConfig, ...overrides?.gasData };\n    if (!sender) {\n      throw new Error(\"Missing transaction sender\");\n    }\n    if (!gasData.budget) {\n      throw new Error(\"Missing gas budget\");\n    }\n    if (!gasData.payment) {\n      throw new Error(\"Missing gas payment\");\n    }\n    if (!gasData.price) {\n      throw new Error(\"Missing gas price\");\n    }\n    const transactionData = {\n      sender: prepareSuiAddress(sender),\n      expiration: expiration ? expiration : { None: true },\n      gasData: {\n        payment: gasData.payment,\n        owner: prepareSuiAddress(this.gasData.owner ?? sender),\n        price: BigInt(gasData.price),\n        budget: BigInt(gasData.budget)\n      },\n      kind: {\n        ProgrammableTransaction: {\n          inputs,\n          commands\n        }\n      }\n    };\n    return bcs.TransactionData.serialize(\n      { V1: transactionData },\n      { maxSize: maxSizeBytes }\n    ).toBytes();\n  }\n  addInput(type, arg) {\n    const index = this.inputs.length;\n    this.inputs.push(arg);\n    return { Input: index, type, $kind: \"Input\" };\n  }\n  getInputUses(index, fn) {\n    this.mapArguments((arg, command) => {\n      if (arg.$kind === \"Input\" && arg.Input === index) {\n        fn(arg, command);\n      }\n      return arg;\n    });\n  }\n  mapCommandArguments(index, fn) {\n    const command = this.commands[index];\n    switch (command.$kind) {\n      case \"MoveCall\":\n        command.MoveCall.arguments = command.MoveCall.arguments.map(\n          (arg) => fn(arg, command, index)\n        );\n        break;\n      case \"TransferObjects\":\n        command.TransferObjects.objects = command.TransferObjects.objects.map(\n          (arg) => fn(arg, command, index)\n        );\n        command.TransferObjects.address = fn(command.TransferObjects.address, command, index);\n        break;\n      case \"SplitCoins\":\n        command.SplitCoins.coin = fn(command.SplitCoins.coin, command, index);\n        command.SplitCoins.amounts = command.SplitCoins.amounts.map(\n          (arg) => fn(arg, command, index)\n        );\n        break;\n      case \"MergeCoins\":\n        command.MergeCoins.destination = fn(command.MergeCoins.destination, command, index);\n        command.MergeCoins.sources = command.MergeCoins.sources.map(\n          (arg) => fn(arg, command, index)\n        );\n        break;\n      case \"MakeMoveVec\":\n        command.MakeMoveVec.elements = command.MakeMoveVec.elements.map(\n          (arg) => fn(arg, command, index)\n        );\n        break;\n      case \"Upgrade\":\n        command.Upgrade.ticket = fn(command.Upgrade.ticket, command, index);\n        break;\n      case \"$Intent\":\n        const inputs = command.$Intent.inputs;\n        command.$Intent.inputs = {};\n        for (const [key, value] of Object.entries(inputs)) {\n          command.$Intent.inputs[key] = Array.isArray(value) ? value.map((arg) => fn(arg, command, index)) : fn(value, command, index);\n        }\n        break;\n      case \"Publish\":\n        break;\n      default:\n        throw new Error(`Unexpected transaction kind: ${command.$kind}`);\n    }\n  }\n  mapArguments(fn) {\n    for (const commandIndex of this.commands.keys()) {\n      this.mapCommandArguments(commandIndex, fn);\n    }\n  }\n  replaceCommand(index, replacement, resultIndex = index) {\n    if (!Array.isArray(replacement)) {\n      this.commands[index] = replacement;\n      return;\n    }\n    const sizeDiff = replacement.length - 1;\n    this.commands.splice(index, 1, ...structuredClone(replacement));\n    this.mapArguments((arg, _command, commandIndex) => {\n      if (commandIndex < index + replacement.length) {\n        return arg;\n      }\n      if (typeof resultIndex !== \"number\") {\n        if (arg.$kind === \"Result\" && arg.Result === index || arg.$kind === \"NestedResult\" && arg.NestedResult[0] === index) {\n          if (!(\"NestedResult\" in arg) || arg.NestedResult[1] === 0) {\n            return parse(ArgumentSchema, structuredClone(resultIndex));\n          } else {\n            throw new Error(\n              `Cannot replace command ${index} with a specific result type: NestedResult[${index}, ${arg.NestedResult[1]}] references a nested element that cannot be mapped to the replacement result`\n            );\n          }\n        }\n      }\n      switch (arg.$kind) {\n        case \"Result\":\n          if (arg.Result === index && typeof resultIndex === \"number\") {\n            arg.Result = resultIndex;\n          }\n          if (arg.Result > index) {\n            arg.Result += sizeDiff;\n          }\n          break;\n        case \"NestedResult\":\n          if (arg.NestedResult[0] === index && typeof resultIndex === \"number\") {\n            return {\n              $kind: \"NestedResult\",\n              NestedResult: [resultIndex, arg.NestedResult[1]]\n            };\n          }\n          if (arg.NestedResult[0] > index) {\n            arg.NestedResult[0] += sizeDiff;\n          }\n          break;\n      }\n      return arg;\n    });\n  }\n  replaceCommandWithTransaction(index, otherTransaction, result) {\n    if (result.$kind !== \"Result\" && result.$kind !== \"NestedResult\") {\n      throw new Error(\"Result must be of kind Result or NestedResult\");\n    }\n    this.insertTransaction(index, otherTransaction);\n    this.replaceCommand(\n      index + otherTransaction.commands.length,\n      [],\n      \"Result\" in result ? { NestedResult: [result.Result + index, 0] } : {\n        NestedResult: [\n          result.NestedResult[0] + index,\n          result.NestedResult[1]\n        ]\n      }\n    );\n  }\n  insertTransaction(atCommandIndex, otherTransaction) {\n    const inputMapping = /* @__PURE__ */ new Map();\n    const commandMapping = /* @__PURE__ */ new Map();\n    for (let i = 0; i < otherTransaction.inputs.length; i++) {\n      const otherInput = otherTransaction.inputs[i];\n      const id = getIdFromCallArg(otherInput);\n      let existingIndex = -1;\n      if (id !== void 0) {\n        existingIndex = this.inputs.findIndex((input) => getIdFromCallArg(input) === id);\n        if (existingIndex !== -1 && this.inputs[existingIndex].Object?.SharedObject && otherInput.Object?.SharedObject) {\n          this.inputs[existingIndex].Object.SharedObject.mutable = this.inputs[existingIndex].Object.SharedObject.mutable || otherInput.Object.SharedObject.mutable;\n        }\n      }\n      if (existingIndex !== -1) {\n        inputMapping.set(i, existingIndex);\n      } else {\n        const newIndex = this.inputs.length;\n        this.inputs.push(otherInput);\n        inputMapping.set(i, newIndex);\n      }\n    }\n    for (let i = 0; i < otherTransaction.commands.length; i++) {\n      commandMapping.set(i, atCommandIndex + i);\n    }\n    const remappedCommands = [];\n    for (let i = 0; i < otherTransaction.commands.length; i++) {\n      const command = structuredClone(otherTransaction.commands[i]);\n      remapCommandArguments(command, inputMapping, commandMapping);\n      remappedCommands.push(command);\n    }\n    this.commands.splice(atCommandIndex, 0, ...remappedCommands);\n    const sizeDiff = remappedCommands.length;\n    if (sizeDiff > 0) {\n      this.mapArguments((arg, _command, commandIndex) => {\n        if (commandIndex >= atCommandIndex && commandIndex < atCommandIndex + remappedCommands.length) {\n          return arg;\n        }\n        switch (arg.$kind) {\n          case \"Result\":\n            if (arg.Result >= atCommandIndex) {\n              arg.Result += sizeDiff;\n            }\n            break;\n          case \"NestedResult\":\n            if (arg.NestedResult[0] >= atCommandIndex) {\n              arg.NestedResult[0] += sizeDiff;\n            }\n            break;\n        }\n        return arg;\n      });\n    }\n  }\n  getDigest() {\n    const bytes = this.build({ onlyTransactionKind: false });\n    return TransactionDataBuilder.getDigestFromBytes(bytes);\n  }\n  snapshot() {\n    return parse(TransactionDataSchema, this);\n  }\n  shallowClone() {\n    return new TransactionDataBuilder({\n      version: this.version,\n      sender: this.sender,\n      expiration: this.expiration,\n      gasData: {\n        ...this.gasData\n      },\n      inputs: [...this.inputs],\n      commands: [...this.commands]\n    });\n  }\n  applyResolvedData(resolved) {\n    if (!this.sender) {\n      this.sender = resolved.sender ?? null;\n    }\n    if (!this.expiration) {\n      this.expiration = resolved.expiration ?? null;\n    }\n    if (!this.gasData.budget) {\n      this.gasData.budget = resolved.gasData.budget;\n    }\n    if (!this.gasData.owner) {\n      this.gasData.owner = resolved.gasData.owner ?? null;\n    }\n    if (!this.gasData.payment) {\n      this.gasData.payment = resolved.gasData.payment;\n    }\n    if (!this.gasData.price) {\n      this.gasData.price = resolved.gasData.price;\n    }\n    for (let i = 0; i < this.inputs.length; i++) {\n      const input = this.inputs[i];\n      const resolvedInput = resolved.inputs[i];\n      switch (input.$kind) {\n        case \"UnresolvedPure\":\n          if (resolvedInput.$kind !== \"Pure\") {\n            throw new Error(\n              `Expected input at index ${i} to resolve to a Pure argument, but got ${JSON.stringify(\n                resolvedInput\n              )}`\n            );\n          }\n          this.inputs[i] = resolvedInput;\n          break;\n        case \"UnresolvedObject\":\n          if (resolvedInput.$kind !== \"Object\") {\n            throw new Error(\n              `Expected input at index ${i} to resolve to an Object argument, but got ${JSON.stringify(\n                resolvedInput\n              )}`\n            );\n          }\n          if (resolvedInput.Object.$kind === \"ImmOrOwnedObject\" || resolvedInput.Object.$kind === \"Receiving\") {\n            const original = input.UnresolvedObject;\n            const resolved2 = resolvedInput.Object.ImmOrOwnedObject ?? resolvedInput.Object.Receiving;\n            if (normalizeSuiAddress(original.objectId) !== normalizeSuiAddress(resolved2.objectId) || original.version != null && original.version !== resolved2.version || original.digest != null && original.digest !== resolved2.digest || // Objects with shared object properties should not resolve to owned objects\n            original.mutable != null || original.initialSharedVersion != null) {\n              throw new Error(\n                `Input at index ${i} did not match unresolved object. ${JSON.stringify(original)} is not compatible with ${JSON.stringify(resolved2)}`\n              );\n            }\n          } else if (resolvedInput.Object.$kind === \"SharedObject\") {\n            const original = input.UnresolvedObject;\n            const resolved2 = resolvedInput.Object.SharedObject;\n            if (normalizeSuiAddress(original.objectId) !== normalizeSuiAddress(resolved2.objectId) || original.initialSharedVersion != null && original.initialSharedVersion !== resolved2.initialSharedVersion || original.mutable != null && original.mutable !== resolved2.mutable || // Objects with owned object properties should not resolve to shared objects\n            original.version != null || original.digest != null) {\n              throw new Error(\n                `Input at index ${i} did not match unresolved object. ${JSON.stringify(original)} is not compatible with ${JSON.stringify(resolved2)}`\n              );\n            }\n          } else {\n            throw new Error(\n              `Input at index ${i} resolved to an unexpected Object kind: ${JSON.stringify(\n                resolvedInput.Object\n              )}`\n            );\n          }\n          this.inputs[i] = resolvedInput;\n          break;\n      }\n    }\n  }\n}\nexport {\n  TransactionDataBuilder\n};\n//# sourceMappingURL=TransactionData.js.map\n","var __typeError = (msg) => {\n  throw TypeError(msg);\n};\nvar __accessCheck = (obj, member, msg) => member.has(obj) || __typeError(\"Cannot \" + msg);\nvar __privateGet = (obj, member, getter) => (__accessCheck(obj, member, \"read from private field\"), getter ? getter.call(obj) : member.get(obj));\nvar __privateAdd = (obj, member, value) => member.has(obj) ? __typeError(\"Cannot add the same private member more than once\") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\nvar __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, \"write to private field\"), setter ? setter.call(obj, value) : member.set(obj, value), value);\nvar _prefix, _cache;\nconst _ClientCache = class _ClientCache {\n  constructor({ prefix, cache } = {}) {\n    __privateAdd(this, _prefix);\n    __privateAdd(this, _cache);\n    __privateSet(this, _prefix, prefix ?? []);\n    __privateSet(this, _cache, cache ?? /* @__PURE__ */ new Map());\n  }\n  read(key, load) {\n    const cacheKey = [__privateGet(this, _prefix), ...key].join(\":\");\n    if (__privateGet(this, _cache).has(cacheKey)) {\n      return __privateGet(this, _cache).get(cacheKey);\n    }\n    const result = load();\n    __privateGet(this, _cache).set(cacheKey, result);\n    if (typeof result === \"object\" && result !== null && \"then\" in result) {\n      return Promise.resolve(result).then((v) => {\n        __privateGet(this, _cache).set(cacheKey, v);\n        return v;\n      }).catch((err) => {\n        __privateGet(this, _cache).delete(cacheKey);\n        throw err;\n      });\n    }\n    return result;\n  }\n  readSync(key, load) {\n    const cacheKey = [__privateGet(this, _prefix), ...key].join(\":\");\n    if (__privateGet(this, _cache).has(cacheKey)) {\n      return __privateGet(this, _cache).get(cacheKey);\n    }\n    const result = load();\n    __privateGet(this, _cache).set(cacheKey, result);\n    return result;\n  }\n  clear(prefix) {\n    const prefixKey = [...__privateGet(this, _prefix), ...prefix ?? []].join(\":\");\n    if (!prefixKey) {\n      __privateGet(this, _cache).clear();\n      return;\n    }\n    for (const key of __privateGet(this, _cache).keys()) {\n      if (key.startsWith(prefixKey)) {\n        __privateGet(this, _cache).delete(key);\n      }\n    }\n  }\n  scope(prefix) {\n    return new _ClientCache({\n      prefix: [...__privateGet(this, _prefix), ...Array.isArray(prefix) ? prefix : [prefix]],\n      cache: __privateGet(this, _cache)\n    });\n  }\n};\n_prefix = new WeakMap();\n_cache = new WeakMap();\nlet ClientCache = _ClientCache;\nexport {\n  ClientCache\n};\n//# sourceMappingURL=cache.js.map\n","const PACKAGE_VERSION = \"1.45.2\";\nconst TARGETED_RPC_VERSION = \"1.62.0\";\nexport {\n  PACKAGE_VERSION,\n  TARGETED_RPC_VERSION\n};\n//# sourceMappingURL=version.js.map\n","var __typeError = (msg) => {\n  throw TypeError(msg);\n};\nvar __accessCheck = (obj, member, msg) => member.has(obj) || __typeError(\"Cannot \" + msg);\nvar __privateGet = (obj, member, getter) => (__accessCheck(obj, member, \"read from private field\"), getter ? getter.call(obj) : member.get(obj));\nvar __privateAdd = (obj, member, value) => member.has(obj) ? __typeError(\"Cannot add the same private member more than once\") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\nvar __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, \"write to private field\"), setter ? setter.call(obj, value) : member.set(obj, value), value);\nvar __privateMethod = (obj, member, method) => (__accessCheck(obj, member, \"access private method\"), method);\nvar _cache, _url, _pageSize, _overrides, _MvrClient_instances, mvrPackageDataLoader_get, mvrTypeDataLoader_get, resolvePackages_fn, resolveTypes_fn, fetch_fn;\nimport { chunk, DataLoader } from \"@mysten/utils\";\nimport { isValidNamedPackage, isValidNamedType } from \"../utils/move-registry.js\";\nimport {\n  isValidSuiAddress,\n  normalizeStructTag,\n  normalizeSuiAddress,\n  parseStructTag\n} from \"../utils/sui-types.js\";\nimport { PACKAGE_VERSION } from \"../version.js\";\nconst NAME_SEPARATOR = \"/\";\nconst MVR_API_HEADER = {\n  \"Mvr-Source\": `@mysten/sui@${PACKAGE_VERSION}`\n};\nclass MvrClient {\n  constructor({ cache, url, pageSize = 50, overrides }) {\n    __privateAdd(this, _MvrClient_instances);\n    __privateAdd(this, _cache);\n    __privateAdd(this, _url);\n    __privateAdd(this, _pageSize);\n    __privateAdd(this, _overrides);\n    __privateSet(this, _cache, cache);\n    __privateSet(this, _url, url);\n    __privateSet(this, _pageSize, pageSize);\n    __privateSet(this, _overrides, {\n      packages: overrides?.packages,\n      types: overrides?.types\n    });\n    validateOverrides(__privateGet(this, _overrides));\n  }\n  async resolvePackage({\n    package: name\n  }) {\n    if (!hasMvrName(name)) {\n      return {\n        package: name\n      };\n    }\n    const resolved = await __privateGet(this, _MvrClient_instances, mvrPackageDataLoader_get).load(name);\n    return {\n      package: resolved\n    };\n  }\n  async resolveType({\n    type\n  }) {\n    if (!hasMvrName(type)) {\n      return {\n        type\n      };\n    }\n    const mvrTypes = [...extractMvrTypes(type)];\n    const resolvedTypes = await __privateGet(this, _MvrClient_instances, mvrTypeDataLoader_get).loadMany(mvrTypes);\n    const typeMap = {};\n    for (let i = 0; i < mvrTypes.length; i++) {\n      const resolvedType = resolvedTypes[i];\n      if (resolvedType instanceof Error) {\n        throw resolvedType;\n      }\n      typeMap[mvrTypes[i]] = resolvedType;\n    }\n    return {\n      type: replaceMvrNames(type, typeMap)\n    };\n  }\n  async resolve({\n    types = [],\n    packages = []\n  }) {\n    const mvrTypes = /* @__PURE__ */ new Set();\n    for (const type of types ?? []) {\n      extractMvrTypes(type, mvrTypes);\n    }\n    const typesArray = [...mvrTypes];\n    const [resolvedTypes, resolvedPackages] = await Promise.all([\n      typesArray.length > 0 ? __privateGet(this, _MvrClient_instances, mvrTypeDataLoader_get).loadMany(typesArray) : [],\n      packages.length > 0 ? __privateGet(this, _MvrClient_instances, mvrPackageDataLoader_get).loadMany(packages) : []\n    ]);\n    const typeMap = {\n      ...__privateGet(this, _overrides)?.types\n    };\n    for (const [i, type] of typesArray.entries()) {\n      const resolvedType = resolvedTypes[i];\n      if (resolvedType instanceof Error) {\n        throw resolvedType;\n      }\n      typeMap[type] = resolvedType;\n    }\n    const replacedTypes = {};\n    for (const type of types ?? []) {\n      const resolvedType = replaceMvrNames(type, typeMap);\n      replacedTypes[type] = {\n        type: resolvedType\n      };\n    }\n    const replacedPackages = {};\n    for (const [i, pkg] of (packages ?? []).entries()) {\n      const resolvedPkg = __privateGet(this, _overrides)?.packages?.[pkg] ?? resolvedPackages[i];\n      if (resolvedPkg instanceof Error) {\n        throw resolvedPkg;\n      }\n      replacedPackages[pkg] = {\n        package: resolvedPkg\n      };\n    }\n    return {\n      types: replacedTypes,\n      packages: replacedPackages\n    };\n  }\n}\n_cache = new WeakMap();\n_url = new WeakMap();\n_pageSize = new WeakMap();\n_overrides = new WeakMap();\n_MvrClient_instances = new WeakSet();\nmvrPackageDataLoader_get = function() {\n  return __privateGet(this, _cache).readSync([\"#mvrPackageDataLoader\", __privateGet(this, _url) ?? \"\"], () => {\n    const loader = new DataLoader(async (packages) => {\n      if (!__privateGet(this, _url)) {\n        throw new Error(\n          `MVR Api URL is not set for the current client (resolving ${packages.join(\", \")})`\n        );\n      }\n      const resolved = await __privateMethod(this, _MvrClient_instances, resolvePackages_fn).call(this, packages);\n      return packages.map(\n        (pkg) => resolved[pkg] ?? new Error(`Failed to resolve package: ${pkg}`)\n      );\n    });\n    const overrides = __privateGet(this, _overrides)?.packages;\n    if (overrides) {\n      for (const [pkg, id] of Object.entries(overrides)) {\n        loader.prime(pkg, id);\n      }\n    }\n    return loader;\n  });\n};\nmvrTypeDataLoader_get = function() {\n  return __privateGet(this, _cache).readSync([\"#mvrTypeDataLoader\", __privateGet(this, _url) ?? \"\"], () => {\n    const loader = new DataLoader(async (types) => {\n      if (!__privateGet(this, _url)) {\n        throw new Error(\n          `MVR Api URL is not set for the current client (resolving ${types.join(\", \")})`\n        );\n      }\n      const resolved = await __privateMethod(this, _MvrClient_instances, resolveTypes_fn).call(this, types);\n      return types.map((type) => resolved[type] ?? new Error(`Failed to resolve type: ${type}`));\n    });\n    const overrides = __privateGet(this, _overrides)?.types;\n    if (overrides) {\n      for (const [type, id] of Object.entries(overrides)) {\n        loader.prime(type, id);\n      }\n    }\n    return loader;\n  });\n};\nresolvePackages_fn = async function(packages) {\n  if (packages.length === 0) return {};\n  const batches = chunk(packages, __privateGet(this, _pageSize));\n  const results = {};\n  await Promise.all(\n    batches.map(async (batch) => {\n      const data = await __privateMethod(this, _MvrClient_instances, fetch_fn).call(this, \"/v1/resolution/bulk\", {\n        names: batch\n      });\n      if (!data?.resolution) return;\n      for (const pkg of Object.keys(data?.resolution)) {\n        const pkgData = data.resolution[pkg]?.package_id;\n        if (!pkgData) continue;\n        results[pkg] = pkgData;\n      }\n    })\n  );\n  return results;\n};\nresolveTypes_fn = async function(types) {\n  if (types.length === 0) return {};\n  const batches = chunk(types, __privateGet(this, _pageSize));\n  const results = {};\n  await Promise.all(\n    batches.map(async (batch) => {\n      const data = await __privateMethod(this, _MvrClient_instances, fetch_fn).call(this, \"/v1/struct-definition/bulk\", {\n        types: batch\n      });\n      if (!data?.resolution) return;\n      for (const type of Object.keys(data?.resolution)) {\n        const typeData = data.resolution[type]?.type_tag;\n        if (!typeData) continue;\n        results[type] = typeData;\n      }\n    })\n  );\n  return results;\n};\nfetch_fn = async function(url, body) {\n  if (!__privateGet(this, _url)) {\n    throw new Error(\"MVR Api URL is not set for the current client\");\n  }\n  const response = await fetch(`${__privateGet(this, _url)}${url}`, {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n      ...MVR_API_HEADER\n    },\n    body: JSON.stringify(body)\n  });\n  if (!response.ok) {\n    const errorBody = await response.json().catch(() => ({}));\n    throw new Error(`Failed to resolve types: ${errorBody?.message}`);\n  }\n  return response.json();\n};\nfunction validateOverrides(overrides) {\n  if (overrides?.packages) {\n    for (const [pkg, id] of Object.entries(overrides.packages)) {\n      if (!isValidNamedPackage(pkg)) {\n        throw new Error(`Invalid package name: ${pkg}`);\n      }\n      if (!isValidSuiAddress(normalizeSuiAddress(id))) {\n        throw new Error(`Invalid package ID: ${id}`);\n      }\n    }\n  }\n  if (overrides?.types) {\n    for (const [type, val] of Object.entries(overrides.types)) {\n      if (parseStructTag(type).typeParams.length > 0) {\n        throw new Error(\n          \"Type overrides must be first-level only. If you want to supply generic types, just pass each type individually.\"\n        );\n      }\n      const parsedValue = parseStructTag(val);\n      if (!isValidSuiAddress(parsedValue.address)) {\n        throw new Error(`Invalid type: ${val}`);\n      }\n    }\n  }\n}\nfunction extractMvrTypes(type, types = /* @__PURE__ */ new Set()) {\n  if (typeof type === \"string\" && !hasMvrName(type)) return types;\n  const tag = isStructTag(type) ? type : parseStructTag(type);\n  if (hasMvrName(tag.address)) types.add(`${tag.address}::${tag.module}::${tag.name}`);\n  for (const param of tag.typeParams) {\n    extractMvrTypes(param, types);\n  }\n  return types;\n}\nfunction replaceMvrNames(tag, typeCache) {\n  const type = isStructTag(tag) ? tag : parseStructTag(tag);\n  const typeTag = `${type.address}::${type.module}::${type.name}`;\n  const cacheHit = typeCache[typeTag];\n  return normalizeStructTag({\n    ...type,\n    address: cacheHit ? cacheHit.split(\"::\")[0] : type.address,\n    typeParams: type.typeParams.map((param) => replaceMvrNames(param, typeCache))\n  });\n}\nfunction hasMvrName(nameOrType) {\n  return nameOrType.includes(NAME_SEPARATOR) || nameOrType.includes(\"@\") || nameOrType.includes(\".sui\");\n}\nfunction isStructTag(type) {\n  return typeof type === \"object\" && \"address\" in type && \"module\" in type && \"name\" in type && \"typeParams\" in type;\n}\nfunction findNamesInTransaction(builder) {\n  const packages = /* @__PURE__ */ new Set();\n  const types = /* @__PURE__ */ new Set();\n  for (const command of builder.commands) {\n    switch (command.$kind) {\n      case \"MakeMoveVec\":\n        if (command.MakeMoveVec.type) {\n          getNamesFromTypeList([command.MakeMoveVec.type]).forEach((type) => {\n            types.add(type);\n          });\n        }\n        break;\n      case \"MoveCall\":\n        const moveCall = command.MoveCall;\n        const pkg = moveCall.package.split(\"::\")[0];\n        if (hasMvrName(pkg)) {\n          if (!isValidNamedPackage(pkg)) throw new Error(`Invalid package name: ${pkg}`);\n          packages.add(pkg);\n        }\n        getNamesFromTypeList(moveCall.typeArguments ?? []).forEach((type) => {\n          types.add(type);\n        });\n        break;\n      default:\n        break;\n    }\n  }\n  return {\n    packages: [...packages],\n    types: [...types]\n  };\n}\nfunction replaceNames(builder, resolved) {\n  for (const command of builder.commands) {\n    if (command.MakeMoveVec?.type) {\n      if (!hasMvrName(command.MakeMoveVec.type)) continue;\n      if (!resolved.types[command.MakeMoveVec.type])\n        throw new Error(`No resolution found for type: ${command.MakeMoveVec.type}`);\n      command.MakeMoveVec.type = resolved.types[command.MakeMoveVec.type].type;\n    }\n    const tx = command.MoveCall;\n    if (!tx) continue;\n    const nameParts = tx.package.split(\"::\");\n    const name = nameParts[0];\n    if (hasMvrName(name) && !resolved.packages[name])\n      throw new Error(`No address found for package: ${name}`);\n    if (hasMvrName(name)) {\n      nameParts[0] = resolved.packages[name].package;\n      tx.package = nameParts.join(\"::\");\n    }\n    const types = tx.typeArguments;\n    if (!types) continue;\n    for (let i = 0; i < types.length; i++) {\n      if (!hasMvrName(types[i])) continue;\n      if (!resolved.types[types[i]]) throw new Error(`No resolution found for type: ${types[i]}`);\n      types[i] = resolved.types[types[i]].type;\n    }\n    tx.typeArguments = types;\n  }\n}\nfunction getNamesFromTypeList(types) {\n  const names = /* @__PURE__ */ new Set();\n  for (const type of types) {\n    if (hasMvrName(type)) {\n      if (!isValidNamedType(type)) throw new Error(`Invalid type with names: ${type}`);\n      names.add(type);\n    }\n  }\n  return names;\n}\nexport {\n  MvrClient,\n  extractMvrTypes,\n  findNamesInTransaction,\n  hasMvrName,\n  replaceNames\n};\n//# sourceMappingURL=mvr.js.map\n","import { ClientCache } from \"../../experimental/cache.js\";\nimport { MvrClient } from \"../../experimental/mvr.js\";\nimport { findNamesInTransaction, replaceNames } from \"../../experimental/mvr.js\";\nconst cacheMap = /* @__PURE__ */ new WeakMap();\nconst namedPackagesPlugin = (options) => {\n  let mvrClient;\n  if (options) {\n    const overrides = options.overrides ?? {\n      packages: {},\n      types: {}\n    };\n    if (!cacheMap.has(overrides)) {\n      cacheMap.set(overrides, new ClientCache());\n    }\n    mvrClient = new MvrClient({\n      cache: cacheMap.get(overrides),\n      url: options.url,\n      pageSize: options.pageSize,\n      overrides\n    });\n  }\n  return async (transactionData, buildOptions, next) => {\n    const names = findNamesInTransaction(transactionData);\n    if (names.types.length === 0 && names.packages.length === 0) {\n      return next();\n    }\n    const resolved = await (mvrClient || getClient(buildOptions).core.mvr).resolve({\n      types: names.types,\n      packages: names.packages\n    });\n    replaceNames(transactionData, resolved);\n    await next();\n  };\n};\nfunction getClient(options) {\n  if (!options.client) {\n    throw new Error(\n      `No sui client passed to Transaction#build, but transaction data was not sufficient to build offline.`\n    );\n  }\n  return options.client;\n}\nexport {\n  getClient,\n  namedPackagesPlugin\n};\n//# sourceMappingURL=NamedPackagesPlugin.js.map\n","var __typeError = (msg) => {\n  throw TypeError(msg);\n};\nvar __accessCheck = (obj, member, msg) => member.has(obj) || __typeError(\"Cannot \" + msg);\nvar __privateGet = (obj, member, getter) => (__accessCheck(obj, member, \"read from private field\"), getter ? getter.call(obj) : member.get(obj));\nvar __privateAdd = (obj, member, value) => member.has(obj) ? __typeError(\"Cannot add the same private member more than once\") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\nvar __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, \"write to private field\"), setter ? setter.call(obj, value) : member.set(obj, value), value);\nvar __privateMethod = (obj, member, method) => (__accessCheck(obj, member, \"access private method\"), method);\nvar _serializationPlugins, _buildPlugins, _intentResolvers, _inputSection, _commandSection, _availableResults, _pendingPromises, _added, _data, _Transaction_instances, fork_fn, addCommand_fn, addInput_fn, normalizeTransactionArgument_fn, resolveArgument_fn, prepareBuild_fn, runPlugins_fn, waitForPendingTasks_fn, sortCommandsAndInputs_fn;\nimport { fromBase64, isSerializedBcs } from \"@mysten/bcs\";\nimport { is, parse } from \"valibot\";\nimport { normalizeSuiAddress } from \"../utils/sui-types.js\";\nimport { Commands } from \"./Commands.js\";\nimport {\n  ArgumentSchema,\n  NormalizedCallArg,\n  ObjectRefSchema,\n  TransactionExpiration\n} from \"./data/internal.js\";\nimport { serializeV1TransactionData } from \"./data/v1.js\";\nimport { SerializedTransactionDataV2Schema } from \"./data/v2.js\";\nimport { Inputs } from \"./Inputs.js\";\nimport { needsTransactionResolution, resolveTransactionPlugin } from \"./resolve.js\";\nimport { createObjectMethods } from \"./object.js\";\nimport { createPure } from \"./pure.js\";\nimport { TransactionDataBuilder } from \"./TransactionData.js\";\nimport { getIdFromCallArg } from \"./utils.js\";\nimport { namedPackagesPlugin } from \"./plugins/NamedPackagesPlugin.js\";\nfunction createTransactionResult(index, length = Infinity) {\n  const baseResult = {\n    $kind: \"Result\",\n    get Result() {\n      return typeof index === \"function\" ? index() : index;\n    }\n  };\n  const nestedResults = [];\n  const nestedResultFor = (resultIndex) => nestedResults[resultIndex] ?? (nestedResults[resultIndex] = {\n    $kind: \"NestedResult\",\n    get NestedResult() {\n      return [typeof index === \"function\" ? index() : index, resultIndex];\n    }\n  });\n  return new Proxy(baseResult, {\n    set() {\n      throw new Error(\n        \"The transaction result is a proxy, and does not support setting properties directly\"\n      );\n    },\n    // TODO: Instead of making this return a concrete argument, we should ideally\n    // make it reference-based (so that this gets resolved at build-time), which\n    // allows re-ordering transactions.\n    get(target, property) {\n      if (property in target) {\n        return Reflect.get(target, property);\n      }\n      if (property === Symbol.iterator) {\n        return function* () {\n          let i = 0;\n          while (i < length) {\n            yield nestedResultFor(i);\n            i++;\n          }\n        };\n      }\n      if (typeof property === \"symbol\") return;\n      const resultIndex = parseInt(property, 10);\n      if (Number.isNaN(resultIndex) || resultIndex < 0) return;\n      return nestedResultFor(resultIndex);\n    }\n  });\n}\nconst TRANSACTION_BRAND = Symbol.for(\"@mysten/transaction\");\nfunction isTransaction(obj) {\n  return !!obj && typeof obj === \"object\" && obj[TRANSACTION_BRAND] === true;\n}\nconst modulePluginRegistry = {\n  buildPlugins: /* @__PURE__ */ new Map(),\n  serializationPlugins: /* @__PURE__ */ new Map()\n};\nconst TRANSACTION_REGISTRY_KEY = Symbol.for(\"@mysten/transaction/registry\");\nfunction getGlobalPluginRegistry() {\n  try {\n    const target = globalThis;\n    if (!target[TRANSACTION_REGISTRY_KEY]) {\n      target[TRANSACTION_REGISTRY_KEY] = modulePluginRegistry;\n    }\n    return target[TRANSACTION_REGISTRY_KEY];\n  } catch {\n    return modulePluginRegistry;\n  }\n}\nconst _Transaction = class _Transaction {\n  constructor() {\n    __privateAdd(this, _Transaction_instances);\n    __privateAdd(this, _serializationPlugins);\n    __privateAdd(this, _buildPlugins);\n    __privateAdd(this, _intentResolvers, /* @__PURE__ */ new Map());\n    __privateAdd(this, _inputSection, []);\n    __privateAdd(this, _commandSection, []);\n    __privateAdd(this, _availableResults, /* @__PURE__ */ new Set());\n    __privateAdd(this, _pendingPromises, /* @__PURE__ */ new Set());\n    __privateAdd(this, _added, /* @__PURE__ */ new Map());\n    __privateAdd(this, _data);\n    /**\n     * Add a new object input to the transaction.\n     */\n    this.object = createObjectMethods(\n      (value) => {\n        if (typeof value === \"function\") {\n          return this.object(this.add(value));\n        }\n        if (typeof value === \"object\" && is(ArgumentSchema, value)) {\n          return value;\n        }\n        const id = getIdFromCallArg(value);\n        const inserted = __privateGet(this, _data).inputs.find((i) => id === getIdFromCallArg(i));\n        if (inserted?.Object?.SharedObject && typeof value === \"object\" && value.Object?.SharedObject) {\n          inserted.Object.SharedObject.mutable = inserted.Object.SharedObject.mutable || value.Object.SharedObject.mutable;\n        }\n        return inserted ? { $kind: \"Input\", Input: __privateGet(this, _data).inputs.indexOf(inserted), type: \"object\" } : __privateMethod(this, _Transaction_instances, addInput_fn).call(this, \"object\", typeof value === \"string\" ? {\n          $kind: \"UnresolvedObject\",\n          UnresolvedObject: { objectId: normalizeSuiAddress(value) }\n        } : value);\n      }\n    );\n    const globalPlugins = getGlobalPluginRegistry();\n    __privateSet(this, _data, new TransactionDataBuilder());\n    __privateSet(this, _buildPlugins, [...globalPlugins.buildPlugins.values()]);\n    __privateSet(this, _serializationPlugins, [...globalPlugins.serializationPlugins.values()]);\n  }\n  /**\n   * Converts from a serialize transaction kind (built with `build({ onlyTransactionKind: true })`) to a `Transaction` class.\n   * Supports either a byte array, or base64-encoded bytes.\n   */\n  static fromKind(serialized) {\n    const tx = new _Transaction();\n    __privateSet(tx, _data, TransactionDataBuilder.fromKindBytes(\n      typeof serialized === \"string\" ? fromBase64(serialized) : serialized\n    ));\n    __privateSet(tx, _inputSection, __privateGet(tx, _data).inputs.slice());\n    __privateSet(tx, _commandSection, __privateGet(tx, _data).commands.slice());\n    __privateSet(tx, _availableResults, new Set(__privateGet(tx, _commandSection).map((_, i) => i)));\n    return tx;\n  }\n  /**\n   * Converts from a serialized transaction format to a `Transaction` class.\n   * There are two supported serialized formats:\n   * - A string returned from `Transaction#serialize`. The serialized format must be compatible, or it will throw an error.\n   * - A byte array (or base64-encoded bytes) containing BCS transaction data.\n   */\n  static from(transaction) {\n    const newTransaction = new _Transaction();\n    if (isTransaction(transaction)) {\n      __privateSet(newTransaction, _data, TransactionDataBuilder.restore(\n        transaction.getData()\n      ));\n    } else if (typeof transaction !== \"string\" || !transaction.startsWith(\"{\")) {\n      __privateSet(newTransaction, _data, TransactionDataBuilder.fromBytes(\n        typeof transaction === \"string\" ? fromBase64(transaction) : transaction\n      ));\n    } else {\n      __privateSet(newTransaction, _data, TransactionDataBuilder.restore(JSON.parse(transaction)));\n    }\n    __privateSet(newTransaction, _inputSection, __privateGet(newTransaction, _data).inputs.slice());\n    __privateSet(newTransaction, _commandSection, __privateGet(newTransaction, _data).commands.slice());\n    __privateSet(newTransaction, _availableResults, new Set(__privateGet(newTransaction, _commandSection).map((_, i) => i)));\n    return newTransaction;\n  }\n  static registerGlobalSerializationPlugin(stepOrStep, step) {\n    getGlobalPluginRegistry().serializationPlugins.set(\n      stepOrStep,\n      step ?? stepOrStep\n    );\n  }\n  static unregisterGlobalSerializationPlugin(name) {\n    getGlobalPluginRegistry().serializationPlugins.delete(name);\n  }\n  static registerGlobalBuildPlugin(stepOrStep, step) {\n    getGlobalPluginRegistry().buildPlugins.set(\n      stepOrStep,\n      step ?? stepOrStep\n    );\n  }\n  static unregisterGlobalBuildPlugin(name) {\n    getGlobalPluginRegistry().buildPlugins.delete(name);\n  }\n  addSerializationPlugin(step) {\n    __privateGet(this, _serializationPlugins).push(step);\n  }\n  addBuildPlugin(step) {\n    __privateGet(this, _buildPlugins).push(step);\n  }\n  addIntentResolver(intent, resolver) {\n    if (__privateGet(this, _intentResolvers).has(intent) && __privateGet(this, _intentResolvers).get(intent) !== resolver) {\n      throw new Error(`Intent resolver for ${intent} already exists`);\n    }\n    __privateGet(this, _intentResolvers).set(intent, resolver);\n  }\n  setSender(sender) {\n    __privateGet(this, _data).sender = sender;\n  }\n  /**\n   * Sets the sender only if it has not already been set.\n   * This is useful for sponsored transaction flows where the sender may not be the same as the signer address.\n   */\n  setSenderIfNotSet(sender) {\n    if (!__privateGet(this, _data).sender) {\n      __privateGet(this, _data).sender = sender;\n    }\n  }\n  setExpiration(expiration) {\n    __privateGet(this, _data).expiration = expiration ? parse(TransactionExpiration, expiration) : null;\n  }\n  setGasPrice(price) {\n    __privateGet(this, _data).gasConfig.price = String(price);\n  }\n  setGasBudget(budget) {\n    __privateGet(this, _data).gasConfig.budget = String(budget);\n  }\n  setGasBudgetIfNotSet(budget) {\n    if (__privateGet(this, _data).gasData.budget == null) {\n      __privateGet(this, _data).gasConfig.budget = String(budget);\n    }\n  }\n  setGasOwner(owner) {\n    __privateGet(this, _data).gasConfig.owner = owner;\n  }\n  setGasPayment(payments) {\n    __privateGet(this, _data).gasConfig.payment = payments.map((payment) => parse(ObjectRefSchema, payment));\n  }\n  /** @deprecated Use `getData()` instead. */\n  get blockData() {\n    return serializeV1TransactionData(__privateGet(this, _data).snapshot());\n  }\n  /** Get a snapshot of the transaction data, in JSON form: */\n  getData() {\n    return __privateGet(this, _data).snapshot();\n  }\n  // Used to brand transaction classes so that they can be identified, even between multiple copies\n  // of the builder.\n  get [TRANSACTION_BRAND]() {\n    return true;\n  }\n  // Temporary workaround for the wallet interface accidentally serializing transactions via postMessage\n  get pure() {\n    Object.defineProperty(this, \"pure\", {\n      enumerable: false,\n      value: createPure((value) => {\n        if (isSerializedBcs(value)) {\n          return __privateMethod(this, _Transaction_instances, addInput_fn).call(this, \"pure\", {\n            $kind: \"Pure\",\n            Pure: {\n              bytes: value.toBase64()\n            }\n          });\n        }\n        return __privateMethod(this, _Transaction_instances, addInput_fn).call(this, \"pure\", is(NormalizedCallArg, value) ? parse(NormalizedCallArg, value) : value instanceof Uint8Array ? Inputs.Pure(value) : { $kind: \"UnresolvedPure\", UnresolvedPure: { value } });\n      })\n    });\n    return this.pure;\n  }\n  /** Returns an argument for the gas coin, to be used in a transaction. */\n  get gas() {\n    return { $kind: \"GasCoin\", GasCoin: true };\n  }\n  /**\n   * Add a new object input to the transaction using the fully-resolved object reference.\n   * If you only have an object ID, use `builder.object(id)` instead.\n   */\n  objectRef(...args) {\n    return this.object(Inputs.ObjectRef(...args));\n  }\n  /**\n   * Add a new receiving input to the transaction using the fully-resolved object reference.\n   * If you only have an object ID, use `builder.object(id)` instead.\n   */\n  receivingRef(...args) {\n    return this.object(Inputs.ReceivingRef(...args));\n  }\n  /**\n   * Add a new shared object input to the transaction using the fully-resolved shared object reference.\n   * If you only have an object ID, use `builder.object(id)` instead.\n   */\n  sharedObjectRef(...args) {\n    return this.object(Inputs.SharedObjectRef(...args));\n  }\n  add(command) {\n    if (typeof command === \"function\") {\n      if (__privateGet(this, _added).has(command)) {\n        return __privateGet(this, _added).get(command);\n      }\n      const fork = __privateMethod(this, _Transaction_instances, fork_fn).call(this);\n      const result = command(fork);\n      if (!(result && typeof result === \"object\" && \"then\" in result)) {\n        __privateSet(this, _availableResults, __privateGet(fork, _availableResults));\n        __privateGet(this, _added).set(command, result);\n        return result;\n      }\n      const placeholder = __privateMethod(this, _Transaction_instances, addCommand_fn).call(this, {\n        $kind: \"$Intent\",\n        $Intent: {\n          name: \"AsyncTransactionThunk\",\n          inputs: {},\n          data: {\n            resultIndex: __privateGet(this, _data).commands.length,\n            result: null\n          }\n        }\n      });\n      __privateGet(this, _pendingPromises).add(\n        Promise.resolve(result).then((result2) => {\n          placeholder.$Intent.data.result = result2;\n        })\n      );\n      const txResult = createTransactionResult(() => placeholder.$Intent.data.resultIndex);\n      __privateGet(this, _added).set(command, txResult);\n      return txResult;\n    } else {\n      __privateMethod(this, _Transaction_instances, addCommand_fn).call(this, command);\n    }\n    return createTransactionResult(__privateGet(this, _data).commands.length - 1);\n  }\n  // Method shorthands:\n  splitCoins(coin, amounts) {\n    const command = Commands.SplitCoins(\n      typeof coin === \"string\" ? this.object(coin) : __privateMethod(this, _Transaction_instances, resolveArgument_fn).call(this, coin),\n      amounts.map(\n        (amount) => typeof amount === \"number\" || typeof amount === \"bigint\" || typeof amount === \"string\" ? this.pure.u64(amount) : __privateMethod(this, _Transaction_instances, normalizeTransactionArgument_fn).call(this, amount)\n      )\n    );\n    __privateMethod(this, _Transaction_instances, addCommand_fn).call(this, command);\n    return createTransactionResult(__privateGet(this, _data).commands.length - 1, amounts.length);\n  }\n  mergeCoins(destination, sources) {\n    return this.add(\n      Commands.MergeCoins(\n        this.object(destination),\n        sources.map((src) => this.object(src))\n      )\n    );\n  }\n  publish({ modules, dependencies }) {\n    return this.add(\n      Commands.Publish({\n        modules,\n        dependencies\n      })\n    );\n  }\n  upgrade({\n    modules,\n    dependencies,\n    package: packageId,\n    ticket\n  }) {\n    return this.add(\n      Commands.Upgrade({\n        modules,\n        dependencies,\n        package: packageId,\n        ticket: this.object(ticket)\n      })\n    );\n  }\n  moveCall({\n    arguments: args,\n    ...input\n  }) {\n    return this.add(\n      Commands.MoveCall({\n        ...input,\n        arguments: args?.map((arg) => __privateMethod(this, _Transaction_instances, normalizeTransactionArgument_fn).call(this, arg))\n      })\n    );\n  }\n  transferObjects(objects, address) {\n    return this.add(\n      Commands.TransferObjects(\n        objects.map((obj) => this.object(obj)),\n        typeof address === \"string\" ? this.pure.address(address) : __privateMethod(this, _Transaction_instances, normalizeTransactionArgument_fn).call(this, address)\n      )\n    );\n  }\n  makeMoveVec({\n    type,\n    elements\n  }) {\n    return this.add(\n      Commands.MakeMoveVec({\n        type,\n        elements: elements.map((obj) => this.object(obj))\n      })\n    );\n  }\n  /**\n   * @deprecated Use toJSON instead.\n   * For synchronous serialization, you can use `getData()`\n   * */\n  serialize() {\n    return JSON.stringify(serializeV1TransactionData(__privateGet(this, _data).snapshot()));\n  }\n  async toJSON(options = {}) {\n    await this.prepareForSerialization(options);\n    const fullyResolved = this.isFullyResolved();\n    return JSON.stringify(\n      parse(\n        SerializedTransactionDataV2Schema,\n        fullyResolved ? {\n          ...__privateGet(this, _data).snapshot(),\n          digest: __privateGet(this, _data).getDigest()\n        } : __privateGet(this, _data).snapshot()\n      ),\n      (_key, value) => typeof value === \"bigint\" ? value.toString() : value,\n      2\n    );\n  }\n  /** Build the transaction to BCS bytes, and sign it with the provided keypair. */\n  async sign(options) {\n    const { signer, ...buildOptions } = options;\n    const bytes = await this.build(buildOptions);\n    return signer.signTransaction(bytes);\n  }\n  /**\n   *  Ensures that:\n   *  - All objects have been fully resolved to a specific version\n   *  - All pure inputs have been serialized to bytes\n   *  - All async thunks have been fully resolved\n   *  - All transaction intents have been resolved\n   * \t- The gas payment, budget, and price have been set\n   *  - The transaction sender has been set\n   *\n   *  When true, the transaction will always be built to the same bytes and digest (unless the transaction is mutated)\n   */\n  isFullyResolved() {\n    if (!__privateGet(this, _data).sender) {\n      return false;\n    }\n    if (__privateGet(this, _pendingPromises).size > 0) {\n      return false;\n    }\n    if (__privateGet(this, _data).commands.some((cmd) => cmd.$Intent)) {\n      return false;\n    }\n    if (needsTransactionResolution(__privateGet(this, _data), {})) {\n      return false;\n    }\n    return true;\n  }\n  /** Build the transaction to BCS bytes. */\n  async build(options = {}) {\n    await this.prepareForSerialization(options);\n    await __privateMethod(this, _Transaction_instances, prepareBuild_fn).call(this, options);\n    return __privateGet(this, _data).build({\n      onlyTransactionKind: options.onlyTransactionKind\n    });\n  }\n  /** Derive transaction digest */\n  async getDigest(options = {}) {\n    await this.prepareForSerialization(options);\n    await __privateMethod(this, _Transaction_instances, prepareBuild_fn).call(this, options);\n    return __privateGet(this, _data).getDigest();\n  }\n  async prepareForSerialization(options) {\n    await __privateMethod(this, _Transaction_instances, waitForPendingTasks_fn).call(this);\n    __privateMethod(this, _Transaction_instances, sortCommandsAndInputs_fn).call(this);\n    const intents = /* @__PURE__ */ new Set();\n    for (const command of __privateGet(this, _data).commands) {\n      if (command.$Intent) {\n        intents.add(command.$Intent.name);\n      }\n    }\n    const steps = [...__privateGet(this, _serializationPlugins)];\n    for (const intent of intents) {\n      if (options.supportedIntents?.includes(intent)) {\n        continue;\n      }\n      if (!__privateGet(this, _intentResolvers).has(intent)) {\n        throw new Error(`Missing intent resolver for ${intent}`);\n      }\n      steps.push(__privateGet(this, _intentResolvers).get(intent));\n    }\n    steps.push(namedPackagesPlugin());\n    await __privateMethod(this, _Transaction_instances, runPlugins_fn).call(this, steps, options);\n  }\n};\n_serializationPlugins = new WeakMap();\n_buildPlugins = new WeakMap();\n_intentResolvers = new WeakMap();\n_inputSection = new WeakMap();\n_commandSection = new WeakMap();\n_availableResults = new WeakMap();\n_pendingPromises = new WeakMap();\n_added = new WeakMap();\n_data = new WeakMap();\n_Transaction_instances = new WeakSet();\nfork_fn = function() {\n  const fork = new _Transaction();\n  __privateSet(fork, _data, __privateGet(this, _data));\n  __privateSet(fork, _serializationPlugins, __privateGet(this, _serializationPlugins));\n  __privateSet(fork, _buildPlugins, __privateGet(this, _buildPlugins));\n  __privateSet(fork, _intentResolvers, __privateGet(this, _intentResolvers));\n  __privateSet(fork, _pendingPromises, __privateGet(this, _pendingPromises));\n  __privateSet(fork, _availableResults, new Set(__privateGet(this, _availableResults)));\n  __privateSet(fork, _added, __privateGet(this, _added));\n  __privateGet(this, _inputSection).push(__privateGet(fork, _inputSection));\n  __privateGet(this, _commandSection).push(__privateGet(fork, _commandSection));\n  return fork;\n};\naddCommand_fn = function(command) {\n  const resultIndex = __privateGet(this, _data).commands.length;\n  __privateGet(this, _commandSection).push(command);\n  __privateGet(this, _availableResults).add(resultIndex);\n  __privateGet(this, _data).commands.push(command);\n  __privateGet(this, _data).mapCommandArguments(resultIndex, (arg) => {\n    if (arg.$kind === \"Result\" && !__privateGet(this, _availableResults).has(arg.Result)) {\n      throw new Error(\n        `Result { Result: ${arg.Result} } is not available to use in the current transaction`\n      );\n    }\n    if (arg.$kind === \"NestedResult\" && !__privateGet(this, _availableResults).has(arg.NestedResult[0])) {\n      throw new Error(\n        `Result { NestedResult: [${arg.NestedResult[0]}, ${arg.NestedResult[1]}] } is not available to use in the current transaction`\n      );\n    }\n    if (arg.$kind === \"Input\" && arg.Input >= __privateGet(this, _data).inputs.length) {\n      throw new Error(\n        `Input { Input: ${arg.Input} } references an input that does not exist in the current transaction`\n      );\n    }\n    return arg;\n  });\n  return command;\n};\naddInput_fn = function(type, input) {\n  __privateGet(this, _inputSection).push(input);\n  return __privateGet(this, _data).addInput(type, input);\n};\nnormalizeTransactionArgument_fn = function(arg) {\n  if (isSerializedBcs(arg)) {\n    return this.pure(arg);\n  }\n  return __privateMethod(this, _Transaction_instances, resolveArgument_fn).call(this, arg);\n};\nresolveArgument_fn = function(arg) {\n  if (typeof arg === \"function\") {\n    const resolved = this.add(arg);\n    if (typeof resolved === \"function\") {\n      return __privateMethod(this, _Transaction_instances, resolveArgument_fn).call(this, resolved);\n    }\n    return parse(ArgumentSchema, resolved);\n  }\n  return parse(ArgumentSchema, arg);\n};\nprepareBuild_fn = async function(options) {\n  if (!options.onlyTransactionKind && !__privateGet(this, _data).sender) {\n    throw new Error(\"Missing transaction sender\");\n  }\n  await __privateMethod(this, _Transaction_instances, runPlugins_fn).call(this, [...__privateGet(this, _buildPlugins), resolveTransactionPlugin], options);\n};\nrunPlugins_fn = async function(plugins, options) {\n  try {\n    const createNext = (i) => {\n      if (i >= plugins.length) {\n        return () => {\n        };\n      }\n      const plugin = plugins[i];\n      return async () => {\n        const next = createNext(i + 1);\n        let calledNext = false;\n        let nextResolved = false;\n        await plugin(__privateGet(this, _data), options, async () => {\n          if (calledNext) {\n            throw new Error(`next() was call multiple times in TransactionPlugin ${i}`);\n          }\n          calledNext = true;\n          await next();\n          nextResolved = true;\n        });\n        if (!calledNext) {\n          throw new Error(`next() was not called in TransactionPlugin ${i}`);\n        }\n        if (!nextResolved) {\n          throw new Error(`next() was not awaited in TransactionPlugin ${i}`);\n        }\n      };\n    };\n    await createNext(0)();\n  } finally {\n    __privateSet(this, _inputSection, __privateGet(this, _data).inputs.slice());\n    __privateSet(this, _commandSection, __privateGet(this, _data).commands.slice());\n    __privateSet(this, _availableResults, new Set(__privateGet(this, _commandSection).map((_, i) => i)));\n  }\n};\nwaitForPendingTasks_fn = async function() {\n  while (__privateGet(this, _pendingPromises).size > 0) {\n    const newPromise = Promise.all(__privateGet(this, _pendingPromises));\n    __privateGet(this, _pendingPromises).clear();\n    __privateGet(this, _pendingPromises).add(newPromise);\n    await newPromise;\n    __privateGet(this, _pendingPromises).delete(newPromise);\n  }\n};\nsortCommandsAndInputs_fn = function() {\n  const unorderedCommands = __privateGet(this, _data).commands;\n  const unorderedInputs = __privateGet(this, _data).inputs;\n  const orderedCommands = __privateGet(this, _commandSection).flat(Infinity);\n  const orderedInputs = __privateGet(this, _inputSection).flat(Infinity);\n  if (orderedCommands.length !== unorderedCommands.length) {\n    throw new Error(\"Unexpected number of commands found in transaction data\");\n  }\n  if (orderedInputs.length !== unorderedInputs.length) {\n    throw new Error(\"Unexpected number of inputs found in transaction data\");\n  }\n  const filteredCommands = orderedCommands.filter(\n    (cmd) => cmd.$Intent?.name !== \"AsyncTransactionThunk\"\n  );\n  __privateGet(this, _data).commands = filteredCommands;\n  __privateGet(this, _data).inputs = orderedInputs;\n  __privateSet(this, _commandSection, filteredCommands);\n  __privateSet(this, _inputSection, orderedInputs);\n  __privateSet(this, _availableResults, new Set(filteredCommands.map((_, i) => i)));\n  function getOriginalIndex(index) {\n    const command = unorderedCommands[index];\n    if (command.$Intent?.name === \"AsyncTransactionThunk\") {\n      const result = command.$Intent.data.result;\n      if (result == null) {\n        throw new Error(\"AsyncTransactionThunk has not been resolved\");\n      }\n      return getOriginalIndex(result.Result);\n    }\n    const updated = filteredCommands.indexOf(command);\n    if (updated === -1) {\n      throw new Error(\"Unable to find original index for command\");\n    }\n    return updated;\n  }\n  __privateGet(this, _data).mapArguments((arg) => {\n    if (arg.$kind === \"Input\") {\n      const updated = orderedInputs.indexOf(unorderedInputs[arg.Input]);\n      if (updated === -1) {\n        throw new Error(\"Input has not been resolved\");\n      }\n      return { ...arg, Input: updated };\n    } else if (arg.$kind === \"Result\") {\n      const updated = getOriginalIndex(arg.Result);\n      return { ...arg, Result: updated };\n    } else if (arg.$kind === \"NestedResult\") {\n      const updated = getOriginalIndex(arg.NestedResult[0]);\n      return { ...arg, NestedResult: [updated, arg.NestedResult[1]] };\n    }\n    return arg;\n  });\n  for (const [i, cmd] of unorderedCommands.entries()) {\n    if (cmd.$Intent?.name === \"AsyncTransactionThunk\") {\n      try {\n        cmd.$Intent.data.resultIndex = getOriginalIndex(i);\n      } catch {\n      }\n    }\n  }\n};\nlet Transaction = _Transaction;\nexport {\n  Transaction,\n  isTransaction\n};\n//# sourceMappingURL=Transaction.js.map\n"],"x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46],"mappings":"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"}