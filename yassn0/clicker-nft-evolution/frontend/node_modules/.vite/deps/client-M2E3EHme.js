import { At as fromBase58, Ct as normalizeSuiNSName, Dt as toHex, F as blake2b, N as suiBcs, Ot as fromBase64, P as TypeTagSerializer, St as isValidNamedPackage, Tt as chunk, _t as isValidTransactionDigest, a as hasMvrName, bt as normalizeSuiObjectId, c as ClientCache, gt as isValidSuiObjectId, ht as isValidSuiAddress, i as MvrClient, kt as toBase64, l as TransactionDataBuilder, m as jsonRpcClientResolveTransactionPlugin, mt as SUI_ADDRESS_LENGTH, n as isTransaction, o as PACKAGE_VERSION, s as TARGETED_RPC_VERSION, t as Transaction, vt as normalizeStructTag, xt as parseStructTag, yt as normalizeSuiAddress } from "./Transaction-DWkJnoaJ.js";

//#region node_modules/.pnpm/@mysten+sui@1.45.2_typescript@5.9.3/node_modules/@mysten/sui/dist/esm/utils/dynamic-fields.js
function deriveDynamicFieldID(parentId, typeTag, key) {
	const address = suiBcs.Address.serialize(parentId).toBytes();
	const tag = suiBcs.TypeTag.serialize(typeTag).toBytes();
	const keyLength = suiBcs.u64().serialize(key.length).toBytes();
	const hash = blake2b.create({ dkLen: 32 });
	hash.update(new Uint8Array([240]));
	hash.update(address);
	hash.update(keyLength);
	hash.update(key);
	hash.update(tag);
	return `0x${toHex(hash.digest().slice(0, 32))}`;
}

//#endregion
//#region node_modules/.pnpm/@mysten+sui@1.45.2_typescript@5.9.3/node_modules/@mysten/sui/dist/esm/jsonRpc/errors.js
var CODE_TO_ERROR_TYPE = {
	"-32700": "ParseError",
	"-32701": "OversizedRequest",
	"-32702": "OversizedResponse",
	"-32600": "InvalidRequest",
	"-32601": "MethodNotFound",
	"-32602": "InvalidParams",
	"-32603": "InternalError",
	"-32604": "ServerBusy",
	"-32000": "CallExecutionFailed",
	"-32001": "UnknownError",
	"-32003": "SubscriptionClosed",
	"-32004": "SubscriptionClosedWithError",
	"-32005": "BatchesNotSupported",
	"-32006": "TooManySubscriptions",
	"-32050": "TransientError",
	"-32002": "TransactionExecutionClientError"
};
var SuiHTTPTransportError = class extends Error {};
var JsonRpcError = class extends SuiHTTPTransportError {
	constructor(message, code) {
		super(message);
		this.code = code;
		this.type = CODE_TO_ERROR_TYPE[code] ?? "ServerError";
	}
};
var SuiHTTPStatusError = class extends SuiHTTPTransportError {
	constructor(message, status, statusText) {
		super(message);
		this.status = status;
		this.statusText = statusText;
	}
};

//#endregion
//#region node_modules/.pnpm/@mysten+sui@1.45.2_typescript@5.9.3/node_modules/@mysten/sui/dist/esm/jsonRpc/rpc-websocket-client.js
var __typeError$2 = (msg) => {
	throw TypeError(msg);
};
var __accessCheck$2 = (obj, member, msg) => member.has(obj) || __typeError$2("Cannot " + msg);
var __privateGet$2 = (obj, member, getter) => (__accessCheck$2(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd$2 = (obj, member, value) => member.has(obj) ? __typeError$2("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet$2 = (obj, member, value, setter) => (__accessCheck$2(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod$1 = (obj, member, method) => (__accessCheck$2(obj, member, "access private method"), method);
var __privateWrapper = (obj, member, setter, getter) => ({
	set _(value) {
		__privateSet$2(obj, member, value, setter);
	},
	get _() {
		return __privateGet$2(obj, member, getter);
	}
});
var _requestId$1, _disconnects, _webSocket, _connectionPromise, _subscriptions, _pendingRequests, _WebsocketClient_instances, setupWebSocket_fn, reconnect_fn;
function getWebsocketUrl(httpUrl) {
	const url = new URL(httpUrl);
	url.protocol = url.protocol.replace("http", "ws");
	return url.toString();
}
var DEFAULT_CLIENT_OPTIONS = {
	WebSocketConstructor: typeof WebSocket !== "undefined" ? WebSocket : void 0,
	callTimeout: 3e4,
	reconnectTimeout: 3e3,
	maxReconnects: 5
};
var WebsocketClient = class {
	constructor(endpoint, options = {}) {
		__privateAdd$2(this, _WebsocketClient_instances);
		__privateAdd$2(this, _requestId$1, 0);
		__privateAdd$2(this, _disconnects, 0);
		__privateAdd$2(this, _webSocket, null);
		__privateAdd$2(this, _connectionPromise, null);
		__privateAdd$2(this, _subscriptions, /* @__PURE__ */ new Set());
		__privateAdd$2(this, _pendingRequests, /* @__PURE__ */ new Map());
		this.endpoint = endpoint;
		this.options = {
			...DEFAULT_CLIENT_OPTIONS,
			...options
		};
		if (!this.options.WebSocketConstructor) throw new Error("Missing WebSocket constructor");
		if (this.endpoint.startsWith("http")) this.endpoint = getWebsocketUrl(this.endpoint);
	}
	async makeRequest(method, params, signal) {
		const webSocket = await __privateMethod$1(this, _WebsocketClient_instances, setupWebSocket_fn).call(this);
		return new Promise((resolve, reject) => {
			__privateSet$2(this, _requestId$1, __privateGet$2(this, _requestId$1) + 1);
			__privateGet$2(this, _pendingRequests).set(__privateGet$2(this, _requestId$1), {
				resolve,
				reject,
				timeout: setTimeout(() => {
					__privateGet$2(this, _pendingRequests).delete(__privateGet$2(this, _requestId$1));
					reject(/* @__PURE__ */ new Error(`Request timeout: ${method}`));
				}, this.options.callTimeout)
			});
			signal?.addEventListener("abort", () => {
				__privateGet$2(this, _pendingRequests).delete(__privateGet$2(this, _requestId$1));
				reject(signal.reason);
			});
			webSocket.send(JSON.stringify({
				jsonrpc: "2.0",
				id: __privateGet$2(this, _requestId$1),
				method,
				params
			}));
		}).then(({ error, result }) => {
			if (error) throw new JsonRpcError(error.message, error.code);
			return result;
		});
	}
	async subscribe(input) {
		const subscription = new RpcSubscription(input);
		__privateGet$2(this, _subscriptions).add(subscription);
		await subscription.subscribe(this);
		return () => subscription.unsubscribe(this);
	}
};
_requestId$1 = /* @__PURE__ */ new WeakMap();
_disconnects = /* @__PURE__ */ new WeakMap();
_webSocket = /* @__PURE__ */ new WeakMap();
_connectionPromise = /* @__PURE__ */ new WeakMap();
_subscriptions = /* @__PURE__ */ new WeakMap();
_pendingRequests = /* @__PURE__ */ new WeakMap();
_WebsocketClient_instances = /* @__PURE__ */ new WeakSet();
setupWebSocket_fn = function() {
	if (__privateGet$2(this, _connectionPromise)) return __privateGet$2(this, _connectionPromise);
	__privateSet$2(this, _connectionPromise, new Promise((resolve) => {
		__privateGet$2(this, _webSocket)?.close();
		__privateSet$2(this, _webSocket, new this.options.WebSocketConstructor(this.endpoint));
		__privateGet$2(this, _webSocket).addEventListener("open", () => {
			__privateSet$2(this, _disconnects, 0);
			resolve(__privateGet$2(this, _webSocket));
		});
		__privateGet$2(this, _webSocket).addEventListener("close", () => {
			__privateWrapper(this, _disconnects)._++;
			if (__privateGet$2(this, _disconnects) <= this.options.maxReconnects) setTimeout(() => {
				__privateMethod$1(this, _WebsocketClient_instances, reconnect_fn).call(this);
			}, this.options.reconnectTimeout);
		});
		__privateGet$2(this, _webSocket).addEventListener("message", ({ data }) => {
			let json;
			try {
				json = JSON.parse(data);
			} catch (error) {
				console.error(new Error(`Failed to parse RPC message: ${data}`, { cause: error }));
				return;
			}
			if ("id" in json && json.id != null && __privateGet$2(this, _pendingRequests).has(json.id)) {
				const { resolve: resolve2, timeout } = __privateGet$2(this, _pendingRequests).get(json.id);
				clearTimeout(timeout);
				resolve2(json);
			} else if ("params" in json) {
				const { params } = json;
				__privateGet$2(this, _subscriptions).forEach((subscription) => {
					if (subscription.subscriptionId === params.subscription) {
						if (params.subscription === subscription.subscriptionId) subscription.onMessage(params.result);
					}
				});
			}
		});
	}));
	return __privateGet$2(this, _connectionPromise);
};
reconnect_fn = async function() {
	__privateGet$2(this, _webSocket)?.close();
	__privateSet$2(this, _connectionPromise, null);
	return Promise.allSettled([...__privateGet$2(this, _subscriptions)].map((subscription) => subscription.subscribe(this)));
};
var RpcSubscription = class {
	constructor(input) {
		this.subscriptionId = null;
		this.subscribed = false;
		this.input = input;
	}
	onMessage(message) {
		if (this.subscribed) this.input.onMessage(message);
	}
	async unsubscribe(client) {
		const { subscriptionId } = this;
		this.subscribed = false;
		if (subscriptionId == null) return false;
		this.subscriptionId = null;
		return client.makeRequest(this.input.unsubscribe, [subscriptionId]);
	}
	async subscribe(client) {
		this.subscriptionId = null;
		this.subscribed = true;
		const newSubscriptionId = await client.makeRequest(this.input.method, this.input.params, this.input.signal);
		if (this.subscribed) this.subscriptionId = newSubscriptionId;
	}
};

//#endregion
//#region node_modules/.pnpm/@mysten+sui@1.45.2_typescript@5.9.3/node_modules/@mysten/sui/dist/esm/jsonRpc/http-transport.js
var __typeError$1 = (msg) => {
	throw TypeError(msg);
};
var __accessCheck$1 = (obj, member, msg) => member.has(obj) || __typeError$1("Cannot " + msg);
var __privateGet$1 = (obj, member, getter) => (__accessCheck$1(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd$1 = (obj, member, value) => member.has(obj) ? __typeError$1("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet$1 = (obj, member, value, setter) => (__accessCheck$1(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod = (obj, member, method) => (__accessCheck$1(obj, member, "access private method"), method);
var _requestId, _options, _websocketClient, _JsonRpcHTTPTransport_instances, getWebsocketClient_fn;
var JsonRpcHTTPTransport = class {
	constructor(options) {
		__privateAdd$1(this, _JsonRpcHTTPTransport_instances);
		__privateAdd$1(this, _requestId, 0);
		__privateAdd$1(this, _options);
		__privateAdd$1(this, _websocketClient);
		__privateSet$1(this, _options, options);
	}
	fetch(input, init) {
		const fetchFn = __privateGet$1(this, _options).fetch ?? fetch;
		if (!fetchFn) throw new Error("The current environment does not support fetch, you can provide a fetch implementation in the options for SuiHTTPTransport.");
		return fetchFn(input, init);
	}
	async request(input) {
		__privateSet$1(this, _requestId, __privateGet$1(this, _requestId) + 1);
		const res = await this.fetch(__privateGet$1(this, _options).rpc?.url ?? __privateGet$1(this, _options).url, {
			method: "POST",
			signal: input.signal,
			headers: {
				"Content-Type": "application/json",
				"Client-Sdk-Type": "typescript",
				"Client-Sdk-Version": PACKAGE_VERSION,
				"Client-Target-Api-Version": TARGETED_RPC_VERSION,
				"Client-Request-Method": input.method,
				...__privateGet$1(this, _options).rpc?.headers
			},
			body: JSON.stringify({
				jsonrpc: "2.0",
				id: __privateGet$1(this, _requestId),
				method: input.method,
				params: input.params
			})
		});
		if (!res.ok) throw new SuiHTTPStatusError(`Unexpected status code: ${res.status}`, res.status, res.statusText);
		const data = await res.json();
		if ("error" in data && data.error != null) throw new JsonRpcError(data.error.message, data.error.code);
		return data.result;
	}
	async subscribe(input) {
		const unsubscribe = await __privateMethod(this, _JsonRpcHTTPTransport_instances, getWebsocketClient_fn).call(this).subscribe(input);
		if (input.signal) {
			input.signal.throwIfAborted();
			input.signal.addEventListener("abort", () => {
				unsubscribe();
			});
		}
		return async () => !!await unsubscribe();
	}
};
_requestId = /* @__PURE__ */ new WeakMap();
_options = /* @__PURE__ */ new WeakMap();
_websocketClient = /* @__PURE__ */ new WeakMap();
_JsonRpcHTTPTransport_instances = /* @__PURE__ */ new WeakSet();
getWebsocketClient_fn = function() {
	if (!__privateGet$1(this, _websocketClient)) {
		const WebSocketConstructor = __privateGet$1(this, _options).WebSocketConstructor ?? WebSocket;
		if (!WebSocketConstructor) throw new Error("The current environment does not support WebSocket, you can provide a WebSocketConstructor in the options for SuiHTTPTransport.");
		__privateSet$1(this, _websocketClient, new WebsocketClient(__privateGet$1(this, _options).websocket?.url ?? __privateGet$1(this, _options).url, {
			WebSocketConstructor,
			...__privateGet$1(this, _options).websocket
		}));
	}
	return __privateGet$1(this, _websocketClient);
};

//#endregion
//#region node_modules/.pnpm/@mysten+sui@1.45.2_typescript@5.9.3/node_modules/@mysten/sui/dist/esm/client/network.js
function getFullnodeUrl(network) {
	switch (network) {
		case "mainnet": return "https://fullnode.mainnet.sui.io:443";
		case "testnet": return "https://fullnode.testnet.sui.io:443";
		case "devnet": return "https://fullnode.devnet.sui.io:443";
		case "localnet": return "http://127.0.0.1:9000";
		default: throw new Error(`Unknown network: ${network}`);
	}
}

//#endregion
//#region node_modules/.pnpm/@mysten+sui@1.45.2_typescript@5.9.3/node_modules/@mysten/sui/dist/esm/experimental/client.js
var Experimental_BaseClient = class {
	constructor({ network, base, cache = base?.cache ?? new ClientCache() }) {
		this.network = network;
		this.base = base ?? this;
		this.cache = cache;
	}
	$extend(...registrations) {
		return Object.create(this, Object.fromEntries(registrations.map((registration) => {
			return [registration.name, { value: registration.register(this) }];
		})));
	}
};

//#endregion
//#region node_modules/.pnpm/@mysten+sui@1.45.2_typescript@5.9.3/node_modules/@mysten/sui/dist/esm/experimental/core.js
var DEFAULT_MVR_URLS = {
	mainnet: "https://mainnet.mvr.mystenlabs.com",
	testnet: "https://testnet.mvr.mystenlabs.com"
};
var Experimental_CoreClient = class extends Experimental_BaseClient {
	constructor(options) {
		super(options);
		this.core = this;
		this.mvr = new MvrClient({
			cache: this.cache.scope("core.mvr"),
			url: options.mvr?.url ?? DEFAULT_MVR_URLS[this.network],
			pageSize: options.mvr?.pageSize,
			overrides: options.mvr?.overrides
		});
	}
	async getObject(options) {
		const { objectId } = options;
		const { objects: [result] } = await this.getObjects({
			objectIds: [objectId],
			signal: options.signal
		});
		if (result instanceof Error) throw result;
		return { object: result };
	}
	async getDynamicField(options) {
		const normalizedNameType = TypeTagSerializer.parseFromStr((await this.core.mvr.resolveType({ type: options.name.type })).type);
		const fieldId = deriveDynamicFieldID(options.parentId, normalizedNameType, options.name.bcs);
		const { objects: [fieldObject] } = await this.getObjects({
			objectIds: [fieldId],
			signal: options.signal
		});
		if (fieldObject instanceof Error) throw fieldObject;
		const fieldType = parseStructTag(fieldObject.type);
		const content = await fieldObject.content;
		return { dynamicField: {
			id: fieldObject.id,
			digest: fieldObject.digest,
			version: fieldObject.version,
			type: fieldObject.type,
			previousTransaction: fieldObject.previousTransaction,
			name: {
				type: typeof fieldType.typeParams[0] === "string" ? fieldType.typeParams[0] : normalizeStructTag(fieldType.typeParams[0]),
				bcs: options.name.bcs
			},
			value: {
				type: typeof fieldType.typeParams[1] === "string" ? fieldType.typeParams[1] : normalizeStructTag(fieldType.typeParams[1]),
				bcs: content.slice(SUI_ADDRESS_LENGTH + options.name.bcs.length)
			}
		} };
	}
	async waitForTransaction({ signal, timeout = 60 * 1e3, ...input }) {
		const abortSignal = signal ? AbortSignal.any([AbortSignal.timeout(timeout), signal]) : AbortSignal.timeout(timeout);
		const abortPromise = new Promise((_, reject) => {
			abortSignal.addEventListener("abort", () => reject(abortSignal.reason));
		});
		abortPromise.catch(() => {});
		while (true) {
			abortSignal.throwIfAborted();
			try {
				return await this.getTransaction({
					...input,
					signal: abortSignal
				});
			} catch {
				await Promise.race([new Promise((resolve) => setTimeout(resolve, 2e3)), abortPromise]);
			}
		}
	}
};

//#endregion
//#region node_modules/.pnpm/@mysten+sui@1.45.2_typescript@5.9.3/node_modules/@mysten/sui/dist/esm/experimental/errors.js
var SuiClientError = class extends Error {};
var ObjectError = class ObjectError extends SuiClientError {
	constructor(code, message) {
		super(message);
		this.code = code;
	}
	static fromResponse(response, objectId) {
		switch (response.code) {
			case "notExists": return new ObjectError(response.code, `Object ${response.object_id} does not exist`);
			case "dynamicFieldNotFound": return new ObjectError(response.code, `Dynamic field not found for object ${response.parent_object_id}`);
			case "deleted": return new ObjectError(response.code, `Object ${response.object_id} has been deleted`);
			case "displayError": return new ObjectError(response.code, `Display error: ${response.error}`);
			case "unknown":
			default: return new ObjectError(response.code, `Unknown error while loading object${objectId ? ` ${objectId}` : ""}`);
		}
	}
};

//#endregion
//#region node_modules/.pnpm/@mysten+sui@1.45.2_typescript@5.9.3/node_modules/@mysten/sui/dist/esm/experimental/transports/utils.js
function parseTransactionBcs(bytes) {
	return {
		...TransactionDataBuilder.fromBytes(bytes).snapshot(),
		bcs: bytes
	};
}
function parseTransactionEffectsBcs(effects) {
	const parsed = suiBcs.TransactionEffects.parse(effects);
	switch (parsed.$kind) {
		case "V1": return parseTransactionEffectsV1({
			bytes: effects,
			effects: parsed.V1
		});
		case "V2": return parseTransactionEffectsV2({
			bytes: effects,
			effects: parsed.V2
		});
		default: throw new Error(`Unknown transaction effects version: ${parsed.$kind}`);
	}
}
function parseTransactionEffectsV1(_) {
	throw new Error("V1 effects are not supported yet");
}
function parseTransactionEffectsV2({ bytes, effects }) {
	const changedObjects = effects.changedObjects.map(([id, change]) => {
		return {
			id,
			inputState: change.inputState.$kind === "Exist" ? "Exists" : "DoesNotExist",
			inputVersion: change.inputState.Exist?.[0][0] ?? null,
			inputDigest: change.inputState.Exist?.[0][1] ?? null,
			inputOwner: change.inputState.Exist?.[1] ?? null,
			outputState: change.outputState.$kind === "NotExist" ? "DoesNotExist" : change.outputState.$kind,
			outputVersion: change.outputState.$kind === "PackageWrite" ? change.outputState.PackageWrite?.[0] : change.outputState.ObjectWrite ? effects.lamportVersion : null,
			outputDigest: change.outputState.$kind === "PackageWrite" ? change.outputState.PackageWrite?.[1] : change.outputState.ObjectWrite?.[0] ?? null,
			outputOwner: change.outputState.ObjectWrite ? change.outputState.ObjectWrite[1] : null,
			idOperation: change.idOperation.$kind
		};
	});
	return {
		bcs: bytes,
		digest: effects.transactionDigest,
		version: 2,
		status: effects.status.$kind === "Success" ? {
			success: true,
			error: null
		} : {
			success: false,
			error: effects.status.Failed.error.$kind
		},
		gasUsed: effects.gasUsed,
		transactionDigest: effects.transactionDigest,
		gasObject: effects.gasObjectIndex === null ? null : changedObjects[effects.gasObjectIndex] ?? null,
		eventsDigest: effects.eventsDigest,
		dependencies: effects.dependencies,
		lamportVersion: effects.lamportVersion,
		changedObjects,
		unchangedConsensusObjects: effects.unchangedSharedObjects.map(([objectId, object]) => {
			return {
				kind: object.$kind === "MutateDeleted" ? "MutateConsensusStreamEnded" : object.$kind === "ReadDeleted" ? "ReadConsensusStreamEnded" : object.$kind,
				objectId,
				version: object.$kind === "ReadOnlyRoot" ? object.ReadOnlyRoot[0] : object[object.$kind],
				digest: object.$kind === "ReadOnlyRoot" ? object.ReadOnlyRoot[1] : null
			};
		}),
		auxiliaryDataDigest: effects.auxDataDigest
	};
}

//#endregion
//#region node_modules/.pnpm/@mysten+sui@1.45.2_typescript@5.9.3/node_modules/@mysten/sui/dist/esm/jsonRpc/core.js
var __typeError = (msg) => {
	throw TypeError(msg);
};
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var _jsonRpcClient;
var JSONRpcCoreClient = class extends Experimental_CoreClient {
	constructor({ jsonRpcClient, mvr }) {
		super({
			network: jsonRpcClient.network,
			base: jsonRpcClient,
			mvr
		});
		__privateAdd(this, _jsonRpcClient);
		__privateSet(this, _jsonRpcClient, jsonRpcClient);
	}
	async getObjects(options) {
		const batches = chunk(options.objectIds, 50);
		const results = [];
		for (const batch of batches) {
			const objects = await __privateGet(this, _jsonRpcClient).multiGetObjects({
				ids: batch,
				options: {
					showOwner: true,
					showType: true,
					showBcs: true,
					showPreviousTransaction: true
				},
				signal: options.signal
			});
			for (const [idx, object] of objects.entries()) if (object.error) results.push(ObjectError.fromResponse(object.error, batch[idx]));
			else results.push(parseObject(object.data));
		}
		return { objects: results };
	}
	async getOwnedObjects(options) {
		const objects = await __privateGet(this, _jsonRpcClient).getOwnedObjects({
			owner: options.address,
			limit: options.limit,
			cursor: options.cursor,
			options: {
				showOwner: true,
				showType: true,
				showBcs: true,
				showPreviousTransaction: true
			},
			filter: options.type ? { StructType: options.type } : null,
			signal: options.signal
		});
		return {
			objects: objects.data.map((result) => {
				if (result.error) throw ObjectError.fromResponse(result.error);
				return parseObject(result.data);
			}),
			hasNextPage: objects.hasNextPage,
			cursor: objects.nextCursor ?? null
		};
	}
	async getCoins(options) {
		const coins = await __privateGet(this, _jsonRpcClient).getCoins({
			owner: options.address,
			coinType: options.coinType,
			limit: options.limit,
			cursor: options.cursor,
			signal: options.signal
		});
		return {
			objects: coins.data.map((coin) => {
				return {
					id: coin.coinObjectId,
					version: coin.version,
					digest: coin.digest,
					balance: coin.balance,
					type: `0x2::coin::Coin<${coin.coinType}>`,
					content: Promise.resolve(Coin.serialize({
						id: coin.coinObjectId,
						balance: { value: coin.balance }
					}).toBytes()),
					owner: {
						$kind: "ObjectOwner",
						ObjectOwner: options.address
					},
					previousTransaction: coin.previousTransaction
				};
			}),
			hasNextPage: coins.hasNextPage,
			cursor: coins.nextCursor ?? null
		};
	}
	async getBalance(options) {
		const balance = await __privateGet(this, _jsonRpcClient).getBalance({
			owner: options.address,
			coinType: options.coinType,
			signal: options.signal
		});
		return { balance: {
			coinType: balance.coinType,
			balance: balance.totalBalance
		} };
	}
	async getAllBalances(options) {
		return {
			balances: (await __privateGet(this, _jsonRpcClient).getAllBalances({
				owner: options.address,
				signal: options.signal
			})).map((balance) => ({
				coinType: balance.coinType,
				balance: balance.totalBalance
			})),
			hasNextPage: false,
			cursor: null
		};
	}
	async getTransaction(options) {
		return { transaction: parseTransaction(await __privateGet(this, _jsonRpcClient).getTransactionBlock({
			digest: options.digest,
			options: {
				showRawInput: true,
				showObjectChanges: true,
				showRawEffects: true,
				showEvents: true,
				showEffects: true,
				showBalanceChanges: true
			},
			signal: options.signal
		})) };
	}
	async executeTransaction(options) {
		return { transaction: parseTransaction(await __privateGet(this, _jsonRpcClient).executeTransactionBlock({
			transactionBlock: options.transaction,
			signature: options.signatures,
			options: {
				showRawEffects: true,
				showEvents: true,
				showObjectChanges: true,
				showRawInput: true,
				showEffects: true,
				showBalanceChanges: true
			},
			signal: options.signal
		})) };
	}
	async dryRunTransaction(options) {
		const tx = Transaction.from(options.transaction);
		const result = await __privateGet(this, _jsonRpcClient).dryRunTransactionBlock({
			transactionBlock: options.transaction,
			signal: options.signal
		});
		const { effects, objectTypes } = parseTransactionEffectsJson({
			effects: result.effects,
			objectChanges: result.objectChanges
		});
		return { transaction: {
			digest: await tx.getDigest(),
			epoch: null,
			effects,
			objectTypes: Promise.resolve(objectTypes),
			signatures: [],
			transaction: parseTransactionBcs(options.transaction),
			balanceChanges: result.balanceChanges.map((change) => ({
				coinType: change.coinType,
				address: parseOwnerAddress(change.owner),
				amount: change.amount
			}))
		} };
	}
	async getReferenceGasPrice(options) {
		const referenceGasPrice = await __privateGet(this, _jsonRpcClient).getReferenceGasPrice({ signal: options?.signal });
		return { referenceGasPrice: String(referenceGasPrice) };
	}
	async getDynamicFields(options) {
		const dynamicFields = await __privateGet(this, _jsonRpcClient).getDynamicFields({
			parentId: options.parentId,
			limit: options.limit,
			cursor: options.cursor
		});
		return {
			dynamicFields: dynamicFields.data.map((dynamicField) => {
				return {
					id: dynamicField.objectId,
					type: dynamicField.objectType,
					name: {
						type: dynamicField.name.type,
						bcs: fromBase64(dynamicField.bcsName)
					}
				};
			}),
			hasNextPage: dynamicFields.hasNextPage,
			cursor: dynamicFields.nextCursor
		};
	}
	async verifyZkLoginSignature(options) {
		const result = await __privateGet(this, _jsonRpcClient).verifyZkLoginSignature({
			bytes: options.bytes,
			signature: options.signature,
			intentScope: options.intentScope,
			author: options.author
		});
		return {
			success: result.success,
			errors: result.errors
		};
	}
	async defaultNameServiceName(options) {
		return { data: { name: (await __privateGet(this, _jsonRpcClient).resolveNameServiceNames(options)).data[0] } };
	}
	resolveTransactionPlugin() {
		return jsonRpcClientResolveTransactionPlugin(__privateGet(this, _jsonRpcClient));
	}
	async getMoveFunction(options) {
		const result = await __privateGet(this, _jsonRpcClient).getNormalizedMoveFunction({
			package: (await this.mvr.resolvePackage({ package: options.packageId })).package,
			module: options.moduleName,
			function: options.name
		});
		return { function: {
			packageId: normalizeSuiAddress(options.packageId),
			moduleName: options.moduleName,
			name: options.name,
			visibility: parseVisibility(result.visibility),
			isEntry: result.isEntry,
			typeParameters: result.typeParameters.map((abilities) => ({
				isPhantom: false,
				constraints: parseAbilities(abilities)
			})),
			parameters: result.parameters.map((param) => parseNormalizedSuiMoveType(param)),
			returns: result.return.map((ret) => parseNormalizedSuiMoveType(ret))
		} };
	}
};
_jsonRpcClient = /* @__PURE__ */ new WeakMap();
function parseObject(object) {
	return {
		id: object.objectId,
		version: object.version,
		digest: object.digest,
		type: object.type,
		content: Promise.resolve(object.bcs?.dataType === "moveObject" ? fromBase64(object.bcs.bcsBytes) : new Uint8Array()),
		owner: parseOwner(object.owner),
		previousTransaction: object.previousTransaction ?? null
	};
}
function parseOwner(owner) {
	if (owner === "Immutable") return {
		$kind: "Immutable",
		Immutable: true
	};
	if ("ConsensusAddressOwner" in owner) return {
		$kind: "ConsensusAddressOwner",
		ConsensusAddressOwner: {
			owner: owner.ConsensusAddressOwner.owner,
			startVersion: owner.ConsensusAddressOwner.start_version
		}
	};
	if ("AddressOwner" in owner) return {
		$kind: "AddressOwner",
		AddressOwner: owner.AddressOwner
	};
	if ("ObjectOwner" in owner) return {
		$kind: "ObjectOwner",
		ObjectOwner: owner.ObjectOwner
	};
	if ("Shared" in owner) return {
		$kind: "Shared",
		Shared: { initialSharedVersion: owner.Shared.initial_shared_version }
	};
	throw new Error(`Unknown owner type: ${JSON.stringify(owner)}`);
}
function parseOwnerAddress(owner) {
	if (owner === "Immutable") return null;
	if ("ConsensusAddressOwner" in owner) return owner.ConsensusAddressOwner.owner;
	if ("AddressOwner" in owner) return owner.AddressOwner;
	if ("ObjectOwner" in owner) return owner.ObjectOwner;
	if ("Shared" in owner) return null;
	throw new Error(`Unknown owner type: ${JSON.stringify(owner)}`);
}
function parseTransaction(transaction) {
	const parsedTx = suiBcs.SenderSignedData.parse(fromBase64(transaction.rawTransaction))[0];
	const objectTypes = {};
	transaction.objectChanges?.forEach((change) => {
		if (change.type !== "published") objectTypes[change.objectId] = change.objectType;
	});
	const bytes = suiBcs.TransactionData.serialize(parsedTx.intentMessage.value).toBytes();
	const data = TransactionDataBuilder.restore({
		version: 2,
		sender: parsedTx.intentMessage.value.V1.sender,
		expiration: parsedTx.intentMessage.value.V1.expiration,
		gasData: parsedTx.intentMessage.value.V1.gasData,
		inputs: parsedTx.intentMessage.value.V1.kind.ProgrammableTransaction.inputs,
		commands: parsedTx.intentMessage.value.V1.kind.ProgrammableTransaction.commands
	});
	return {
		digest: transaction.digest,
		epoch: transaction.effects?.executedEpoch ?? null,
		effects: parseTransactionEffectsBcs(new Uint8Array(transaction.rawEffects)),
		objectTypes: Promise.resolve(objectTypes),
		transaction: {
			...data,
			bcs: bytes
		},
		signatures: parsedTx.txSignatures,
		balanceChanges: transaction.balanceChanges?.map((change) => ({
			coinType: change.coinType,
			address: parseOwnerAddress(change.owner),
			amount: change.amount
		})) ?? []
	};
}
function parseTransactionEffectsJson({ bytes, effects, objectChanges }) {
	const changedObjects = [];
	const unchangedConsensusObjects = [];
	const objectTypes = {};
	objectChanges?.forEach((change) => {
		switch (change.type) {
			case "published":
				changedObjects.push({
					id: change.packageId,
					inputState: "DoesNotExist",
					inputVersion: null,
					inputDigest: null,
					inputOwner: null,
					outputState: "PackageWrite",
					outputVersion: change.version,
					outputDigest: change.digest,
					outputOwner: null,
					idOperation: "Created"
				});
				break;
			case "transferred":
				changedObjects.push({
					id: change.objectId,
					inputState: "Exists",
					inputVersion: change.version,
					inputDigest: change.digest,
					inputOwner: {
						$kind: "AddressOwner",
						AddressOwner: change.sender
					},
					outputState: "ObjectWrite",
					outputVersion: change.version,
					outputDigest: change.digest,
					outputOwner: parseOwner(change.recipient),
					idOperation: "None"
				});
				objectTypes[change.objectId] = change.objectType;
				break;
			case "mutated":
				changedObjects.push({
					id: change.objectId,
					inputState: "Exists",
					inputVersion: change.previousVersion,
					inputDigest: null,
					inputOwner: parseOwner(change.owner),
					outputState: "ObjectWrite",
					outputVersion: change.version,
					outputDigest: change.digest,
					outputOwner: parseOwner(change.owner),
					idOperation: "None"
				});
				objectTypes[change.objectId] = change.objectType;
				break;
			case "deleted":
				changedObjects.push({
					id: change.objectId,
					inputState: "Exists",
					inputVersion: change.version,
					inputDigest: effects.deleted?.find((d) => d.objectId === change.objectId)?.digest ?? null,
					inputOwner: null,
					outputState: "DoesNotExist",
					outputVersion: null,
					outputDigest: null,
					outputOwner: null,
					idOperation: "Deleted"
				});
				objectTypes[change.objectId] = change.objectType;
				break;
			case "wrapped":
				changedObjects.push({
					id: change.objectId,
					inputState: "Exists",
					inputVersion: change.version,
					inputDigest: null,
					inputOwner: {
						$kind: "AddressOwner",
						AddressOwner: change.sender
					},
					outputState: "ObjectWrite",
					outputVersion: change.version,
					outputDigest: effects.wrapped?.find((w) => w.objectId === change.objectId)?.digest ?? null,
					outputOwner: {
						$kind: "ObjectOwner",
						ObjectOwner: change.sender
					},
					idOperation: "None"
				});
				objectTypes[change.objectId] = change.objectType;
				break;
			case "created":
				changedObjects.push({
					id: change.objectId,
					inputState: "DoesNotExist",
					inputVersion: null,
					inputDigest: null,
					inputOwner: null,
					outputState: "ObjectWrite",
					outputVersion: change.version,
					outputDigest: change.digest,
					outputOwner: parseOwner(change.owner),
					idOperation: "Created"
				});
				objectTypes[change.objectId] = change.objectType;
				break;
		}
	});
	return {
		objectTypes,
		effects: {
			bcs: bytes ?? null,
			digest: effects.transactionDigest,
			version: 2,
			status: effects.status.status === "success" ? {
				success: true,
				error: null
			} : {
				success: false,
				error: effects.status.error
			},
			gasUsed: effects.gasUsed,
			transactionDigest: effects.transactionDigest,
			gasObject: {
				id: effects.gasObject?.reference.objectId,
				inputState: "Exists",
				inputVersion: null,
				inputDigest: null,
				inputOwner: null,
				outputState: "ObjectWrite",
				outputVersion: effects.gasObject.reference.version,
				outputDigest: effects.gasObject.reference.digest,
				outputOwner: parseOwner(effects.gasObject.owner),
				idOperation: "None"
			},
			eventsDigest: effects.eventsDigest ?? null,
			dependencies: effects.dependencies ?? [],
			lamportVersion: effects.gasObject.reference.version,
			changedObjects,
			unchangedConsensusObjects,
			auxiliaryDataDigest: null
		}
	};
}
var Balance = suiBcs.struct("Balance", { value: suiBcs.u64() });
var Coin = suiBcs.struct("Coin", {
	id: suiBcs.Address,
	balance: Balance
});
function parseNormalizedSuiMoveType(type) {
	if (typeof type !== "string") {
		if ("Reference" in type) return {
			reference: "immutable",
			body: parseNormalizedSuiMoveTypeBody(type.Reference)
		};
		if ("MutableReference" in type) return {
			reference: "mutable",
			body: parseNormalizedSuiMoveTypeBody(type.MutableReference)
		};
	}
	return {
		reference: null,
		body: parseNormalizedSuiMoveTypeBody(type)
	};
}
function parseNormalizedSuiMoveTypeBody(type) {
	switch (type) {
		case "Address": return { $kind: "address" };
		case "Bool": return { $kind: "bool" };
		case "U8": return { $kind: "u8" };
		case "U16": return { $kind: "u16" };
		case "U32": return { $kind: "u32" };
		case "U64": return { $kind: "u64" };
		case "U128": return { $kind: "u128" };
		case "U256": return { $kind: "u256" };
	}
	if (typeof type === "string") throw new Error(`Unknown type: ${type}`);
	if ("Vector" in type) return {
		$kind: "vector",
		vector: parseNormalizedSuiMoveTypeBody(type.Vector)
	};
	if ("Struct" in type) return {
		$kind: "datatype",
		datatype: {
			typeName: `${normalizeSuiAddress(type.Struct.address)}::${type.Struct.module}::${type.Struct.name}`,
			typeParameters: type.Struct.typeArguments.map((t) => parseNormalizedSuiMoveTypeBody(t))
		}
	};
	if ("TypeParameter" in type) return {
		$kind: "typeParameter",
		index: type.TypeParameter
	};
	throw new Error(`Unknown type: ${JSON.stringify(type)}`);
}
function parseAbilities(abilitySet) {
	return abilitySet.abilities.map((ability) => {
		switch (ability) {
			case "Copy": return "copy";
			case "Drop": return "drop";
			case "Store": return "store";
			case "Key": return "key";
			default: return "unknown";
		}
	});
}
function parseVisibility(visibility) {
	switch (visibility) {
		case "Public": return "public";
		case "Private": return "private";
		case "Friend": return "friend";
		default: return "unknown";
	}
}

//#endregion
//#region node_modules/.pnpm/@mysten+sui@1.45.2_typescript@5.9.3/node_modules/@mysten/sui/dist/esm/jsonRpc/client.js
var SUI_CLIENT_BRAND = Symbol.for("@mysten/SuiClient");
function isSuiJsonRpcClient(client) {
	return typeof client === "object" && client !== null && client[SUI_CLIENT_BRAND] === true;
}
var SuiJsonRpcClient = class extends Experimental_BaseClient {
	/**
	* Establish a connection to a Sui RPC endpoint
	*
	* @param options configuration options for the API Client
	*/
	constructor(options) {
		super({ network: options.network ?? "unknown" });
		this.jsonRpc = this;
		this.transport = options.transport ?? new JsonRpcHTTPTransport({ url: options.url });
		this.core = new JSONRpcCoreClient({
			jsonRpcClient: this,
			mvr: options.mvr
		});
	}
	get [SUI_CLIENT_BRAND]() {
		return true;
	}
	async getRpcApiVersion({ signal } = {}) {
		return (await this.transport.request({
			method: "rpc.discover",
			params: [],
			signal
		})).info.version;
	}
	/**
	* Get all Coin<`coin_type`> objects owned by an address.
	*/
	async getCoins({ coinType, owner, cursor, limit, signal }) {
		if (!owner || !isValidSuiAddress(normalizeSuiAddress(owner))) throw new Error("Invalid Sui address");
		if (coinType && hasMvrName(coinType)) coinType = (await this.core.mvr.resolveType({ type: coinType })).type;
		return await this.transport.request({
			method: "suix_getCoins",
			params: [
				owner,
				coinType,
				cursor,
				limit
			],
			signal
		});
	}
	/**
	* Get all Coin objects owned by an address.
	*/
	async getAllCoins(input) {
		if (!input.owner || !isValidSuiAddress(normalizeSuiAddress(input.owner))) throw new Error("Invalid Sui address");
		return await this.transport.request({
			method: "suix_getAllCoins",
			params: [
				input.owner,
				input.cursor,
				input.limit
			],
			signal: input.signal
		});
	}
	/**
	* Get the total coin balance for one coin type, owned by the address owner.
	*/
	async getBalance({ owner, coinType, signal }) {
		if (!owner || !isValidSuiAddress(normalizeSuiAddress(owner))) throw new Error("Invalid Sui address");
		if (coinType && hasMvrName(coinType)) coinType = (await this.core.mvr.resolveType({ type: coinType })).type;
		return await this.transport.request({
			method: "suix_getBalance",
			params: [owner, coinType],
			signal
		});
	}
	/**
	* Get the total coin balance for all coin types, owned by the address owner.
	*/
	async getAllBalances(input) {
		if (!input.owner || !isValidSuiAddress(normalizeSuiAddress(input.owner))) throw new Error("Invalid Sui address");
		return await this.transport.request({
			method: "suix_getAllBalances",
			params: [input.owner],
			signal: input.signal
		});
	}
	/**
	* Fetch CoinMetadata for a given coin type
	*/
	async getCoinMetadata({ coinType, signal }) {
		if (coinType && hasMvrName(coinType)) coinType = (await this.core.mvr.resolveType({ type: coinType })).type;
		return await this.transport.request({
			method: "suix_getCoinMetadata",
			params: [coinType],
			signal
		});
	}
	/**
	*  Fetch total supply for a coin
	*/
	async getTotalSupply({ coinType, signal }) {
		if (coinType && hasMvrName(coinType)) coinType = (await this.core.mvr.resolveType({ type: coinType })).type;
		return await this.transport.request({
			method: "suix_getTotalSupply",
			params: [coinType],
			signal
		});
	}
	/**
	* Invoke any RPC method
	* @param method the method to be invoked
	* @param args the arguments to be passed to the RPC request
	*/
	async call(method, params, { signal } = {}) {
		return await this.transport.request({
			method,
			params,
			signal
		});
	}
	/**
	* Get Move function argument types like read, write and full access
	*/
	async getMoveFunctionArgTypes({ package: pkg, module, function: fn, signal }) {
		if (pkg && isValidNamedPackage(pkg)) pkg = (await this.core.mvr.resolvePackage({ package: pkg })).package;
		return await this.transport.request({
			method: "sui_getMoveFunctionArgTypes",
			params: [
				pkg,
				module,
				fn
			],
			signal
		});
	}
	/**
	* Get a map from module name to
	* structured representations of Move modules
	*/
	async getNormalizedMoveModulesByPackage({ package: pkg, signal }) {
		if (pkg && isValidNamedPackage(pkg)) pkg = (await this.core.mvr.resolvePackage({ package: pkg })).package;
		return await this.transport.request({
			method: "sui_getNormalizedMoveModulesByPackage",
			params: [pkg],
			signal
		});
	}
	/**
	* Get a structured representation of Move module
	*/
	async getNormalizedMoveModule({ package: pkg, module, signal }) {
		if (pkg && isValidNamedPackage(pkg)) pkg = (await this.core.mvr.resolvePackage({ package: pkg })).package;
		return await this.transport.request({
			method: "sui_getNormalizedMoveModule",
			params: [pkg, module],
			signal
		});
	}
	/**
	* Get a structured representation of Move function
	*/
	async getNormalizedMoveFunction({ package: pkg, module, function: fn, signal }) {
		if (pkg && isValidNamedPackage(pkg)) pkg = (await this.core.mvr.resolvePackage({ package: pkg })).package;
		return await this.transport.request({
			method: "sui_getNormalizedMoveFunction",
			params: [
				pkg,
				module,
				fn
			],
			signal
		});
	}
	/**
	* Get a structured representation of Move struct
	*/
	async getNormalizedMoveStruct({ package: pkg, module, struct, signal }) {
		if (pkg && isValidNamedPackage(pkg)) pkg = (await this.core.mvr.resolvePackage({ package: pkg })).package;
		return await this.transport.request({
			method: "sui_getNormalizedMoveStruct",
			params: [
				pkg,
				module,
				struct
			],
			signal
		});
	}
	/**
	* Get all objects owned by an address
	*/
	async getOwnedObjects(input) {
		if (!input.owner || !isValidSuiAddress(normalizeSuiAddress(input.owner))) throw new Error("Invalid Sui address");
		const filter = input.filter ? { ...input.filter } : void 0;
		if (filter && "MoveModule" in filter && isValidNamedPackage(filter.MoveModule.package)) filter.MoveModule = {
			module: filter.MoveModule.module,
			package: (await this.core.mvr.resolvePackage({ package: filter.MoveModule.package })).package
		};
		else if (filter && "StructType" in filter && hasMvrName(filter.StructType)) filter.StructType = (await this.core.mvr.resolveType({ type: filter.StructType })).type;
		return await this.transport.request({
			method: "suix_getOwnedObjects",
			params: [
				input.owner,
				{
					filter,
					options: input.options
				},
				input.cursor,
				input.limit
			],
			signal: input.signal
		});
	}
	/**
	* Get details about an object
	*/
	async getObject(input) {
		if (!input.id || !isValidSuiObjectId(normalizeSuiObjectId(input.id))) throw new Error("Invalid Sui Object id");
		return await this.transport.request({
			method: "sui_getObject",
			params: [input.id, input.options],
			signal: input.signal
		});
	}
	async tryGetPastObject(input) {
		return await this.transport.request({
			method: "sui_tryGetPastObject",
			params: [
				input.id,
				input.version,
				input.options
			],
			signal: input.signal
		});
	}
	/**
	* Batch get details about a list of objects. If any of the object ids are duplicates the call will fail
	*/
	async multiGetObjects(input) {
		input.ids.forEach((id) => {
			if (!id || !isValidSuiObjectId(normalizeSuiObjectId(id))) throw new Error(`Invalid Sui Object id ${id}`);
		});
		if (input.ids.length !== new Set(input.ids).size) throw new Error(`Duplicate object ids in batch call ${input.ids}`);
		return await this.transport.request({
			method: "sui_multiGetObjects",
			params: [input.ids, input.options],
			signal: input.signal
		});
	}
	/**
	* Get transaction blocks for a given query criteria
	*/
	async queryTransactionBlocks({ filter, options, cursor, limit, order, signal }) {
		if (filter && "MoveFunction" in filter && isValidNamedPackage(filter.MoveFunction.package)) filter = {
			...filter,
			MoveFunction: { package: (await this.core.mvr.resolvePackage({ package: filter.MoveFunction.package })).package }
		};
		return await this.transport.request({
			method: "suix_queryTransactionBlocks",
			params: [
				{
					filter,
					options
				},
				cursor,
				limit,
				(order || "descending") === "descending"
			],
			signal
		});
	}
	async getTransactionBlock(input) {
		if (!isValidTransactionDigest(input.digest)) throw new Error("Invalid Transaction digest");
		return await this.transport.request({
			method: "sui_getTransactionBlock",
			params: [input.digest, input.options],
			signal: input.signal
		});
	}
	async multiGetTransactionBlocks(input) {
		input.digests.forEach((d) => {
			if (!isValidTransactionDigest(d)) throw new Error(`Invalid Transaction digest ${d}`);
		});
		if (input.digests.length !== new Set(input.digests).size) throw new Error(`Duplicate digests in batch call ${input.digests}`);
		return await this.transport.request({
			method: "sui_multiGetTransactionBlocks",
			params: [input.digests, input.options],
			signal: input.signal
		});
	}
	async executeTransactionBlock({ transactionBlock, signature, options, requestType, signal }) {
		const result = await this.transport.request({
			method: "sui_executeTransactionBlock",
			params: [
				typeof transactionBlock === "string" ? transactionBlock : toBase64(transactionBlock),
				Array.isArray(signature) ? signature : [signature],
				options
			],
			signal
		});
		if (requestType === "WaitForLocalExecution") try {
			await this.waitForTransaction({ digest: result.digest });
		} catch {}
		return result;
	}
	async signAndExecuteTransaction({ transaction, signer, ...input }) {
		let transactionBytes;
		if (transaction instanceof Uint8Array) transactionBytes = transaction;
		else {
			transaction.setSenderIfNotSet(signer.toSuiAddress());
			transactionBytes = await transaction.build({ client: this });
		}
		const { signature, bytes } = await signer.signTransaction(transactionBytes);
		return this.executeTransactionBlock({
			transactionBlock: bytes,
			signature,
			...input
		});
	}
	/**
	* Get total number of transactions
	*/
	async getTotalTransactionBlocks({ signal } = {}) {
		const resp = await this.transport.request({
			method: "sui_getTotalTransactionBlocks",
			params: [],
			signal
		});
		return BigInt(resp);
	}
	/**
	* Getting the reference gas price for the network
	*/
	async getReferenceGasPrice({ signal } = {}) {
		const resp = await this.transport.request({
			method: "suix_getReferenceGasPrice",
			params: [],
			signal
		});
		return BigInt(resp);
	}
	/**
	* Return the delegated stakes for an address
	*/
	async getStakes(input) {
		if (!input.owner || !isValidSuiAddress(normalizeSuiAddress(input.owner))) throw new Error("Invalid Sui address");
		return await this.transport.request({
			method: "suix_getStakes",
			params: [input.owner],
			signal: input.signal
		});
	}
	/**
	* Return the delegated stakes queried by id.
	*/
	async getStakesByIds(input) {
		input.stakedSuiIds.forEach((id) => {
			if (!id || !isValidSuiObjectId(normalizeSuiObjectId(id))) throw new Error(`Invalid Sui Stake id ${id}`);
		});
		return await this.transport.request({
			method: "suix_getStakesByIds",
			params: [input.stakedSuiIds],
			signal: input.signal
		});
	}
	/**
	* Return the latest system state content.
	*/
	async getLatestSuiSystemState({ signal } = {}) {
		return await this.transport.request({
			method: "suix_getLatestSuiSystemState",
			params: [],
			signal
		});
	}
	/**
	* Get events for a given query criteria
	*/
	async queryEvents({ query, cursor, limit, order, signal }) {
		if (query && "MoveEventType" in query && hasMvrName(query.MoveEventType)) query = {
			...query,
			MoveEventType: (await this.core.mvr.resolveType({ type: query.MoveEventType })).type
		};
		if (query && "MoveEventModule" in query && isValidNamedPackage(query.MoveEventModule.package)) query = {
			...query,
			MoveEventModule: {
				module: query.MoveEventModule.module,
				package: (await this.core.mvr.resolvePackage({ package: query.MoveEventModule.package })).package
			}
		};
		if ("MoveModule" in query && isValidNamedPackage(query.MoveModule.package)) query = {
			...query,
			MoveModule: {
				module: query.MoveModule.module,
				package: (await this.core.mvr.resolvePackage({ package: query.MoveModule.package })).package
			}
		};
		return await this.transport.request({
			method: "suix_queryEvents",
			params: [
				query,
				cursor,
				limit,
				(order || "descending") === "descending"
			],
			signal
		});
	}
	/**
	* Subscribe to get notifications whenever an event matching the filter occurs
	*
	* @deprecated
	*/
	async subscribeEvent(input) {
		return this.transport.subscribe({
			method: "suix_subscribeEvent",
			unsubscribe: "suix_unsubscribeEvent",
			params: [input.filter],
			onMessage: input.onMessage,
			signal: input.signal
		});
	}
	/**
	* @deprecated
	*/
	async subscribeTransaction(input) {
		return this.transport.subscribe({
			method: "suix_subscribeTransaction",
			unsubscribe: "suix_unsubscribeTransaction",
			params: [input.filter],
			onMessage: input.onMessage,
			signal: input.signal
		});
	}
	/**
	* Runs the transaction block in dev-inspect mode. Which allows for nearly any
	* transaction (or Move call) with any arguments. Detailed results are
	* provided, including both the transaction effects and any return values.
	*/
	async devInspectTransactionBlock(input) {
		let devInspectTxBytes;
		if (isTransaction(input.transactionBlock)) {
			input.transactionBlock.setSenderIfNotSet(input.sender);
			devInspectTxBytes = toBase64(await input.transactionBlock.build({
				client: this,
				onlyTransactionKind: true
			}));
		} else if (typeof input.transactionBlock === "string") devInspectTxBytes = input.transactionBlock;
		else if (input.transactionBlock instanceof Uint8Array) devInspectTxBytes = toBase64(input.transactionBlock);
		else throw new Error("Unknown transaction block format.");
		input.signal?.throwIfAborted();
		return await this.transport.request({
			method: "sui_devInspectTransactionBlock",
			params: [
				input.sender,
				devInspectTxBytes,
				input.gasPrice?.toString(),
				input.epoch
			],
			signal: input.signal
		});
	}
	/**
	* Dry run a transaction block and return the result.
	*/
	async dryRunTransactionBlock(input) {
		return await this.transport.request({
			method: "sui_dryRunTransactionBlock",
			params: [typeof input.transactionBlock === "string" ? input.transactionBlock : toBase64(input.transactionBlock)]
		});
	}
	/**
	* Return the list of dynamic field objects owned by an object
	*/
	async getDynamicFields(input) {
		if (!input.parentId || !isValidSuiObjectId(normalizeSuiObjectId(input.parentId))) throw new Error("Invalid Sui Object id");
		return await this.transport.request({
			method: "suix_getDynamicFields",
			params: [
				input.parentId,
				input.cursor,
				input.limit
			],
			signal: input.signal
		});
	}
	/**
	* Return the dynamic field object information for a specified object
	*/
	async getDynamicFieldObject(input) {
		return await this.transport.request({
			method: "suix_getDynamicFieldObject",
			params: [input.parentId, input.name],
			signal: input.signal
		});
	}
	/**
	* Get the sequence number of the latest checkpoint that has been executed
	*/
	async getLatestCheckpointSequenceNumber({ signal } = {}) {
		const resp = await this.transport.request({
			method: "sui_getLatestCheckpointSequenceNumber",
			params: [],
			signal
		});
		return String(resp);
	}
	/**
	* Returns information about a given checkpoint
	*/
	async getCheckpoint(input) {
		return await this.transport.request({
			method: "sui_getCheckpoint",
			params: [input.id],
			signal: input.signal
		});
	}
	/**
	* Returns historical checkpoints paginated
	*/
	async getCheckpoints(input) {
		return await this.transport.request({
			method: "sui_getCheckpoints",
			params: [
				input.cursor,
				input?.limit,
				input.descendingOrder
			],
			signal: input.signal
		});
	}
	/**
	* Return the committee information for the asked epoch
	*/
	async getCommitteeInfo(input) {
		return await this.transport.request({
			method: "suix_getCommitteeInfo",
			params: [input?.epoch],
			signal: input?.signal
		});
	}
	async getNetworkMetrics({ signal } = {}) {
		return await this.transport.request({
			method: "suix_getNetworkMetrics",
			params: [],
			signal
		});
	}
	async getAddressMetrics({ signal } = {}) {
		return await this.transport.request({
			method: "suix_getLatestAddressMetrics",
			params: [],
			signal
		});
	}
	async getEpochMetrics(input) {
		return await this.transport.request({
			method: "suix_getEpochMetrics",
			params: [
				input?.cursor,
				input?.limit,
				input?.descendingOrder
			],
			signal: input?.signal
		});
	}
	async getAllEpochAddressMetrics(input) {
		return await this.transport.request({
			method: "suix_getAllEpochAddressMetrics",
			params: [input?.descendingOrder],
			signal: input?.signal
		});
	}
	/**
	* Return the committee information for the asked epoch
	*/
	async getEpochs(input) {
		return await this.transport.request({
			method: "suix_getEpochs",
			params: [
				input?.cursor,
				input?.limit,
				input?.descendingOrder
			],
			signal: input?.signal
		});
	}
	/**
	* Returns list of top move calls by usage
	*/
	async getMoveCallMetrics({ signal } = {}) {
		return await this.transport.request({
			method: "suix_getMoveCallMetrics",
			params: [],
			signal
		});
	}
	/**
	* Return the committee information for the asked epoch
	*/
	async getCurrentEpoch({ signal } = {}) {
		return await this.transport.request({
			method: "suix_getCurrentEpoch",
			params: [],
			signal
		});
	}
	/**
	* Return the Validators APYs
	*/
	async getValidatorsApy({ signal } = {}) {
		return await this.transport.request({
			method: "suix_getValidatorsApy",
			params: [],
			signal
		});
	}
	async getChainIdentifier({ signal } = {}) {
		return toHex(fromBase58((await this.getCheckpoint({
			id: "0",
			signal
		})).digest).slice(0, 4));
	}
	async resolveNameServiceAddress(input) {
		return await this.transport.request({
			method: "suix_resolveNameServiceAddress",
			params: [input.name],
			signal: input.signal
		});
	}
	async resolveNameServiceNames({ format = "dot", ...input }) {
		const { nextCursor, hasNextPage, data } = await this.transport.request({
			method: "suix_resolveNameServiceNames",
			params: [
				input.address,
				input.cursor,
				input.limit
			],
			signal: input.signal
		});
		return {
			hasNextPage,
			nextCursor,
			data: data.map((name) => normalizeSuiNSName(name, format))
		};
	}
	async getProtocolConfig(input) {
		return await this.transport.request({
			method: "sui_getProtocolConfig",
			params: [input?.version],
			signal: input?.signal
		});
	}
	async verifyZkLoginSignature(input) {
		return await this.transport.request({
			method: "sui_verifyZkLoginSignature",
			params: [
				input.bytes,
				input.signature,
				input.intentScope,
				input.author
			],
			signal: input.signal
		});
	}
	/**
	* Wait for a transaction block result to be available over the API.
	* This can be used in conjunction with `executeTransactionBlock` to wait for the transaction to
	* be available via the API.
	* This currently polls the `getTransactionBlock` API to check for the transaction.
	*/
	async waitForTransaction({ signal, timeout = 60 * 1e3, pollInterval = 2 * 1e3, ...input }) {
		const timeoutSignal = AbortSignal.timeout(timeout);
		const timeoutPromise = new Promise((_, reject) => {
			timeoutSignal.addEventListener("abort", () => reject(timeoutSignal.reason));
		});
		timeoutPromise.catch(() => {});
		while (!timeoutSignal.aborted) {
			signal?.throwIfAborted();
			try {
				return await this.getTransactionBlock(input);
			} catch {
				await Promise.race([new Promise((resolve) => setTimeout(resolve, pollInterval)), timeoutPromise]);
			}
		}
		timeoutSignal.throwIfAborted();
		throw new Error("Unexpected error while waiting for transaction block.");
	}
};

//#endregion
export { JsonRpcError as a, JsonRpcHTTPTransport as i, isSuiJsonRpcClient as n, SuiHTTPStatusError as o, getFullnodeUrl as r, SuiHTTPTransportError as s, SuiJsonRpcClient as t };
//# sourceMappingURL=client-M2E3EHme.js.map